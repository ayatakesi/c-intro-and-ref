This is c, produced by makeinfo version 6.8 from c.texi.

Copyright © 2022 Richard Stallman and Free Software Foundation, Inc.

   (The work of Trevis Rothwell and Nelson Beebe has been assigned or
licensed to the FSF.)

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with the Invariant Sections being “GNU General Public
     License,” with the Front-Cover Texts being “A GNU Manual,” and with
     the Back-Cover Texts as in (a) below.  A copy of the license is
     included in the section entitled “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and
     modify this GNU manual.  Buying copies from the FSF supports it in
     developing GNU and promoting software freedom.”
INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* C: (c).       GNU C Language Intro and Reference Manual
END-INFO-DIR-ENTRY


File: c,  Node: Declaring Arrays and Pointers,  Next: Combining Variable Declarations,  Up: Variable Declarations

20.1.1 Declaring Arrays and Pointers
------------------------------------

To declare a variable that is an array, write ‘VARIABLE[LENGTH]’ for
DECORATED-VARIABLE:

     int foo[5];

   To declare a variable that has a pointer type, write ‘*VARIABLE’ for
DECORATED-VARIABLE:

     struct list_elt *foo;

   These constructs nest.  For instance,

     int foo[3][5];

declares ‘foo’ as an array of 3 arrays of 5 integers each,

     struct list_elt *foo[5];

declares ‘foo’ as an array of 5 pointers to structures, and

     struct list_elt **foo;

declares ‘foo’ as a pointer to a pointer to a structure.

     int **(*foo[30])(int, double);

declares ‘foo’ as an array of 30 pointers to functions (*note Function
Pointers::), each of which must accept two arguments (one ‘int’ and one
‘double’) and return type ‘int **’.

     void
     bar (int size)
     {
       int foo[size];
       ...
     }

declares ‘foo’ as an array of integers with a size specified at run time
when the function ‘bar’ is called.


File: c,  Node: Combining Variable Declarations,  Prev: Declaring Arrays and Pointers,  Up: Variable Declarations

20.1.2 Combining Variable Declarations
--------------------------------------

When multiple declarations have the same KEYWORDS and BASETYPE, you can
combine them using commas.  Thus,

     KEYWORDS BASETYPE
        DECORATED-VARIABLE-1 [= INIT1],
        DECORATED-VARIABLE-2 [= INIT2];

is equivalent to

     KEYWORDS BASETYPE
        DECORATED-VARIABLE-1 [= INIT1];
     KEYWORDS BASETYPE
        DECORATED-VARIABLE-2 [= INIT2];

   Here are some simple examples:

     int a, b;
     int a = 1, b = 2;
     int a, *p, array[5];
     int a = 0, *p = &a, array[5] = {1, 2};

In the last two examples, ‘a’ is an ‘int’, ‘p’ is a pointer to ‘int’,
and ‘array’ is an array of 5 ‘int’s.  Since the initializer for ‘array’
specifies only two elements, the other three elements are initialized to
zero.


File: c,  Node: Initializers,  Next: Designated Inits,  Prev: Variable Declarations,  Up: Variables

20.2 Initializers
=================

A variable’s declaration, unless it is ‘extern’, should also specify its
initial value.  For numeric and pointer-type variables, the initializer
is an expression for the value.  If necessary, it is converted to the
variable’s type, just as in an assignment.

   You can also initialize a local structure-type (*note Structures::)
or local union-type (*note Unions::) variable this way, from an
expression whose value has the same type.  But you can’t initialize an
array this way (*note Arrays::), since arrays are not first-class
objects in C (*note Limitations of C Arrays::) and there is no array
assignment.

   You can initialize arrays and structures componentwise, with a list
of the elements or components.  You can initialize a union with any one
of its alternatives.

   • A component-wise initializer for an array consists of element
     values surrounded by ‘{...}’.  If the values in the initializer
     don’t cover all the elements in the array, the remaining elements
     are initialized to zero.

     You can omit the size of the array when you declare it, and let the
     initializer specify the size:

          int array[] = { 3, 9, 12 };

   • A component-wise initializer for a structure consists of field
     values surrounded by ‘{...}’.  Write the field values in the same
     order as the fields are declared in the structure.  If the values
     in the initializer don’t cover all the fields in the structure, the
     remaining fields are initialized to zero.

   • The initializer for a union-type variable has the form ‘{ VALUE }’,
     where VALUE initializes the _first alternative_ in the union
     definition.

   For an array of arrays, a structure containing arrays, an array of
structures, etc., you can nest these constructs.  For example,

     struct point { double x, y; };

     struct point series[]
       = { {0, 0}, {1.5, 2.8}, {99, 100.0004} };

   You can omit a pair of inner braces if they contain the right number
of elements for the sub-value they initialize, so that no elements or
fields need to be filled in with zeros.  But don’t do that very much, as
it gets confusing.

   An array of ‘char’ can be initialized using a string constant.
Recall that the string constant includes an implicit null character at
the end (*note String Constants::).  Using a string constant as
initializer means to use its contents as the initial values of the array
elements.  Here are examples:

     char text[6] = "text!";     /* Includes the null. */
     char text[5] = "text!";     /* Excludes the null. */
     char text[] = "text!";      /* Gets length 6. */
     char text[]
       = { 't', 'e', 'x', 't', '!', 0 };  /* same as above. */
     char text[] = { "text!" };  /* Braces are optional. */

and this kind of initializer can be nested inside braces to initialize
structures or arrays that contain a ‘char’-array.

   In like manner, you can use a wide string constant to initialize an
array of ‘wchar_t’.


File: c,  Node: Designated Inits,  Next: Auto Type,  Prev: Initializers,  Up: Variables

20.3 Designated Initializers
============================

In a complex structure or long array, it’s useful to indicate which
field or element we are initializing.

   To designate specific array elements during initialization, include
the array index in brackets, and an assignment operator, for each
element:

     int foo[10] = { [3] = 42, [7] = 58 };

This does the same thing as:

     int foo[10] = { 0, 0, 0, 42, 0, 0, 0, 58, 0, 0 };

   The array initialization can include non-designated element values
alongside designated indices; these follow the expected ordering of the
array initialization, so that

     int foo[10] = { [3] = 42, 43, 44, [7] = 58 };

does the same thing as:

     int foo[10] = { 0, 0, 0, 42, 43, 44, 0, 58, 0, 0 };

   Note that you can only use constant expressions as array index
values, not variables.

   If you need to initialize a subsequence of sequential array elements
to the same value, you can specify a range:

     int foo[100] = { [0 ... 19] = 42, [20 ... 99] = 43 };

Using a range this way is a GNU C extension.

   When subsequence ranges overlap, each element is initialized by the
last specification that applies to it.  Thus, this initialization is
equivalent to the previous one.

     int foo[100] = { [0 ... 99] = 43, [0 ... 19] = 42 };

as the second overrides the first for elements 0 through 19.

   The value used to initialize a range of elements is evaluated only
once, for the first element in the range.  So for example, this code

     int random_values[100]
       = { [0 ... 99] = get_random_number() };

would initialize all 100 elements of the array ‘random_values’ to the
same value—probably not what is intended.

   Similarly, you can initialize specific fields of a structure variable
by specifying the field name prefixed with a dot:

     struct point { int x; int y; };

     struct point foo = { .y = 42; };

The same syntax works for union variables as well:

     union int_double { int i; double d; };

     union int_double foo = { .d = 34 };

This casts the integer value 34 to a double and stores it in the union
variable ‘foo’.

   You can designate both array elements and structure elements in the
same initialization; for example, here’s an array of point structures:

     struct point point_array[10] = { [4].y = 32, [6].y = 39 };

   Along with the capability to specify particular array and structure
elements to initialize comes the possibility of initializing the same
element more than once:

     int foo[10] = { [4] = 42, [4] = 98 };

In such a case, the last initialization value is retained.


File: c,  Node: Auto Type,  Next: Local Variables,  Prev: Designated Inits,  Up: Variables

20.4 Referring to a Type with ‘__auto_type’
===========================================

You can declare a variable copying the type from the initializer by
using ‘__auto_type’ instead of a particular type.  Here’s an example:

     #define max(a,b) \
       ({ __auto_type _a = (a); \
           __auto_type _b = (b); \
         _a > _b ? _a : _b })

   This defines ‘_a’ to be of the same type as ‘a’, and ‘_b’ to be of
the same type as ‘b’.  This is a useful thing to do in a macro that
ought to be able to handle any type of data (*note Macros and Auto
Type::).

   The original GNU C method for obtaining the type of a value is to use
‘typeof’, which takes as an argument either a value or the name of a
type.  The previous example could also be written as:

     #define max(a,b) \
       ({ typeof(a) _a = (a); \
           typeof(b) _b = (b); \
         _a > _b ? _a : _b })

   ‘typeof’ is more flexible than ‘__auto_type’; however, the principal
use case for ‘typeof’ is in variable declarations with initialization,
which is exactly what ‘__auto_type’ handles.


File: c,  Node: Local Variables,  Next: File-Scope Variables,  Prev: Auto Type,  Up: Variables

20.5 Local Variables
====================

Declaring a variable inside a function definition (*note Function
Definitions::) makes the variable name “local” to the containing
block—that is, the containing pair of braces.  More precisely, the
variable’s name is visible starting just after where it appears in the
declaration, and its visibility continues until the end of the block.

   Local variables in C are generally “automatic” variables: each
variable’s storage exists only from the declaration to the end of the
block.  Execution of the declaration allocates the storage, computes the
initial value, and stores it in the variable.  The end of the block
deallocates the storage.(1)

   *Warning:* Two declarations for the same local variable in the same
scope are an error.

   *Warning:* Automatic variables are stored in the run-time stack.  The
total space for the program’s stack may be limited; therefore, in using
very large arrays, it may be necessary to allocate them in some other
way to stop the program from crashing.

   *Warning:* If the declaration of an automatic variable does not
specify an initial value, the variable starts out containing garbage.
In this example, the value printed could be anything at all:

     {
       int i;

       printf ("Print junk %d\n", i);
     }

   In a simple test program, that statement is likely to print 0, simply
because every process starts with memory zeroed.  But don’t rely on it
to be zero—that is erroneous.

   *Note:* Make sure to store a value into each local variable (by
assignment, or by initialization) before referring to its value.

   ---------- Footnotes ----------

   (1) Due to compiler optimizations, allocation and deallocation don’t
necessarily really happen at those times.


File: c,  Node: File-Scope Variables,  Next: Static Local Variables,  Prev: Local Variables,  Up: Variables

20.6 File-Scope Variables
=========================

A variable declaration at the top level in a file (not inside a function
definition) declares a “file-scope variable”.  Loading a program
allocates the storage for all the file-scope variables in it, and
initializes them too.

   Each file-scope variable is either “static” (limited to one
compilation module) or “global” (shared with all compilation modules in
the program).  To make the variable static, write the keyword ‘static’
at the start of the declaration.  Omitting ‘static’ makes the variable
global.

   The initial value for a file-scope variable can’t depend on the
contents of storage, and can’t call any functions.

     int foo = 5;         /* Valid. */
     int bar = foo;       /* Invalid! */
     int bar = sin (1.0); /* Invalid! */

   But it can use the address of another file-scope variable:

     int foo;
     int *bar = &foo;     /* Valid. */
     int arr[5];
     int *bar3 = &arr[3]; /* Valid. */
     int *bar4 = arr + 4; /* Valid. */

   It is valid for a module to have multiple declarations for a
file-scope variable, as long as they are all global or all static, but
at most one declaration can specify an initial value for it.


File: c,  Node: Static Local Variables,  Next: Extern Declarations,  Prev: File-Scope Variables,  Up: Variables

20.7 Static Local Variables
===========================

The keyword ‘static’ in a local variable declaration says to allocate
the storage for the variable permanently, just like a file-scope
variable, even if the declaration is within a function.

   Here’s an example:

     int
     increment_counter ()
     {
       static int counter = 0;
       return ++counter;
     }

   The scope of the name ‘counter’ runs from the declaration to the end
of the containing block, just like an automatic local variable, but its
storage is permanent, so the value persists from one call to the next.
As a result, each call to ‘increment_counter’ returns a different,
unique value.

   The initial value of a static local variable has the same limitations
as for file-scope variables: it can’t depend on the contents of storage
or call any functions.  It can use the address of a file-scope variable
or a static local variable, because those addresses are determined
before the program runs.


File: c,  Node: Extern Declarations,  Next: Allocating File-Scope,  Prev: Static Local Variables,  Up: Variables

20.8 ‘extern’ Declarations
==========================

An ‘extern’ declaration is used to refer to a global variable whose
principal declaration comes elsewhere—in the same module, or in another
compilation module.  It looks like this:

     extern BASETYPE DECORATED-VARIABLE;

   Its meaning is that, in the current scope, the variable name refers
to the file-scope variable of that name—which needs to be declared in a
non-‘extern’, non-‘static’ way somewhere else.

   For instance, if one compilation module has this global variable
declaration

     int error_count = 0;

then other compilation modules can specify this

     extern int error_count;

to allow reference to the same variable.

   The usual place to write an ‘extern’ declaration is at top level in a
source file, but you can write an ‘extern’ declaration inside a block to
make a global or static file-scope variable accessible in that block.

   Since an ‘extern’ declaration does not allocate space for the
variable, it can omit the size of an array:

     extern int array[];

   You can use ‘array’ normally in all contexts where it is converted
automatically to a pointer.  However, to use it as the operand of
‘sizeof’ is an error, since the size is unknown.

   It is valid to have multiple ‘extern’ declarations for the same
variable, even in the same scope, if they give the same type.  They do
not conflict—they agree.  For an array, it is legitimate for some
‘extern’ declarations can specify the size while others omit it.
However, if two declarations give different sizes, that is an error.

   Likewise, you can use ‘extern’ declarations at file scope (*note
File-Scope Variables::) followed by an ordinary global (non-static)
declaration of the same variable.  They do not conflict, because they
say compatible things about the same meaning of the variable.


File: c,  Node: Allocating File-Scope,  Next: auto and register,  Prev: Extern Declarations,  Up: Variables

20.9 Allocating File-Scope Variables
====================================

Some file-scope declarations allocate space for the variable, and some
don’t.

   A file-scope declaration with an initial value _must_ allocate space
for the variable; if there are two of such declarations for the same
variable, even in different compilation modules, they conflict.

   An ‘extern’ declaration _never_ allocates space for the variable.  If
all the top-level declarations of a certain variable are ‘extern’, the
variable never gets memory space.  If that variable is used anywhere in
the program, the use will be reported as an error, saying that the
variable is not defined.

   A file-scope declaration without an initial value is called a
“tentative definition”.  This is a strange hybrid: it _can_ allocate
space for the variable, but does not insist.  So it causes no conflict,
no error, if the variable has another declaration that allocates space
for it, perhaps in another compilation module.  But if nothing else
allocates space for the variable, the tentative definition will do it.
Any number of compilation modules can declare the same variable in this
way, and that is sufficient for all of them to use the variable.

   In programs that are very large or have many contributors, it may be
wise to adopt the convention of never using tentative definitions.  You
can use the compilation option ‘-fno-common’ to make them an error, or
‘--warn-common’ to warn about them.

   If a file-scope variable gets its space through a tentative
definition, it starts out containing all zeros.


File: c,  Node: auto and register,  Next: Omitting Types,  Prev: Allocating File-Scope,  Up: Variables

20.10 ‘auto’ and ‘register’
===========================

For historical reasons, you can write ‘auto’ or ‘register’ before a
local variable declaration.  ‘auto’ merely emphasizes that the variable
isn’t static; it changes nothing.

   ‘register’ suggests to the compiler storing this variable in a
register.  However, GNU C ignores this suggestion, since it can choose
the best variables to store in registers without any hints.

   It is an error to take the address of a variable declared ‘register’,
so you cannot use the unary ‘&’ operator on it.  If the variable is an
array, you can’t use it at all (other than as the operand of ‘sizeof’),
which makes it rather useless.


File: c,  Node: Omitting Types,  Prev: auto and register,  Up: Variables

20.11 Omitting Types in Declarations
====================================

The syntax of C traditionally allows omitting the data type in a
declaration if it specifies a storage class, a type qualifier (see the
next chapter), or ‘auto’ or ‘register’.  Then the type defaults to
‘int’.  For example:

     auto foo = 42;

   This is bad practice; if you see it, fix it.


File: c,  Node: Type Qualifiers,  Next: Functions,  Prev: Variables,  Up: Top

21 Type Qualifiers
******************

A declaration can include type qualifiers to advise the compiler about
how the variable will be used.  There are three different qualifiers,
‘const’, ‘volatile’ and ‘restrict’.  They pertain to different issues,
so you can use more than one together.  For instance, ‘const volatile’
describes a value that the program is not allowed to change, but might
have a different value each time the program examines it.  (This might
perhaps be a special hardware register, or part of shared memory.)

   If you are just learning C, you can skip this chapter.

* Menu:

* const::                        Variables whose values don’t change.
* volatile::                     Variables whose values may be accessed
                                   or changed outside of the control of
                                   this program.
* restrict Pointers::            Restricted pointers for code optimization.
* restrict Pointer Example::     Example of how that works.


File: c,  Node: const,  Next: volatile,  Up: Type Qualifiers

21.1 ‘const’ Variables and Fields
=================================

You can mark a variable as “constant” by writing ‘const’ in front of the
declaration.  This says to treat any assignment to that variable as an
error.  It may also permit some compiler optimizations—for instance, to
fetch the value only once to satisfy multiple references to it.  The
construct looks like this:

     const double pi = 3.14159;

   After this definition, the code can use the variable ‘pi’ but cannot
assign a different value to it.

     pi = 3.0; /* Error! */

   Simple variables that are constant can be used for the same purposes
as enumeration constants, and they are not limited to integers.  The
constantness of the variable propagates into pointers, too.

   A pointer type can specify that the _target_ is constant.  For
example, the pointer type ‘const double *’ stands for a pointer to a
constant ‘double’.  That’s the typethat results from taking the address
of ‘pi’.  Such a pointer can’t be dereferenced in the left side of an
assignment.

     *(&pi) = 3.0; /* Error! */

   Nonconstant pointers can be converted automatically to constant
pointers, but not vice versa.  For instance,

     const double *cptr;
     double *ptr;

     cptr = &pi;    /* Valid. */
     cptr = ptr;    /* Valid. */
     ptr = cptr;    /* Error! */
     ptr = &pi;     /* Error! */

   This is not an ironclad protection against modifying the value.  You
can always cast the constant pointer to a nonconstant pointer type:

     ptr = (double *)cptr;    /* Valid. */
     ptr = (double *)&pi;     /* Valid. */

   However, ‘const’ provides a way to show that a certain function won’t
modify the data structure whose address is passed to it.  Here’s an
example:

     int
     string_length (const char *string)
     {
       int count = 0;
       while (*string++)
         count++;
       return count;
     }

Using ‘const char *’ for the parameter is a way of saying this function
never modifies the memory of the string itself.

   In calling ‘string_length’, you can specify an ordinary ‘char *’
since that can be converted automatically to ‘const char *’.


File: c,  Node: volatile,  Next: restrict Pointers,  Prev: const,  Up: Type Qualifiers

21.2 ‘volatile’ Variables and Fields
====================================

The GNU C compiler often performs optimizations that eliminate the need
to write or read a variable.  For instance,

     int foo;
     foo = 1;
     foo++;

might simply store the value 2 into ‘foo’, without ever storing 1.
These optimizations can also apply to structure fields in some cases.

   If the memory containing ‘foo’ is shared with another program, or if
it is examined asynchronously by hardware, such optimizations could
confuse the communication.  Using ‘volatile’ is one way to prevent them.

   Writing ‘volatile’ with the type in a variable or field declaration
says that the value may be examined or changed for reasons outside the
control of the program at any moment.  Therefore, the program must
execute in a careful way to assure correct interaction with those
accesses, whenever they may occur.

   The simplest use looks like this:

     volatile int lock;

   This directs the compiler not to do certain common optimizations on
use of the variable ‘lock’.  All the reads and writes for a volatile
variable or field are really done, and done in the order specified by
the source code.  Thus, this code:

     lock = 1;
     list = list->next;
     if (lock)
       lock_broken (&lock);
     lock = 0;

really stores the value 1 in ‘lock’, even though there is no sign it is
really used, and the ‘if’ statement reads and checks the value of
‘lock’, rather than assuming it is still 1.

   A limited amount of optimization can be done, in principle, on
‘volatile’ variables and fields: multiple references between two
sequence points (*note Sequence Points::) can be simplified together.

   Use of ‘volatile’ does not eliminate the flexibility in ordering the
computation of the operands of most operators.  For instance, in ‘lock +
foo ()’, the order of accessing ‘lock’ and calling ‘foo’ is not
specified, so they may be done in either order; the fact that ‘lock’ is
‘volatile’ has no effect on that.


File: c,  Node: restrict Pointers,  Next: restrict Pointer Example,  Prev: volatile,  Up: Type Qualifiers

21.3 ‘restrict’-Qualified Pointers
==================================

You can declare a pointer as “restricted” using the ‘restrict’ type
qualifier, like this:

     int *restrict p = x;

This enables better optimization of code that uses the pointer.

   If ‘p’ is declared with ‘restrict’, and then the code references the
object that ‘p’ points to (using ‘*p’ or ‘p[I]’), the ‘restrict’
declaration promises that the code will not access that object in any
other way—only through ‘p’.

   For instance, it means the code must not use another pointer to
access the same space, as shown here:

     int *restrict p = WHATEVER;
     int *q = p;
     foo (*p, *q);

That contradicts the ‘restrict’ promise by accessing the object that ‘p’
points to using ‘q’, which bypasses ‘p’.  Likewise, it must not do this:

     int *restrict p = WHATEVER;
     struct { int *a, *b; } s;
     s.a = p;
     foo (*p, *s.a);

This example uses a structure field instead of the variable ‘q’ to hold
the other pointer, and that contradicts the promise just the same.

   The keyword ‘restrict’ also promises that ‘p’ won’t point to the
allocated space of any automatic or static variable.  So the code must
not do this:

     int a;
     int *restrict p = &a;
     foo (*p, a);

because that does direct access to the object (‘a’) that ‘p’ points to,
which bypasses ‘p’.

   If the code makes such promises with ‘restrict’ then breaks them,
execution is unpredictable.


File: c,  Node: restrict Pointer Example,  Prev: restrict Pointers,  Up: Type Qualifiers

21.4 ‘restrict’ Pointer Example
===============================

Here are examples where ‘restrict’ enables real optimization.

   In this example, ‘restrict’ assures GCC that the array ‘out’ points
to does not overlap with the array ‘in’ points to.

     void
     process_data (const char *in,
                   char * restrict out,
                   size_t size)
     {
       for (i = 0; i < size; i++)
         out[i] = in[i] + in[i + 1];
     }

   Here’s a simple tree structure, where each tree node holds data of
type ‘PAYLOAD’ plus two subtrees.

     struct foo
       {
         PAYLOAD payload;
         struct foo *left;
         struct foo *right;
       };

   Now here’s a function to null out both pointers in the ‘left’
subtree.

     void
     null_left (struct foo *a)
     {
       a->left->left = NULL;
       a->left->right = NULL;
     }

   Since ‘*a’ and ‘*a->left’ have the same data type, they could
legitimately alias (*note Aliasing::).  Therefore, the compiled code for
‘null_left’ must read ‘a->left’ again from memory when executing the
second assignment statement.

   We can enable optimization, so that it does not need to read
‘a->left’ again, by writing ‘null_left’ this in a less obvious way.

     void
     null_left (struct foo *a)
     {
       struct foo *b = a->left;
       b->left = NULL;
       b->right = NULL;
     }

   A more elegant way to fix this is with ‘restrict’.

     void
     null_left (struct foo *restrict a)
     {
       a->left->left = NULL;
       a->left->right = NULL;
     }

   Declaring ‘a’ as ‘restrict’ asserts that other pointers such as
‘a->left’ will not point to the same memory space as ‘a’.  Therefore,
the memory location ‘a->left->left’ cannot be the same memory as
‘a->left’.  Knowing this, the compiled code may avoid reloading
‘a->left’ for the second statement.


File: c,  Node: Functions,  Next: Compatible Types,  Prev: Type Qualifiers,  Up: Top

22 Functions
************

We have already presented many examples of functions, so if you’ve read
this far, you basically understand the concept of a function.  It is
vital, nonetheless, to have a chapter in the manual that collects all
the information about functions.

* Menu:

* Function Definitions::         Writing the body of a function.
* Function Declarations::        Declaring the interface of a function.
* Function Calls::               Using functions.
* Function Call Semantics::      Call-by-value argument passing.
* Function Pointers::            Using references to functions.
* The main Function::            Where execution of a GNU C program begins.
* Advanced Definitions::         Advanced features of function definitions.
* Obsolete Definitions::         Obsolete features still used
                                   in function definitions in old code.


File: c,  Node: Function Definitions,  Next: Function Declarations,  Up: Functions

22.1 Function Definitions
=========================

We have already presented many examples of function definitions.  To
summarize the rules, a function definition looks like this:

     RETURNTYPE
     FUNCTIONNAME (PARM_DECLARATIONS...)
     {
       BODY
     }

   The part before the open-brace is called the “function header”.

   Write ‘void’ as the RETURNTYPE if the function does not return a
value.

* Menu:

* Function Parameter Variables::     Syntax and semantics
                                       of function parameters.
* Forward Function Declarations::    Functions can only be called after
                                       they have been defined or declared.
* Static Functions::                 Limiting visibility of a function.
* Arrays as Parameters::             Functions that accept array arguments.
* Structs as Parameters::            Functions that accept structure arguments.


File: c,  Node: Function Parameter Variables,  Next: Forward Function Declarations,  Up: Function Definitions

22.1.1 Function Parameter Variables
-----------------------------------

A function parameter variable is a local variable (*note Local
Variables::) used within the function to store the value passed as an
argument in a call to the function.  Usually we say “function parameter”
or “parameter” for short, not mentioning the fact that it’s a variable.

   We declare these variables in the beginning of the function
definition, in the “parameter list”.  For example,

     fib (int n)

has a parameter list with one function parameter ‘n’, which has type
‘int’.

   Function parameter declarations differ from ordinary variable
declarations in several ways:

   • Inside the function definition header, commas separate parameter
     declarations, and each parameter needs a complete declaration
     including the type.  For instance, if a function ‘foo’ has two
     ‘int’ parameters, write this:

          foo (int a, int b)

     You can’t share the common ‘int’ between the two declarations:

          foo (int a, b)      /* Invalid! */

   • A function parameter variable is initialized to whatever value is
     passed in the function call, so its declaration cannot specify an
     initial value.

   • Writing an array type in a function parameter declaration has the
     effect of declaring it as a pointer.  The size specified for the
     array has no effect at all, and we normally omit the size.  Thus,

          foo (int a[5])
          foo (int a[])
          foo (int *a)

     are equivalent.

   • The scope of the parameter variables is the entire function body,
     notwithstanding the fact that they are written in the function
     header, which is just outside the function body.

   If a function has no parameters, it would be most natural for the
list of parameters in its definition to be empty.  But that, in C, has a
special meaning for historical reasons: “Do not check that calls to this
function have the right number of arguments.” Thus,

     int
     foo ()
     {
       return 5;
     }

     int
     bar (int x)
     {
       return foo (x);
     }

would not report a compilation error in passing ‘x’ as an argument to
‘foo’.  By contrast,

     int
     foo (void)
     {
       return 5;
     }

     int
     bar (int x)
     {
       return foo (x);
     }

would report an error because ‘foo’ is supposed to receive no arguments.


File: c,  Node: Forward Function Declarations,  Next: Static Functions,  Prev: Function Parameter Variables,  Up: Function Definitions

22.1.2 Forward Function Declarations
------------------------------------

The order of the function definitions in the source code makes no
difference, except that each function needs to be defined or declared
before code uses it.

   The definition of a function also declares its name for the rest of
the containing scope.  But what if you want to call the function before
its definition?  To permit that, write a compatible declaration of the
same function, before the first call.  A declaration that prefigures a
subsequent definition in this way is called a “forward declaration”.
The function declaration can be at top level or within a block, and it
applies until the end of the containing scope.

   *Note Function Declarations::, for more information about these
declarations.


File: c,  Node: Static Functions,  Next: Arrays as Parameters,  Prev: Forward Function Declarations,  Up: Function Definitions

22.1.3 Static Functions
-----------------------

The keyword ‘static’ in a function definition limits the visibility of
the name to the current compilation module.  (That’s the same thing
‘static’ does in variable declarations; *note File-Scope Variables::.)
For instance, if one compilation module contains this code:

     static int
     foo (void)
     {
       ...
     }

then the code of that compilation module can call ‘foo’ anywhere after
the definition, but other compilation modules cannot refer to it at all.

   To call ‘foo’ before its definition, it needs a forward declaration,
which should use ‘static’ since the function definition does.  For this
function, it looks like this:

     static int foo (void);

   It is generally wise to use ‘static’ on the definitions of functions
that won’t be called from outside the same compilation module.  This
makes sure that calls are not added in other modules.  If programmers
decide to change the function’s calling convention, or understand all
the consequences of its use, they will only have to check for calls in
the same compilation module.


File: c,  Node: Arrays as Parameters,  Next: Structs as Parameters,  Prev: Static Functions,  Up: Function Definitions

22.1.4 Arrays as Parameters
---------------------------

Arrays in C are not first-class objects: it is impossible to copy them.
So they cannot be passed as arguments like other values.  *Note
Limitations of C Arrays::.  Rather, array parameters work in a special
way.

* Menu:

* Array Parm Pointer::
* Passing Array Args::
* Array Parm Qualifiers::


File: c,  Node: Array Parm Pointer,  Next: Passing Array Args,  Up: Arrays as Parameters

22.1.4.1 Array parameters are pointers
......................................

Declaring a function parameter variable as an array really gives it a
pointer type.  C does this because an expression with array type, if
used as an argument in a function call, is converted automatically to a
pointer (to the zeroth element of the array).  If you declare the
corresponding parameter as an “array”, it will work correctly with the
pointer value that really gets passed.

   This relates to the fact that C does not check array bounds in access
to elements of the array (*note Accessing Array Elements::).

   For example, in this function,

     void
     clobber4 (int array[20])
     {
       array[4] = 0;
     }

the parameter ‘array’’s real type is ‘int *’; the specified length, 20,
has no effect on the program.  You can leave out the length and write
this:

     void
     clobber4 (int array[])
     {
       array[4] = 0;
     }

or write the parameter declaration explicitly as a pointer:

     void
     clobber4 (int *array)
     {
       array[4] = 0;
     }

   They are all equivalent.


File: c,  Node: Passing Array Args,  Next: Array Parm Qualifiers,  Prev: Array Parm Pointer,  Up: Arrays as Parameters

22.1.4.2 Passing array arguments
................................

The function call passes this pointer by value, like all argument values
in C.  However, the result is paradoxical in that the array itself is
passed by reference: its contents are treated as shared memory—shared
between the caller and the called function, that is.  When ‘clobber4’
assigns to element 4 of ‘array’, the effect is to alter element 4 of the
array specified in the call.

     #include <stddef.h>  /* Defines ‘NULL’. */
     #include <stdlib.h>  /* Declares ‘malloc’, */
                          /* Defines ‘EXIT_SUCCESS’. */

     int
     main (void)
     {
       int data[] = {1, 2, 3, 4, 5, 6};
       int i;

       /* Show the initial value of element 4. */
       for (i = 0; i < 6; i++)
         printf ("data[%d] = %d\n", i, data[i]);

       printf ("\n");

       clobber4 (data);

       /* Show that element 4 has been changed. */
       for (i = 0; i < 6; i++)
         printf ("data[%d] = %d\n", i, data[i]);

       printf ("\n");

       return EXIT_SUCCESS;
     }

shows that ‘data[4]’ has become zero after the call to ‘clobber4’.

   The array ‘data’ has 6 elements, but passing it to a function whose
argument type is written as ‘int [20]’ is not an error, because that
really stands for ‘int *’.  The pointer that is the real argument
carries no indication of the length of the array it points into.  It is
not required to point to the beginning of the array, either.  For
instance,

     clobber4 (data+1);

passes an “array” that starts at element 1 of ‘data’, and the effect is
to zero ‘data[5]’ instead of ‘data[4]’.

   If all calls to the function will provide an array of a particular
size, you can specify the size of the array to be ‘static’:

     void
     clobber4 (int array[static 20])
     ...

This is a promise to the compiler that the function will always be
called with an array of 20 elements, so that the compiler can optimize
code accordingly.  If the code breaks this promise and calls the
function with, for example, a shorter array, unpredictable things may
happen.


File: c,  Node: Array Parm Qualifiers,  Prev: Passing Array Args,  Up: Arrays as Parameters

22.1.4.3 Type qualifiers on array parameters
............................................

You can use the type qualifiers ‘const’, ‘restrict’, and ‘volatile’ with
array parameters; for example:

     void
     clobber4 (volatile int array[20])
     ...

denotes that ‘array’ is equivalent to a pointer to a volatile ‘int’.
Alternatively:

     void
     clobber4 (int array[const 20])
     ...

makes the array parameter equivalent to a constant pointer to an ‘int’.
If we want the ‘clobber4’ function to succeed, it would not make sense
to write

     void
     clobber4 (const int array[20])
     ...

as this would tell the compiler that the parameter should point to an
array of constant ‘int’ values, and then we would not be able to store
zeros in them.

   In a function with multiple array parameters, you can use ‘restrict’
to tell the compiler that each array parameter passed in will be
distinct:

     void
     foo (int array1[restrict 10], int array2[restrict 10])
     ...

Using ‘restrict’ promises the compiler that callers will not pass in the
same array for more than one ‘restrict’ array parameter.  Knowing this
enables the compiler to perform better code optimization.  This is the
same effect as using ‘restrict’ pointers (*note restrict Pointers::),
but makes it clear when reading the code that an array of a specific
size is expected.


File: c,  Node: Structs as Parameters,  Prev: Arrays as Parameters,  Up: Function Definitions

22.1.5 Functions That Accept Structure Arguments
------------------------------------------------

Structures in GNU C are first-class objects, so using them as function
parameters and arguments works in the natural way.  This function
‘swapfoo’ takes a ‘struct foo’ with two fields as argument, and returns
a structure of the same type but with the fields exchanged.

     struct foo { int a, b; };

     struct foo x;

     struct foo
     swapfoo (struct foo inval)
     {
       struct foo outval;
       outval.a = inval.b;
       outval.b = inval.a;
       return outval;
     }

   This simpler definition of ‘swapfoo’ avoids using a local variable to
hold the result about to be return, by using a structure constructor
(*note Structure Constructors::), like this:

     struct foo
     swapfoo (struct foo inval)
     {
       return (struct foo) { inval.b, inval.a };
     }

   It is valid to define a structure type in a function’s parameter
list, as in

     int
     frob_bar (struct bar { int a, b; } inval)
     {
       BODY
     }

and BODY can access the fields of INVAL since the structure type ‘struct
bar’ is defined for the whole function body.  However, there is no way
to create a ‘struct bar’ argument to pass to ‘frob_bar’, except with
kludges.  As a result, defining a structure type in a parameter list is
useless in practice.


File: c,  Node: Function Declarations,  Next: Function Calls,  Prev: Function Definitions,  Up: Functions

22.2 Function Declarations
==========================

To call a function, or use its name as a pointer, a “function
declaration” for the function name must be in effect at that point in
the code.  The function’s definition serves as a declaration of that
function for the rest of the containing scope, but to use the function
in code before the definition, or from another compilation module, a
separate function declaration must precede the use.

   A function declaration looks like the start of a function definition.
It begins with the return value type (‘void’ if none) and the function
name, followed by argument declarations in parentheses (though these can
sometimes be omitted).  But that’s as far as the similarity goes:
instead of the function body, the declaration uses a semicolon.

   A declaration that specifies argument types is called a “function
prototype”.  You can include the argument names or omit them.  The
names, if included in the declaration, have no effect, but they may
serve as documentation.

   This form of prototype specifies fixed argument types:

     RETTYPE FUNCTION (ARGTYPES...);

This form says the function takes no arguments:

     RETTYPE FUNCTION (void);

This form declares types for some arguments, and allows additional
arguments whose types are not specified:

     RETTYPE FUNCTION (ARGTYPES..., ...);

   For a parameter that’s an array of variable length, you can write its
declaration with ‘*’ where the “length” of the array would normally go;
for example, these are all equivalent.

     double maximum (int n, int m, double a[n][m]);
     double maximum (int n, int m, double a[*][*]);
     double maximum (int n, int m, double a[ ][*]);
     double maximum (int n, int m, double a[ ][m]);

The old-fashioned form of declaration, which is not a prototype, says
nothing about the types of arguments or how many they should be:

     RETTYPE FUNCTION ();

   *Warning:* Arguments passed to a function declared without a
prototype are converted with the default argument promotions (*note
Argument Promotions::.  Likewise for additional arguments whose types
are unspecified.

   Function declarations are usually written at the top level in a
source file, but you can also put them inside code blocks.  Then the
function name is visible for the rest of the containing scope.  For
example:

     void
     foo (char *file_name)
     {
       void save_file (char *);
       save_file (file_name);
     }

   If another part of the code tries to call the function ‘save_file’,
this declaration won’t be in effect there.  So the function will get an
implicit declaration of the form ‘extern int save_file ();’.  That
conflicts with the explicit declaration here, and the discrepancy
generates a warning.

   The syntax of C traditionally allows omitting the data type in a
function declaration if it specifies a storage class or a qualifier.
Then the type defaults to ‘int’.  For example:

     static foo (double x);

defaults the return type to ‘int’.  This is bad practice; if you see it,
fix it.

   Calling a function that is undeclared has the effect of an creating
“implicit” declaration in the innermost containing scope, equivalent to
this:

     extern int “function” ();

This declaration says that the function returns ‘int’ but leaves its
argument types unspecified.  If that does not accurately fit the
function, then the program *needs* an explicit declaration of the
function with argument types in order to call it correctly.

   Implicit declarations are deprecated, and a function call that
creates one causes a warning.


File: c,  Node: Function Calls,  Next: Function Call Semantics,  Prev: Function Declarations,  Up: Functions

22.3 Function Calls
===================

Starting a program automatically calls the function named ‘main’ (*note
The main Function::).  Aside from that, a function does nothing except
when it is “called”.  That occurs during the execution of a
function-call expression specifying that function.

   A function-call expression looks like this:

     FUNCTION (ARGUMENTS...)

   Most of the time, FUNCTION is a function name.  However, it can also
be an expression with a function pointer value; that way, the program
can determine at run time which function to call.

   The ARGUMENTS are a series of expressions separated by commas.  Each
expression specifies one argument to pass to the function.

   The list of arguments in a function call looks just like use of the
comma operator (*note Comma Operator::), but the fact that it fills the
parentheses of a function call gives it a different meaning.

   Here’s an example of a function call, taken from an example near the
beginning (*note Complete Program::).

     printf ("Fibonacci series item %d is %d\n",
             19, fib (19));

   The three arguments given to ‘printf’ are a constant string, the
integer 19, and the integer returned by ‘fib (19)’.


File: c,  Node: Function Call Semantics,  Next: Function Pointers,  Prev: Function Calls,  Up: Functions

22.4 Function Call Semantics
============================

The meaning of a function call is to compute the specified argument
expressions, convert their values according to the function’s
declaration, then run the function giving it copies of the converted
values.  (This method of argument passing is known as “call-by-value”.)
When the function finishes, the value it returns becomes the value of
the function-call expression.

   Call-by-value implies that an assignment to the function argument
variable has no direct effect on the caller.  For instance,

     #include <stdlib.h>  /* Defines ‘EXIT_SUCCESS’. */
     #include <stdio.h>   /* Declares ‘printf’. */

     void
     subroutine (int x)
     {
       x = 5;
     }

     void
     main (void)
     {
       int y = 20;
       subroutine (y);
       printf ("y is %d\n", y);
       return EXIT_SUCCESS;
     }

prints ‘y is 20’.  Calling ‘subroutine’ initializes ‘x’ from the value
of ‘y’, but this does not establish any other relationship between the
two variables.  Thus, the assignment to ‘x’, inside ‘subroutine’,
changes only _that_ ‘x’.

   If an argument’s type is specified by the function’s declaration, the
function call converts the argument expression to that type if possible.
If the conversion is impossible, that is an error.

   If the function’s declaration doesn’t specify the type of that
argument, then the _default argument promotions_ apply.  *Note Argument
Promotions::.


File: c,  Node: Function Pointers,  Next: The main Function,  Prev: Function Call Semantics,  Up: Functions

22.5 Function Pointers
======================

A function name refers to a fixed function.  Sometimes it is useful to
call a function to be determined at run time; to do this, you can use a
“function pointer value” that points to the chosen function (*note
Pointers::).

   Pointer-to-function types can be used to declare variables and other
data, including array elements, structure fields, and union
alternatives.  They can also be used for function arguments and return
values.  These types have the peculiarity that they are never converted
automatically to ‘void *’ or vice versa.  However, you can do that
conversion with a cast.

* Menu:

* Declaring Function Pointers:: How to declare a pointer to a function.
* Assigning Function Pointers:: How to assign values to function pointers.
* Calling Function Pointers::   How to call functions through pointers.


File: c,  Node: Declaring Function Pointers,  Next: Assigning Function Pointers,  Up: Function Pointers

22.5.1 Declaring Function Pointers
----------------------------------

The declaration of a function pointer variable (or structure field)
looks almost like a function declaration, except it has an additional
‘*’ just before the variable name.  Proper nesting requires a pair of
parentheses around the two of them.  For instance, ‘int (*a) ();’ says,
“Declare ‘a’ as a pointer such that ‘*a’ is an ‘int’-returning
function.”

   Contrast these three declarations:

     /* Declare a function returning ‘char *’.  */
     char *a (char *);
     /* Declare a pointer to a function returning ‘char’.  */
     char (*a) (char *);
     /* Declare a pointer to a function returning ‘char *’.  */
     char *(*a) (char *);

   The possible argument types of the function pointed to are the same
as in a function declaration.  You can write a prototype that specifies
all the argument types:

     RETTYPE (*FUNCTION) (ARGUMENTS...);

or one that specifies some and leaves the rest unspecified:

     RETTYPE (*FUNCTION) (ARGUMENTS..., ...);

or one that says there are no arguments:

     RETTYPE (*FUNCTION) (void);

   You can also write a non-prototype declaration that says nothing
about the argument types:

     RETTYPE (*FUNCTION) ();

   For example, here’s a declaration for a variable that should point to
some arithmetic function that operates on two ‘double’s:

     double (*binary_op) (double, double);

   Structure fields, union alternatives, and array elements can be
function pointers; so can parameter variables.  The function pointer
declaration construct can also be combined with other operators allowed
in declarations.  For instance,

     int **(*foo)();

declares ‘foo’ as a pointer to a function that returns type ‘int **’,
and

     int **(*foo[30])();

declares ‘foo’ as an array of 30 pointers to functions that return type
‘int **’.

     int **(**foo)();

declares ‘foo’ as a pointer to a pointer to a function that returns type
‘int **’.


File: c,  Node: Assigning Function Pointers,  Next: Calling Function Pointers,  Prev: Declaring Function Pointers,  Up: Function Pointers

22.5.2 Assigning Function Pointers
----------------------------------

Assuming we have declared the variable ‘binary_op’ as in the previous
section, giving it a value requires a suitable function to use.  So
let’s define a function suitable for the variable to point to.  Here’s
one:

     double
     double_add (double a, double b)
     {
       return a+b;
     }

   Now we can give it a value:

     binary_op = double_add;

   The target type of the function pointer must be upward compatible
with the type of the function (*note Compatible Types::).

   There is no need for ‘&’ in front of ‘double_add’.  Using a function
name such as ‘double_add’ as an expression automatically converts it to
the function’s address, with the appropriate function pointer type.
However, it is ok to use ‘&’ if you feel that is clearer:

     binary_op = &double_add;


File: c,  Node: Calling Function Pointers,  Prev: Assigning Function Pointers,  Up: Function Pointers

22.5.3 Calling Function Pointers
--------------------------------

To call the function specified by a function pointer, just write the
function pointer value in a function call.  For instance, here’s a call
to the function ‘binary_op’ points to:

     binary_op (x, 5)

   Since the data type of ‘binary_op’ explicitly specifies type ‘double’
for the arguments, the call converts ‘x’ and 5 to ‘double’.

   The call conceptually dereferences the pointer ‘binary_op’ to “get”
the function it points to, and calls that function.  If you wish, you
can explicitly represent the derefence by writing the ‘*’ operator:

     (*binary_op) (x, 5)

   The ‘*’ reminds people reading the code that ‘binary_op’ is a
function pointer rather than the name of a specific function.


File: c,  Node: The main Function,  Next: Advanced Definitions,  Prev: Function Pointers,  Up: Functions

22.6 The ‘main’ Function
========================

Every complete executable program requires at least one function, called
‘main’, which is where execution begins.  You do not have to explicitly
declare ‘main’, though GNU C permits you to do so.  Conventionally,
‘main’ should be defined to follow one of these calling conventions:

     int main (void) {...}
     int main (int argc, char *argv[]) {...}
     int main (int argc, char *argv[], char *envp[]) {...}

Using ‘void’ as the parameter list means that ‘main’ does not use the
arguments.  You can write ‘char **argv’ instead of ‘char *argv[]’, and
likewise for ‘envp’, as the two constructs are equivalent.

   You can call ‘main’ from C code, as you can call any other function,
though that is an unusual thing to do.  When you do that, you must write
the call to pass arguments that match the parameters in the definition
of ‘main’.

   The ‘main’ function is not actually the first code that runs when a
program starts.  In fact, the first code that runs is system code from
the file ‘crt0.o’.  In Unix, this was hand-written assembler code, but
in GNU we replaced it with C code.  Its job is to find the arguments for
‘main’ and call that.

* Menu:

* Values from main::         Returning values from the main function.
* Command-line Parameters::  Accessing command-line parameters
                               provided to the program.
* Environment Variables::    Accessing system environment variables.


File: c,  Node: Values from main,  Next: Command-line Parameters,  Up: The main Function

22.6.1 Returning Values from ‘main’
-----------------------------------

When ‘main’ returns, the process terminates.  Whatever value ‘main’
returns becomes the exit status which is reported to the parent process.
While nominally the return value is of type ‘int’, in fact the exit
status gets truncated to eight bits; if ‘main’ returns the value 256,
the exit status is 0.

   Normally, programs return only one of two values: 0 for success, and
1 for failure.  For maximum portability, use the macro values
‘EXIT_SUCCESS’ and ‘EXIT_FAILURE’ defined in ‘stdlib.h’.  Here’s an
example:

     #include <stdlib.h>  /* Defines ‘EXIT_SUCCESS’ */
                          /* and ‘EXIT_FAILURE’. */

     int
     main (void)
     {
       ...
       if (foo)
         return EXIT_SUCCESS;
       else
         return EXIT_FAILURE;
     }

   Some types of programs maintain special conventions for various
return values; for example, comparison programs including ‘cmp’ and
‘diff’ return 1 to indicate a mismatch, and 2 to indicate that the
comparison couldn’t be performed.


File: c,  Node: Command-line Parameters,  Next: Environment Variables,  Prev: Values from main,  Up: The main Function

22.6.2 Accessing Command-line Parameters
----------------------------------------

If the program was invoked with any command-line arguments, it can
access them through the arguments of ‘main’, ‘argc’ and ‘argv’.  (You
can give these arguments any names, but the names ‘argc’ and ‘argv’ are
customary.)

   The value of ‘argv’ is an array containing all of the command-line
arguments as strings, with the name of the command invoked as the first
string.  ‘argc’ is an integer that says how many strings ‘argv’
contains.  Here is an example of accessing the command-line parameters,
retrieving the program’s name and checking for the standard ‘--version’
and ‘--help’ options:

     #include <string.h> /* Declare ‘strcmp’. */

     int
     main (int argc, char *argv[])
     {
       char *program_name = argv[0];

       for (int i = 1; i < argc; i++)
         {
           if (!strcmp (argv[i], "--version"))
             {
               /* Print version information and exit. */
               ...
             }
           else if (!strcmp (argv[i], "--help"))
             {
               /* Print help information and exit. */
               ...
             }
         }
       ...
     }


File: c,  Node: Environment Variables,  Prev: Command-line Parameters,  Up: The main Function

22.6.3 Accessing Environment Variables
--------------------------------------

You can optionally include a third parameter to ‘main’, another array of
strings, to capture the environment variables available to the program.
Unlike what happens with ‘argv’, there is no additional parameter for
the count of environment variables; rather, the array of environment
variables concludes with a null pointer.

     #include <stdio.h>   /* Declares ‘printf’. */

     int
     main (int argc, char *argv[], char *envp[])
     {
       /* Print out all environment variables. */
       int i = 0;
       while (envp[i])
         {
           printf ("%s\n", envp[i]);
           i++;
         }
     }

   Another method of retrieving environment variables is to use the
library function ‘getenv’, which is defined in ‘stdlib.h’.  Using
‘getenv’ does not require defining ‘main’ to accept the ‘envp’ pointer.
For example, here is a program that fetches and prints the user’s home
directory (if defined):

     #include <stdlib.h>  /* Declares ‘getenv’. */
     #include <stdio.h>   /* Declares ‘printf’. */

     int
     main (void)
     {
       char *home_directory = getenv ("HOME");
       if (home_directory)
         printf ("My home directory is: %s\n", home_directory);
       else
         printf ("My home directory is not defined!\n");
     }


File: c,  Node: Advanced Definitions,  Next: Obsolete Definitions,  Prev: The main Function,  Up: Functions

22.7 Advanced Function Features
===============================

This section describes some advanced or obscure features for GNU C
function definitions.  If you are just learning C, you can skip the rest
of this chapter.

* Menu:

* Variable-Length Array Parameters:: Functions that accept arrays
                                       of variable length.
* Variable Number of Arguments::     Variadic functions.
* Nested Functions::                 Defining functions within functions.
* Inline Function Definitions::      A function call optimization technique.


File: c,  Node: Variable-Length Array Parameters,  Next: Variable Number of Arguments,  Up: Advanced Definitions

22.7.1 Variable-Length Array Parameters
---------------------------------------

An array parameter can have variable length: simply declare the array
type with a size that isn’t constant.  In a nested function, the length
can refer to a variable defined in a containing scope.  In any function,
it can refer to a previous parameter, like this:

     struct entry
     tester (int len, char data[len][len])
     {
       ...
     }

   Alternatively, in function declarations (but not in function
definitions), you can use ‘[*]’ to denote that the array parameter is of
a variable length, such that these two declarations mean the same thing:

     struct entry
     tester (int len, char data[len][len]);

     struct entry
     tester (int len, char data[*][*]);

The two forms of input are equivalent in GNU C, but emphasizing that the
array parameter is variable-length may be helpful to those studying the
code.

   You can also omit the length parameter, and instead use some other
in-scope variable for the length in the function definition:

     struct entry
     tester (char data[*][*]);
     ...
     int dataLength = 20;
     ...
     struct entry
     tester (char data[dataLength][dataLength])
     {
       ...
     }

   In GNU C, to pass the array first and the length afterward, you can
use a “parameter forward declaration”, like this:

     struct entry
     tester (int len; char data[len][len], int len)
     {
       ...
     }

   The ‘int len’ before the semicolon is the parameter forward
declaration; it serves the purpose of making the name ‘len’ known when
the declaration of ‘data’ is parsed.

   You can write any number of such parameter forward declarations in
the parameter list.  They can be separated by commas or semicolons, but
the last one must end with a semicolon, which is followed by the “real”
parameter declarations.  Each forward declaration must match a
subsequent “real” declaration in parameter name and data type.

   Standard C does not support parameter forward declarations.


File: c,  Node: Variable Number of Arguments,  Next: Nested Functions,  Prev: Variable-Length Array Parameters,  Up: Advanced Definitions

22.7.2 Variable-Length Parameter Lists
--------------------------------------

A function that takes a variable number of arguments is called a
“variadic function”.  In C, a variadic function must specify at least
one fixed argument with an explicitly declared data type.  Additional
arguments can follow, and can vary in both quantity and data type.

   In the function header, declare the fixed parameters in the normal
way, then write a comma and an ellipsis: ‘, ...’.  Here is an example of
a variadic function header:

     int add_multiple_values (int number, ...)

   The function body can refer to fixed arguments by their parameter
names, but the additional arguments have no names.  Accessing them in
the function body uses certain standard macros.  They are defined in the
library header file ‘stdarg.h’, so the code must ‘#include’ that file.

   In the body, write

     va_list ap;
     va_start (ap, LAST_FIXED_PARAMETER);

This declares the variable ‘ap’ (you can use any name for it) and then
sets it up to point before the first additional argument.

   Then, to fetch the next consecutive additional argument, write this:

     va_arg (ap, TYPE)

   After fetching all the additional arguments (or as many as need to be
used), write this:

     va_end (ap);

   Here’s an example of a variadic function definition that adds any
number of ‘int’ arguments.  The first (fixed) argument says how many
more arguments follow.

     #include <stdarg.h> /* Defines ‘va’... macros. */
     ...

     int
     add_multiple_values (int argcount, ...)
     {
       int counter, total = 0;

       /* Declare a variable of type ‘va_list’. */
       va_list argptr;

       /* Initialize that variable.. */
       va_start (argptr, argcount);

       for (counter = 0; counter < argcount; counter++)
         {
           /* Get the next additional argument. */
           total += va_arg (argptr, int);
         }

       /* End use of the ‘argptr’ variable. */
       va_end (argptr);

       return total;
     }

   With GNU C, ‘va_end’ is superfluous, but some other compilers might
make ‘va_start’ allocate memory so that calling ‘va_end’ is necessary to
avoid a memory leak.  Before doing ‘va_start’ again with the same
variable, do ‘va_end’ first.

   Because of this possible memory allocation, it is risky (in
principle) to copy one ‘va_list’ variable to another with assignment.
Instead, use ‘va_copy’, which copies the substance but allocates
separate memory in the variable you copy to.  The call looks like
‘va_copy (TO, FROM)’, where both TO and FROM should be variables of type
‘va_list’.  In principle, do ‘va_end’ on each of these variables before
its scope ends.

   Since the additional arguments’ types are not specified in the
function’s definition, the default argument promotions (*note Argument
Promotions::) apply to them in function calls.  The function definition
must take account of this; thus, if an argument was passed as ‘short’,
the function should get it as ‘int’.  If an argument was passed as
‘float’, the function should get it as ‘double’.

   C has no mechanism to tell the variadic function how many arguments
were passed to it, so its calling convention must give it a way to
determine this.  That’s why ‘add_multiple_values’ takes a fixed argument
that says how many more arguments follow.  Thus, you can call the
function like this:

     sum = add_multiple_values (3, 12, 34, 190);
     /* Value is 12+34+190. */

   In GNU C, there is no actual need to use the ‘va_end’ function.  In
fact, it does nothing.  It’s used for compatibility with other
compilers, when that matters.

   It is a mistake to access variables declared as ‘va_list’ except in
the specific ways described here.  Just what that type consists of is an
implementation detail, which could vary from one platform to another.


File: c,  Node: Nested Functions,  Next: Inline Function Definitions,  Prev: Variable Number of Arguments,  Up: Advanced Definitions

22.7.3 Nested Functions
-----------------------

A “nested function” is a function defined inside another function.  The
nested function’s name is local to the block where it is defined.  For
example, here we define a nested function named ‘square’, and call it
twice:

     foo (double a, double b)
     {
       double square (double z) { return z * z; }

       return square (a) + square (b);
     }

   The nested function can access all the variables of the containing
function that are visible at the point of its definition.  This is
called “lexical scoping”.  For example, here we show a nested function
that uses an inherited variable named ‘offset’:

     bar (int *array, int offset, int size)
     {
       int access (int *array, int index)
         { return array[index + offset]; }
       int i;
       ...
       for (i = 0; i < size; i++)
         ... access (array, i) ...
     }

   Nested function definitions can appear wherever automatic variable
declarations are allowed; that is, in any block, interspersed with the
other declarations and statements in the block.

   The nested function’s name is visible only within the parent block;
the name’s scope starts from its definition and continues to the end of
the containing block.  If the nested function’s name is the same as the
parent function’s name, there wil be no way to refer to the parent
function inside the scope of the name of the nested function.

   Using ‘extern’ or ‘static’ on a nested function definition is an
error.

   It is possible to call the nested function from outside the scope of
its name by storing its address or passing the address to another
function.  You can do this safely, but you must be careful:

     hack (int *array, int size, int addition)
     {
       void store (int index, int value)
         { array[index] = value + addition; }

       intermediate (store, size);
     }

   Here, the function ‘intermediate’ receives the address of ‘store’ as
an argument.  If ‘intermediate’ calls ‘store’, the arguments given to
‘store’ are used to store into ‘array’.  ‘store’ also accesses ‘hack’’s
local variable ‘addition’.

   It is safe for ‘intermediate’ to call ‘store’ because ‘hack’’s stack
frame, with its arguments and local variables, continues to exist during
the call to ‘intermediate’.

   Calling the nested function through its address after the containing
function has exited is asking for trouble.  If it is called after a
containing scope level has exited, and if it refers to some of the
variables that are no longer in scope, it will refer to memory
containing junk or other data.  It’s not wise to take the risk.

   The GNU C Compiler implements taking the address of a nested function
using a technique called “trampolines”.  This technique was described in
‘Lexical Closures for C++’ (Thomas M. Breuel, USENIX C++ Conference
Proceedings, October 17–21, 1988).

   A nested function can jump to a label inherited from a containing
function, provided the label was explicitly declared in the containing
function (*note Local Labels::).  Such a jump returns instantly to the
containing function, exiting the nested function that did the ‘goto’ and
any intermediate function invocations as well.  Here is an example:

     bar (int *array, int offset, int size)
     {
       /* Explicitly declare the label ‘failure’. */
       __label__ failure;
       int access (int *array, int index)
         {
           if (index > size)
             /* Exit this function,
                and return to ‘bar’. */
             goto failure;
           return array[index + offset];
         }

       int i;
       ...
       for (i = 0; i < size; i++)
         ... access (array, i) ...
       ...
       return 0;

      /* Control comes here from ‘access’
         if it does the ‘goto’.  */
      failure:
       return -1;
     }

   To declare the nested function before its definition, use ‘auto’
(which is otherwise meaningless for function declarations; *note auto
and register::).  For example,

     bar (int *array, int offset, int size)
     {
       auto int access (int *, int);
       ...
       ... access (array, i) ...
       ...
       int access (int *array, int index)
         {
           ...
         }
       ...
     }


File: c,  Node: Inline Function Definitions,  Prev: Nested Functions,  Up: Advanced Definitions

22.7.4 Inline Function Definitions
----------------------------------

To declare a function inline, use the ‘inline’ keyword in its
definition.  Here’s a simple function that takes a pointer-to-‘int’ and
increments the integer stored there—declared inline.

     struct list
     {
       struct list *first, *second;
     };

     inline struct list *
     list_first (struct list *p)
     {
       return p->first;
     }

     inline struct list *
     list_second (struct list *p)
     {
       return p->second;
     }

   optimized compilation can substitute the inline function’s body for
any call to it.  This is called _inlining_ the function.  It makes the
code that contains the call run faster, significantly so if the inline
function is small.

   Here’s a function that uses ‘pair_second’:

     int
     pairlist_length (struct list *l)
     {
       int length = 0;
       while (l)
         {
           length++;
           l = pair_second (l);
         }
       return length;
     }

   Substituting the code of ‘pair_second’ into the definition of
‘pairlist_length’ results in this code, in effect:

     int
     pairlist_length (struct list *l)
     {
       int length = 0;
       while (l)
         {
           length++;
           l = l->second;
         }
       return length;
     }

   Since the definition of ‘pair_second’ does not say ‘extern’ or
‘static’, that definition is used only for inlining.  It doesn’t
generate code that can be called at run time.  If not all the calls to
the function are inlined, there must be a definition of the same
function name in another module for them to call.

   Adding ‘static’ to an inline function definition means the function
definition is limited to this compilation module.  Also, it generates
run-time code if necessary for the sake of any calls that were not
inlined.  If all calls are inlined then the function definition does not
generate run-time code, but you can force generation of run-time code
with the option ‘-fkeep-inline-functions’.

   Specifying ‘extern’ along with ‘inline’ means the function is
external and generates run-time code to be called from other separately
compiled modules, as well as inlined.  You can define the function as
‘inline’ without ‘extern’ in other modules so as to inline calls to the
same function in those modules.

   Why are some calls not inlined?  First of all, inlining is an
optimization, so non-optimized compilation does not inline.

   Some calls cannot be inlined for technical reasons.  Also, certain
usages in a function definition can make it unsuitable for inline
substitution.  Among these usages are: variadic functions, use of
‘alloca’, use of computed goto (*note Labels as Values::), and use of
nonlocal goto.  The option ‘-Winline’ requests a warning when a function
marked ‘inline’ is unsuitable to be inlined.  The warning explains what
obstacle makes it unsuitable.

   Just because a call _can_ be inlined does not mean it _should_ be
inlined.  The GNU C compiler weighs costs and benefits to decide whether
inlining a particular call is advantageous.

   You can force inlining of all calls to a given function that can be
inlined, even in a non-optimized compilation.  by specifying the
‘always_inline’ attribute for the function, like this:

     /* Prototype.  */
     inline void foo (const char) __attribute__((always_inline));

This is a GNU C extension.  *Note Attributes::.

   A function call may be inlined even if not declared ‘inline’ in
special cases where the compiler can determine this is correct and
desirable.  For instance, when a static function is called only once, it
will very likely be inlined.  With ‘-flto’, link-time optimization, any
function might be inlined.  To absolutely prevent inlining of a specific
function, specify ‘__attribute__((__noinline__))’ in the function’s
definition.


File: c,  Node: Obsolete Definitions,  Prev: Advanced Definitions,  Up: Functions

22.8 Obsolete Function Features
===============================

These features of function definitions are still used in old programs,
but you shouldn’t write code this way today.  If you are just learning
C, you can skip this section.

* Menu:

* Old GNU Inlining::                 An older inlining technique.
* Old-Style Function Definitions::   Original K&R style functions.


File: c,  Node: Old GNU Inlining,  Next: Old-Style Function Definitions,  Up: Obsolete Definitions

22.8.1 Older GNU C Inlining
---------------------------

The GNU C spec for inline functions, before GCC version 5, defined
‘extern inline’ on a function definition to mean to inline calls to it
but _not_ generate code for the function that could be called at run
time.  By contrast, ‘inline’ without ‘extern’ specified to generate
run-time code for the function.  In effect, ISO incompatibly flipped the
meanings of these two cases.  We changed GCC in version 5 to adopt the
ISO specification.

   Many programs still use these cases with the previous GNU C meanings.
You can specify use of those meanings with the option ‘-fgnu89-inline’.
You can also specify this for a single function with ‘__attribute__
((gnu_inline))’.  Here’s an example:

     inline __attribute__ ((gnu_inline))
     int
     inc (int *a)
     {
       (*a)++;
     }


File: c,  Node: Old-Style Function Definitions,  Prev: Old GNU Inlining,  Up: Obsolete Definitions

22.8.2 Old-Style Function Definitions
-------------------------------------

The syntax of C traditionally allows omitting the data type in a
function declaration if it specifies a storage class or a qualifier.
Then the type defaults to ‘int’.  For example:

     static foo (double x);

defaults the return type to ‘int’.  This is bad practice; if you see it,
fix it.

   An “old-style” (or “K&R”) function definition is the way function
definitions were written in the 1980s.  It looks like this:

     RETTYPE
     FUNCTION (PARMNAMES)
       PARM_DECLARATIONS
     {
       BODY
     }

   In PARMNAMES, only the parameter names are listed, separated by
commas.  Then PARM_DECLARATIONS declares their data types; these
declarations look just like variable declarations.  If a parameter is
listed in PARMNAMES but has no declaration, it is implicitly declared
‘int’.

   There is no reason to write a definition this way nowadays, but they
can still be seen in older GNU programs.

   An old-style variadic function definition looks like this:

     #include <varargs.h>

     int
     add_multiple_values (va_alist)
         va_dcl
     {
       int argcount;
       int counter, total = 0;

       /* Declare a variable of type ‘va_list’. */
       va_list argptr;

       /* Initialize that variable. */
       va_start (argptr);

       /* Get the first argument (fixed). */
       argcount = va_arg (int);

       for (counter = 0; counter < argcount; counter++)
         {
           /* Get the next additional argument. */
           total += va_arg (argptr, int);
         }

       /* End use of the ‘argptr’ variable. */
       va_end (argptr);

       return total;
     }

   Note that the old-style variadic function definition has no fixed
parameter variables; all arguments must be obtained with ‘va_arg’.


File: c,  Node: Compatible Types,  Next: Type Conversions,  Prev: Functions,  Up: Top

23 Compatible Types
*******************

Declaring a function or variable twice is valid in C only if the two
declarations specify “compatible” types.  In addition, some operations
on pointers require operands to have compatible target types.

   In C, two different primitive types are never compatible.  Likewise
for the defined types ‘struct’, ‘union’ and ‘enum’: two separately
defined types are incompatible unless they are defined exactly the same
way.

   However, there are a few cases where different types can be
compatible:

   • Every enumeration type is compatible with some integer type.  In
     GNU C, the choice of integer type depends on the largest
     enumeration value.

   • Array types are compatible if the element types are compatible and
     the sizes (when specified) match.

   • Pointer types are compatible if the pointer target types are
     compatible.

   • Function types that specify argument types are compatible if the
     return types are compatible and the argument types are compatible,
     argument by argument.  In addition, they must all agree in whether
     they use ‘...’ to allow additional arguments.

   • Function types that don’t specify argument types are compatible if
     the return types are.

   • Function types that specify the argument types are compatible with
     function types that omit them, if the return types are compatible
     and the specified argument types are unaltered by the argument
     promotions (*note Argument Promotions::).

   In order for types to be compatible, they must agree in their type
qualifiers.  Thus, ‘const int’ and ‘int’ are incompatible.  It follows
that ‘const int *’ and ‘int *’ are incompatible too (they are pointers
to types that are not compatible).

   If two types are compatible ignoring the qualifiers, we call them
“nearly compatible”.  (If they are array types, we ignore qualifiers on
the element types.(1))  Comparison of pointers is valid if the pointers’
target types are nearly compatible.  Likewise, the two branches of a
conditional expression may be pointers to nearly compatible target
types.

   If two types are compatible ignoring the qualifiers, and the first
type has all the qualifiers of the second type, we say the first is
“upward compatible” with the second.  Assignment of pointers requires
the assigned pointer’s target type to be upward compatible with the
right operand (the new value)’s target type.

   ---------- Footnotes ----------

   (1) This is a GNU C extension.


File: c,  Node: Type Conversions,  Next: Scope,  Prev: Compatible Types,  Up: Top

24 Type Conversions
*******************

C converts between data types automatically when that seems clearly
necessary.  In addition, you can convert explicitly with a “cast”.

* Menu:

* Explicit Type Conversion::     Casting a value from one type to another.
* Assignment Type Conversions::  Automatic conversion by assignment operation.
* Argument Promotions::          Automatic conversion of function parameters.
* Operand Promotions::           Automatic conversion of arithmetic operands.
* Common Type::                  When operand types differ, which one is used?


File: c,  Node: Explicit Type Conversion,  Next: Assignment Type Conversions,  Up: Type Conversions

24.1 Explicit Type Conversion
=============================

You can do explicit conversions using the unary “cast” operator, which
is written as a type designator (*note Type Designators::) in
parentheses.  For example, ‘(int)’ is the operator to cast to type
‘int’.  Here’s an example of using it:

     {
       double d = 5.5;

       printf ("Floating point value: %f\n", d);
       printf ("Rounded to integer: %d\n", (int) d);
     }

   Using ‘(int) d’ passes an ‘int’ value as argument to ‘printf’, so you
can print it with ‘%d’.  Using just ‘d’ without the cast would pass the
value as ‘double’.  That won’t work at all with ‘%d’; the results would
be gibberish.

   To divide one integer by another without rounding, cast either of the
integers to ‘double’ first:

     (double) DIVIDEND / DIVISOR
     DIVIDEND / (double) DIVISOR

   It is enough to cast one of them, because that forces the common type
to ‘double’ so the other will be converted automatically.

   The valid cast conversions are:

   • One numerical type to another.

   • One pointer type to another.  (Converting between pointers that
     point to functions and pointers that point to data is not standard
     C.)

   • A pointer type to an integer type.

   • An integer type to a pointer type.

   • To a union type, from the type of any alternative in the union
     (*note Unions::).  (This is a GNU extension.)

   • Anything, to ‘void’.


File: c,  Node: Assignment Type Conversions,  Next: Argument Promotions,  Prev: Explicit Type Conversion,  Up: Type Conversions

24.2 Assignment Type Conversions
================================

Certain type conversions occur automatically in assignments and certain
other contexts.  These are the conversions assignments can do:

   • Converting any numeric type to any other numeric type.

   • Converting ‘void *’ to any other pointer type (except
     pointer-to-function types).

   • Converting any other pointer type to ‘void *’.  (except
     pointer-to-function types).

   • Converting 0 (a null pointer constant) to any pointer type.

   • Converting any pointer type to ‘bool’.  (The result is 1 if the
     pointer is not null.)

   • Converting between pointer types when the left-hand target type is
     upward compatible with the right-hand target type.  *Note
     Compatible Types::.

   These type conversions occur automatically in certain contexts, which
are:

   • An assignment converts the type of the right-hand expression to the
     type wanted by the left-hand expression.  For example,

          double i;
          i = 5;

     converts 5 to ‘double’.

   • A function call, when the function specifies the type for that
     argument, converts the argument value to that type.  For example,

          void foo (double);
          foo (5);

     converts 5 to ‘double’.

   • A ‘return’ statement converts the specified value to the type that
     the function is declared to return.  For example,

          double
          foo ()
          {
            return 5;
          }

     also converts 5 to ‘double’.

   In all three contexts, if the conversion is impossible, that
constitutes an error.


File: c,  Node: Argument Promotions,  Next: Operand Promotions,  Prev: Assignment Type Conversions,  Up: Type Conversions

24.3 Argument Promotions
========================

When a function’s definition or declaration does not specify the type of
an argument, that argument is passed without conversion in whatever type
it has, with these exceptions:

   • Some narrow numeric values are “promoted” to a wider type.  If the
     expression is a narrow integer, such as ‘char’ or ‘short’, the call
     converts it automatically to ‘int’ (*note Integer Types::).(1)

     In this example, the expression ‘c’ is passed as an ‘int’:

          char c = '$';

          printf ("Character c is '%c'\n", c);

   • If the expression has type ‘float’, the call converts it
     automatically to ‘double’.

   • An array as argument is converted to a pointer to its zeroth
     element.

   • A function name as argument is converted to a pointer to that
     function.

   ---------- Footnotes ----------

   (1) On an embedded controller where ‘char’ or ‘short’ is the same
width as ‘int’, ‘unsigned char’ or ‘unsigned short’ promotes to
‘unsigned int’, but that never occurs in GNU C on real computers.


File: c,  Node: Operand Promotions,  Next: Common Type,  Prev: Argument Promotions,  Up: Type Conversions

24.4 Operand Promotions
=======================

The operands in arithmetic operations undergo type conversion
automatically.  These “operand promotions” are the same as the argument
promotions except without converting ‘float’ to ‘double’.  In other
words, the operand promotions convert

   • ‘char’ or ‘short’ (whether signed or not) to ‘int’.

   • an array to a pointer to its zeroth element, and

   • a function name to a pointer to that function.


File: c,  Node: Common Type,  Prev: Operand Promotions,  Up: Type Conversions

24.5 Common Type
================

Arithmetic binary operators (except the shift operators) convert their
operands to the “common type” before operating on them.  Conditional
expressions also convert the two possible results to their common type.
Here are the rules for determining the common type.

   If one of the numbers has a floating-point type and the other is an
integer, the common type is that floating-point type.  For instance,

     5.6 * 2   ⇒ 11.2 /* a ‘double’ value */

   If both are floating point, the type with the larger range is the
common type.

   If both are integers but of different widths, the common type is the
wider of the two.

   If they are integer types of the same width, the common type is
unsigned if either operand is unsigned, and it’s ‘long’ if either
operand is ‘long’.  It’s ‘long long’ if either operand is ‘long long’.

   These rules apply to addition, subtraction, multiplication, division,
remainder, comparisons, and bitwise operations.  They also apply to the
two branches of a conditional expression, and to the arithmetic done in
a modifying assignment operation.


File: c,  Node: Scope,  Next: Preprocessing,  Prev: Type Conversions,  Up: Top

25 Scope
********

Each definition or declaration of an identifier is visible in certain
parts of the program, which is typically less than the whole of the
program.  The parts where it is visible are called its “scope”.

   Normally, declarations made at the top-level in the source – that is,
not within any blocks and function definitions – are visible for the
entire contents of the source file after that point.  This is called
“file scope” (*note File-Scope Variables::).

   Declarations made within blocks of code, including within function
definitions, are visible only within those blocks.  This is called
“block scope”.  Here is an example:

     void
     foo (void)
     {
       int x = 42;
     }

In this example, the variable ‘x’ has block scope; it is visible only
within the ‘foo’ function definition block.  Thus, other blocks could
have their own variables, also named ‘x’, without any conflict between
those variables.

   A variable declared inside a subblock has a scope limited to that
subblock,

     void
     foo (void)
     {
       {
         int x = 42;
       }
       // ‘x’ is out of scope here.
     }

   If a variable declared within a block has the same name as a variable
declared outside of that block, the definition within the block takes
precedence during its scope:

     int x = 42;

     void
     foo (void)
     {
       int x = 17;
       printf ("%d\n", x);
     }

This prints 17, the value of the variable ‘x’ declared in the function
body block, rather than the value of the variable ‘x’ at file scope.  We
say that the inner declaration of ‘x’ “shadows” the outer declaration,
for the extent of the inner declaration’s scope.

   A declaration with block scope can be shadowed by another declaration
with the same name in a subblock.

     void
     foo (void)
     {
       char *x = "foo";
       {
         int x = 42;
         ...
         exit (x / 6);
       }
     }

   A function parameter’s scope is the entire function body, but it can
be shadowed.  For example:

     int x = 42;

     void
     foo (int x)
     {
       printf ("%d\n", x);
     }

This prints the value of ‘x’ the function parameter, rather than the
value of the file-scope variable ‘x’.  However,

   Labels (*note goto Statement::) have “function” scope: each label is
visible for the whole of the containing function body, both before and
after the label declaration:

     void
     foo (void)
     {
       ...
       goto bar;
       ...
       {  // Subblock does not affect labels.
         bar:
         ...
       }
       goto bar;
     }

   Except for labels, a declared identifier is not visible to code
before its declaration.  For example:

     int x = 5;
     int y = x + 10;

will work, but:

     int x = y + 10;
     int y = 5;

cannot refer to the variable ‘y’ before its declaration.


File: c,  Node: Preprocessing,  Next: Integers in Depth,  Prev: Scope,  Up: Top

26 Preprocessing
****************

As the first stage of compiling a C source module, GCC transforms the
text with text substitutions and file inclusions.  This is called
“preprocessing”.

* Menu:

* Preproc Overview::
* Directives::
* Preprocessing Tokens::
* Header Files::
* Macros::
* Conditionals::
* Diagnostics::
* Line Control::
* Null Directive::


File: c,  Node: Preproc Overview,  Next: Directives,  Up: Preprocessing

26.1 Preprocessing Overview
===========================

GNU C performs preprocessing on each line of a C program as the first
stage of compilation.  Preprocessing operates on a line only when it
contains a “preprocessing directive” or uses a “macro”—all other lines
pass through preprocessing unchanged.

   Here are some jobs that preprocessing does.  The rest of this chapter
gives the details.

   • Inclusion of header files.  These are files (usually containing
     declarations and macro definitions) that can be substituted into
     your program.

   • Macro expansion.  You can define “macros”, which are abbreviations
     for arbitrary fragments of C code.  Preprocessing replaces the
     macros with their definitions.  Some macros are automatically
     predefined.

   • Conditional compilation.  You can include or exclude parts of the
     program according to various conditions.

   • Line control.  If you use a program to combine or rearrange source
     files into an intermediate file that is then compiled, you can use
     line control to inform the compiler where each source line
     originally came from.

   • Compilation control.  ‘#pragma’ and ‘_Pragma’ invoke some special
     compiler features in how to handle certain constructs.

   • Diagnostics.  You can detect problems at compile time and issue
     errors or warnings.

   Except for expansion of predefined macros, all these operations
happen only if you use preprocessing directives to request them.


File: c,  Node: Directives,  Next: Preprocessing Tokens,  Prev: Preproc Overview,  Up: Preprocessing

26.2 Directives
===============

“Preprocessing directives” are lines in the program that start with ‘#’.
Whitespace is allowed before and after the ‘#’.  The ‘#’ is followed by
an identifier, the “directive name”.  It specifies the operation to
perform.  Here are a couple of examples:

     #define LIMIT 51
       #   undef LIMIT
     # error You screwed up!

   We usually refer to a directive as ‘#NAME’ where NAME is the
directive name.  For example, ‘#define’ means the directive that defines
a macro.

   The ‘#’ that begins a directive cannot come from a macro expansion.
Also, the directive name is not macro expanded.  Thus, if ‘foo’ is
defined as a macro expanding to ‘define’, that does not make ‘#foo’ a
valid preprocessing directive.

   The set of valid directive names is fixed.  Programs cannot define
new preprocessing directives.

   Some directives require arguments; these make up the rest of the
directive line and must be separated from the directive name by
whitespace.  For example, ‘#define’ must be followed by a macro name and
the intended expansion of the macro.

   A preprocessing directive cannot cover more than one line.  The line
can, however, be continued with backslash-newline, or by a
‘/*...*/’-style comment that extends past the end of the line.  These
will be replaced (by nothing, or by whitespace) before the directive is
processed.


File: c,  Node: Preprocessing Tokens,  Next: Header Files,  Prev: Directives,  Up: Preprocessing

26.3 Preprocessing Tokens
=========================

Preprocessing divides C code (minus its comments) into “tokens” that are
similar to C tokens, but not exactly the same.  Here are the quirks of
preprocessing tokens.

   The main classes of preprocessing tokens are identifiers,
preprocessing numbers, string constants, character constants, and
punctuators; there are a few others too.

identifier
     An “identifier” preprocessing token is syntactically like an
     identifier in C: any sequence of letters, digits, or underscores,
     as well as non-ASCII characters represented using ‘\U’ or ‘\u’,
     that doesn’t begin with a digit.

     During preprocessing, the keywords of C have no special
     significance; at that stage, they are simply identifiers.  Thus,
     you can define a macro whose name is a keyword.  The only
     identifier that is special during preprocessing is ‘defined’ (*note
     defined::).

preprocessing number
     A “preprocessing number” is something that preprocessing treats
     textually as a number, including C numeric constants, and other
     sequences of characters which resemble numeric constants.
     Preprocessing does not try to verify that a preprocessing number is
     a valid number in C, and indeed it need not be one.

     More precisely, preprocessing numbers begin with an optional
     period, a required decimal digit, and then continue with any
     sequence of letters, digits, underscores, periods, and exponents.
     Exponents are the two-character sequences ‘e+’, ‘e-’, ‘E+’, ‘E-’,
     ‘p+’, ‘p-’, ‘P+’, and ‘P-’.  (The exponents that begin with ‘p’ or
     ‘P’ are new to C99.  They are used for hexadecimal floating-point
     constants.)

     The reason behind this unusual syntactic class is that the full
     complexity of numeric constants is irrelevant during preprocessing.
     The distinction between lexically valid and invalid floating-point
     numbers, for example, doesn’t matter at this stage.  The use of
     preprocessing numbers makes it possible to split an identifier at
     any position and get exactly two tokens, and reliably paste them
     together using the ‘##’ operator (*note Concatenation::).

punctuator
     A “punctuator” is syntactically like an operator.  These are the
     valid punctuators:

          [  ]   (  )  {  }  .  ->
          ++ --  &  *  +  -  ~  !
          /  %   << >> <  >  <= >=  ==  !=  ^  |  &&  ||
          ?  :   ;  ...
          =  *=  /=  %=  +=  -=  <<=  >>=  &=  ^=  |=
          ,  #   ##
          <: :>  <% %>  %:  %:%:

string constant
     A string constant in the source code is recognized by preprocessing
     as a single preprocessing token.

character constant
     A character constant in the source code is recognized by
     preprocessing as a single preprocessing token.

header name
     Within the ‘#include’ directive, preprocessing recognizes a “header
     name” token.  It consists of ‘"NAME"’, where NAME is a sequence of
     source characters other than newline and ‘"’, or ‘<NAME>’, where
     NAME is a sequence of source characters other than newline and ‘>’.

     In practice, it is more convenient to think that the ‘#include’
     line is exempt from tokenization.

other
     Any other character that’s valid in a C source program is treated
     as a separate preprocessing token.

   Once the program is broken into preprocessing tokens, they remain
separate until the end of preprocessing.  Macros that generate two
consecutive tokens insert whitespace to keep them separate, if
necessary.  For example,

     #define foo() bar
     foo()baz
          ↦ bar baz
     _not_
          ↦ barbaz

   The only exception is with the ‘##’ preprocessing operator, which
pastes tokens together (*note Concatenation::).

   Preprocessing treats the null character (code 0) as whitespace, but
generates a warning for it because it may be invisible to the user (many
terminals do not display it at all) and its presence in the file is
probably a mistake.


File: c,  Node: Header Files,  Next: Macros,  Prev: Preprocessing Tokens,  Up: Preprocessing

26.4 Header Files
=================

A header file is a file of C code, typically containing C declarations
and macro definitions (*note Macros::), to be shared between several
source files.  You request the use of a header file in your program by
“including” it, with the C preprocessing directive ‘#include’.

   Header files serve two purposes.

   • System header files declare the interfaces to parts of the
     operating system.  You include them in your program to supply the
     definitions and declarations that you need to invoke system calls
     and libraries.

   • Program-specific header files contain declarations for interfaces
     between the source files of a particular program.  It is a good
     idea to create a header file for related declarations and macro
     definitions if all or most of them are needed in several different
     source files.

   Including a header file produces the same results as copying the
header file into each source file that needs it.  Such copying would be
time-consuming and error-prone.  With a header file, the related
declarations appear in only one place.  If they need to be changed, you
can change them in one place, and programs that include the header file
will then automatically use the new version when next recompiled.  The
header file eliminates the labor of finding and changing all the copies
as well as the risk that a failure to change one copy will result in
inconsistencies within a program.

   In C, the usual convention is to give header files names that end
with ‘.h’.  It is most portable to use only letters, digits, dashes, and
underscores in header file names, and at most one dot.

* Menu:

* include Syntax::
* include Operation::
* Search Path::
* Once-Only Headers::
* Computed Includes::


File: c,  Node: include Syntax,  Next: include Operation,  Up: Header Files

26.4.1 ‘#include’ Syntax
------------------------

You can specify inclusion of user and system header files with the
preprocessing directive ‘#include’.  It has two variants:

‘#include <FILE>’
     This variant is used for system header files.  It searches for a
     file named FILE in a standard list of system directories.  You can
     prepend directories to this list with the ‘-I’ option (*note
     Invoking GCC: (gcc)Invocation.).

‘#include "FILE"’
     This variant is used for header files of your own program.  It
     searches for a file named FILE first in the directory containing
     the current file, then in the quote directories, then the same
     directories used for ‘<FILE>’.  You can prepend directories to the
     list of quote directories with the ‘-iquote’ option.

   The argument of ‘#include’, whether delimited with quote marks or
angle brackets, behaves like a string constant in that comments are not
recognized, and macro names are not expanded.  Thus, ‘#include <x/*y>’
specifies inclusion of a system header file named ‘x/*y’.

   However, if backslashes occur within FILE, they are considered
ordinary text characters, not escape characters: character escape
sequences such as used in string constants in C are not meaningful here.
Thus, ‘#include "x\n\\y"’ specifies a filename containing three
backslashes.  By the same token, there is no way to escape ‘"’ or ‘>’ to
include it in the header file name if it would instead end the file
name.

   Some systems interpret ‘\’ as a file name component separator.  All
these systems also interpret ‘/’ the same way.  It is most portable to
use only ‘/’.

   It is an error to put anything other than comments on the ‘#include’
line after the file name.


File: c,  Node: include Operation,  Next: Search Path,  Prev: include Syntax,  Up: Header Files

26.4.2 ‘#include’ Operation
---------------------------

The ‘#include’ directive works by scanning the specified header file as
input before continuing with the rest of the current file.  The result
of preprocessing consists of the text already generated, followed by the
result of preprocessing the included file, followed by whatever results
from the text after the ‘#include’ directive.  For example, if you have
a header file ‘header.h’ as follows,

     char *test (void);

and a main program called ‘program.c’ that uses the header file, like
this,

     int x;
     #include "header.h"

     int
     main (void)
     {
       puts (test ());
     }

the result is equivalent to putting this text in ‘program.c’:

     int x;
     char *test (void);

     int
     main (void)
     {
       puts (test ());
     }

   Included files are not limited to declarations and macro definitions;
those are merely the typical uses.  Any fragment of a C program can be
included from another file.  The include file could even contain the
beginning of a statement that is concluded in the containing file, or
the end of a statement that was started in the including file.  However,
an included file must consist of complete tokens.  Comments and string
literals that have not been closed by the end of an included file are
invalid.  For error recovery, the compiler terminates them at the end of
the file.

   To avoid confusion, it is best if header files contain only complete
syntactic units—function declarations or definitions, type declarations,
etc.

   The line following the ‘#include’ directive is always treated as a
separate line, even if the included file lacks a final newline.  There
is no problem putting a preprocessing directive there.


File: c,  Node: Search Path,  Next: Once-Only Headers,  Prev: include Operation,  Up: Header Files

26.4.3 Search Path
------------------

GCC looks in several different places for header files to be included.
On the GNU system, and Unix systems, the default directories for system
header files are:

     LIBDIR/gcc/TARGET/VERSION/include
     /usr/local/include
     LIBDIR/gcc/TARGET/VERSION/include-fixed
     LIBDIR/TARGET/include
     /usr/include/TARGET
     /usr/include

The list may be different in some operating systems.  Other directories
are added for C++.

   In the above, TARGET is the canonical name of the system GCC was
configured to compile code for; often but not always the same as the
canonical name of the system it runs on.  VERSION is the version of GCC
in use.

   You can add to this list with the ‘-IDIR’ command-line option.  All
the directories named by ‘-I’ are searched, in left-to-right order,
_before_ the default directories.  The only exception is when ‘dir’ is
already searched by default.  In this case, the option is ignored and
the search order for system directories remains unchanged.

   Duplicate directories are removed from the quote and bracket search
chains before the two chains are merged to make the final search chain.
Thus, it is possible for a directory to occur twice in the final search
chain if it was specified in both the quote and bracket chains.

   You can prevent GCC from searching any of the default directories
with the ‘-nostdinc’ option.  This is useful when you are compiling an
operating system kernel or some other program that does not use the
standard C library facilities, or the standard C library itself.  ‘-I’
options are not ignored as described above when ‘-nostdinc’ is in
effect.

   GCC looks for headers requested with ‘#include "FILE"’ first in the
directory containing the current file, then in the “quote directories”
specified by ‘-iquote’ options, then in the same places it looks for a
system header.  For example, if ‘/usr/include/sys/stat.h’ contains
‘#include "types.h"’, GCC looks for ‘types.h’ first in
‘/usr/include/sys’, then in the quote directories and then in its usual
search path.

   ‘#line’ (*note Line Control::) does not change GCC’s idea of the
directory containing the current file.

   The ‘-I-’ is an old-fashioned, deprecated way to specify the quote
directories.  To look for headers in a directory named ‘-’, specify
‘-I./-’.  There are several more ways to adjust the header search path.
*Note Invoking GCC: (gcc)invocation.


File: c,  Node: Once-Only Headers,  Next: Computed Includes,  Prev: Search Path,  Up: Header Files

26.4.4 Once-Only Headers
------------------------

If a header file happens to be included twice, the compiler will process
its contents twice.  This is very likely to cause an error, e.g. when
the compiler sees the same structure definition twice.

   The standard way to prevent this is to enclose the entire real
contents of the file in a conditional, like this:

     /* File foo.  */
     #ifndef FILE_FOO_SEEN
     #define FILE_FOO_SEEN

     THE ENTIRE FILE

     #endif /* !FILE_FOO_SEEN */

   This construct is commonly known as a “wrapper #ifndef”.  When the
header is included again, the conditional will be false, because
‘FILE_FOO_SEEN’ is defined.  Preprocessing skips over the entire
contents of the file, so that compilation will never “see” the file
contents twice in one module.

   GCC optimizes this case even further.  It remembers when a header
file has a wrapper ‘#ifndef’.  If a subsequent ‘#include’ specifies that
header, and the macro in the ‘#ifndef’ is still defined, it does not
bother to rescan the file at all.

   You can put comments in the header file outside the wrapper.  They do
not interfere with this optimization.

   The macro ‘FILE_FOO_SEEN’ is called the “controlling macro” or “guard
macro”.  In a user header file, the macro name should not begin with
‘_’.  In a system header file, it should begin with ‘__’ (or ‘_’
followed by an upper-case letter) to avoid conflicts with user programs.
In any kind of header file, the macro name should contain the name of
the file and some additional text, to avoid conflicts with other header
files.


File: c,  Node: Computed Includes,  Prev: Once-Only Headers,  Up: Header Files

26.4.5 Computed Includes
------------------------

Sometimes it is necessary to select one of several different header
files to be included into your program.  They might specify
configuration parameters to be used on different sorts of operating
systems, for instance.  You could do this with a series of conditionals,

     #if SYSTEM_1
     # include "system_1.h"
     #elif SYSTEM_2
     # include "system_2.h"
     #elif SYSTEM_3
     /* ... */
     #endif

   That rapidly becomes tedious.  Instead, GNU C offers the ability to
use a macro for the header name.  This is called a “computed include”.
Instead of writing a header name as the direct argument of ‘#include’,
you simply put a macro name there instead:

     #define SYSTEM_H "system_1.h"
     /* ... */
     #include SYSTEM_H

‘SYSTEM_H’ is expanded, then ‘system_1.h’ is included as if the
‘#include’ had been written with that name.  ‘SYSTEM_H’ could be defined
by your Makefile with a ‘-D’ option.

   You must be careful when you define such a macro.  ‘#define’ saves
tokens, not text.  GCC has no way of knowing that the macro will be used
as the argument of ‘#include’, so it generates ordinary tokens, not a
header name.  This is unlikely to cause problems if you use double-quote
includes, which are syntactically similar to string constants.  If you
use angle brackets, however, you may have trouble.

   The syntax of a computed include is actually a bit more general than
the above.  If the first non-whitespace character after ‘#include’ is
not ‘"’ or ‘<’, then the entire line is macro-expanded like running text
would be.

   If the line expands to a single string constant, the contents of that
string constant are the file to be included.  Preprocessing does not
re-examine the string for embedded quotes, but neither does it process
backslash escapes in the string.  Therefore

     #define HEADER "a\"b"
     #include HEADER

looks for a file named ‘a\"b’.  Preprocessing searches for the file
according to the rules for double-quoted includes.

   If the line expands to a token stream beginning with a ‘<’ token and
including a ‘>’ token, then the tokens between the ‘<’ and the first ‘>’
are combined to form the filename to be included.  Any whitespace
between tokens is reduced to a single space; then any space after the
initial ‘<’ is retained, but a trailing space before the closing ‘>’ is
ignored.  Preprocessing searches for the file according to the rules for
angle-bracket includes.

   In either case, if there are any tokens on the line after the file
name, an error occurs and the directive is not processed.  It is also an
error if the result of expansion does not match either of the two
expected forms.

   These rules are implementation-defined behavior according to the C
standard.  To minimize the risk of different compilers interpreting your
computed includes differently, we recommend you use only a single
object-like macro that expands to a string constant.  That also makes it
clear to people reading your program.


File: c,  Node: Macros,  Next: Conditionals,  Prev: Header Files,  Up: Preprocessing

26.5 Macros
===========

A “macro” is a fragment of code that has been given a name.  Whenever
the name is used, it is replaced by the contents of the macro.  There
are two kinds of macros.  They differ mostly in what they look like when
they are used.  “Object-like” macros resemble data objects when used,
“function-like” macros resemble function calls.

   You may define any valid identifier as a macro, even if it is a C
keyword.  In the preprocessing stage, GCC does not know anything about
keywords.  This can be useful if you wish to hide a keyword such as
‘const’ from an older compiler that does not understand it.  However,
the preprocessing operator ‘defined’ (*note defined::) can never be
defined as a macro, and C‘++’’s named operators (*note C++ Named
Operators: (gcc)C++ Named Operators.) cannot be macros when compiling
C‘++’ code.

   The operator ‘#’ is used in macros for stringification of an argument
(*note Stringification::), and ‘##’ is used for concatenation of
arguments into larger tokens (*note Concatenation::)

* Menu:

* Object-like Macros::
* Function-like Macros::
* Macro Arguments::
* Stringification::
* Concatenation::
* Variadic Macros::
* Predefined Macros::
* Undefining and Redefining Macros::
* Directives Within Macro Arguments::
* Macro Pitfalls::


File: c,  Node: Object-like Macros,  Next: Function-like Macros,  Up: Macros

26.5.1 Object-like Macros
-------------------------

An “object-like macro” is a simple identifier that will be replaced by a
code fragment.  It is called object-like because in most cases the use
of the macro looks like reference to a data object in code that uses it.
These macros are most commonly used to give symbolic names to numeric
constants.

   The way to define macros with the ‘#define’ directive.  ‘#define’ is
followed by the name of the macro and then the token sequence it should
be an abbreviation for, which is variously referred to as the macro’s
“body”, “expansion” or “replacement list”.  For example,

     #define BUFFER_SIZE 1024

defines a macro named ‘BUFFER_SIZE’ as an abbreviation for the token
‘1024’.  If somewhere after this ‘#define’ directive there comes a C
statement of the form

     foo = (char *) malloc (BUFFER_SIZE);

then preprocessing will recognize and “expand” the macro ‘BUFFER_SIZE’,
so that compilation will see the tokens:

     foo = (char *) malloc (1024);

   By convention, macro names are written in upper case.  Programs are
easier to read when it is possible to tell at a glance which names are
macros.  Macro names that start with ‘__’ are reserved for internal
uses, and many of them are defined automatically, so don’t define such
macro names unless you really know what you’re doing.  Likewise for
macro names that start with ‘_’ and an upper-case letter.

   The macro’s body ends at the end of the ‘#define’ line.  You may
continue the definition onto multiple lines, if necessary, using
backslash-newline.  When the macro is expanded, however, it will all
come out on one line.  For example,

     #define NUMBERS 1, \
                     2, \
                     3
     int x[] = { NUMBERS };
          ↦ int x[] = { 1, 2, 3 };

The most common visible consequence of this is surprising line numbers
in error messages.

   There is no restriction on what can go in a macro body provided it
decomposes into valid preprocessing tokens.  Parentheses need not
balance, and the body need not resemble valid C code.  (If it does not,
you may get error messages from the C compiler when you use the macro.)

   Preprocessing scans the program sequentially.  A macro definition
takes effect right after its appearance.  Therefore, the following input

     foo = X;
     #define X 4
     bar = X;

produces

     foo = X;
     bar = 4;

   When preprocessing expands a macro name, the macro’s expansion
replaces the macro invocation, then the expansion is examined for more
macros to expand.  For example,

     #define TABLESIZE BUFSIZE
     #define BUFSIZE 1024
     TABLESIZE
          ↦ BUFSIZE
          ↦ 1024

‘TABLESIZE’ is expanded first to produce ‘BUFSIZE’, then that macro is
expanded to produce the final result, ‘1024’.

   Notice that ‘BUFSIZE’ was not defined when ‘TABLESIZE’ was defined.
The ‘#define’ for ‘TABLESIZE’ uses exactly the expansion you specify—in
this case, ‘BUFSIZE’—and does not check to see whether it too contains
macro names.  Only when you _use_ ‘TABLESIZE’ is the result of its
expansion scanned for more macro names.

   This makes a difference if you change the definition of ‘BUFSIZE’ at
some point in the source file.  ‘TABLESIZE’, defined as shown, will
always expand using the definition of ‘BUFSIZE’ that is currently in
effect:

     #define BUFSIZE 1020
     #define TABLESIZE BUFSIZE
     #undef BUFSIZE
     #define BUFSIZE 37

Now ‘TABLESIZE’ expands (in two stages) to ‘37’.

   If the expansion of a macro contains its own name, either directly or
via intermediate macros, it is not expanded again when the expansion is
examined for more macros.  This prevents infinite recursion.  *Note
Self-Referential Macros::, for the precise details.


File: c,  Node: Function-like Macros,  Next: Macro Arguments,  Prev: Object-like Macros,  Up: Macros

26.5.2 Function-like Macros
---------------------------

You can also define macros whose use looks like a function call.  These
are called “function-like macros”.  To define one, use the ‘#define’
directive with a pair of parentheses immediately after the macro name.
For example,

     #define lang_init()  c_init()
     lang_init()
          ↦ c_init()

   A function-like macro is expanded only when its name appears with a
pair of parentheses after it.  If you write just the name, without
parentheses, it is left alone.  This can be useful when you have a
function and a macro of the same name, and you wish to use the function
sometimes.  Whitespace and line breaks before or between the parentheses
are ignored when the macro is called.

     extern void foo(void);
     #define foo() /* optimized inline version */
     /* ... */
       foo();
       funcptr = foo;

   Here the call to ‘foo()’ expands the macro, but the function pointer
‘funcptr’ gets the address of the real function ‘foo’.  If the macro
were to be expanded there, it would cause a syntax error.

   If you put spaces between the macro name and the parentheses in the
macro definition, that does not define a function-like macro, it defines
an object-like macro whose expansion happens to begin with a pair of
parentheses.  Here is an example:

     #define lang_init ()    c_init()
     lang_init()
          ↦ () c_init()()

   The first two pairs of parentheses in this expansion come from the
macro.  The third is the pair that was originally after the macro
invocation.  Since ‘lang_init’ is an object-like macro, it does not
consume those parentheses.

   Any name can have at most one macro definition at a time.  Thus, you
can’t define the same name as an object-like macro and a function-like
macro at once.


File: c,  Node: Macro Arguments,  Next: Stringification,  Prev: Function-like Macros,  Up: Macros

26.5.3 Macro Arguments
----------------------

Function-like macros can take “arguments”, just like true functions.  To
define a macro that uses arguments, you insert “parameters” between the
pair of parentheses in the macro definition that make the macro
function-like.  The parameters must be valid C identifiers, separated by
commas and optionally whitespace.

   To invoke a macro that takes arguments, you write the name of the
macro followed by a list of “actual arguments” in parentheses, separated
by commas.  The invocation of the macro need not be restricted to a
single logical line—it can cross as many lines in the source file as you
wish.  The number of arguments you give must match the number of
parameters in the macro definition.  When the macro is expanded, each
use of a parameter in its body is replaced by the tokens of the
corresponding argument.  (The macro body is not required to use all of
the parameters.)

   As an example, here is a macro that computes the minimum of two
numeric values, as it is defined in many C programs, and some uses.

     #define min(X, Y)  ((X) < (Y) ? (X) : (Y))
       x = min(a, b);      ↦ x = ((a) < (b) ? (a) : (b));
       y = min(1, 2);      ↦ y = ((1) < (2) ? (1) : (2));
       z = min(a+28, *p);  ↦ z = ((a+28) < (*p) ? (a+28) : (*p));

In this small example you can already see several of the dangers of
macro arguments.  *Note Macro Pitfalls::, for detailed explanations.

   Leading and trailing whitespace in each argument is dropped, and all
whitespace between the tokens of an argument is reduced to a single
space.  Parentheses within each argument must balance; a comma within
such parentheses does not end the argument.  However, there is no
requirement for square brackets or braces to balance, and they do not
prevent a comma from separating arguments.  Thus,

     macro (array[x = y, x + 1])

passes two arguments to ‘macro’: ‘array[x = y’ and ‘x + 1]’.  If you
want to supply ‘array[x = y, x + 1]’ as an argument, you can write it as
‘array[(x = y, x + 1)]’, which is equivalent C code.  However, putting
an assignment inside an array subscript is to be avoided anyway.

   All arguments to a macro are completely macro-expanded before they
are substituted into the macro body.  After substitution, the complete
text is scanned again for macros to expand, including the arguments.
This rule may seem strange, but it is carefully designed so you need not
worry about whether any function call is actually a macro invocation.
You can run into trouble if you try to be too clever, though.  *Note
Argument Prescan::, for detailed discussion.

   For example, ‘min (min (a, b), c)’ is first expanded to

       min (((a) < (b) ? (a) : (b)), (c))

and then to

     ((((a) < (b) ? (a) : (b))) < (c)
      ? (((a) < (b) ? (a) : (b)))
      : (c))

(The line breaks shown here for clarity are not actually generated.)

   You can leave macro arguments empty without error, but many macros
will then expand to invalid code.  You cannot leave out arguments
entirely; if a macro takes two arguments, there must be exactly one
comma at the top level of its argument list.  Here are some silly
examples using ‘min’:

     min(, b)        ↦ ((   ) < (b) ? (   ) : (b))
     min(a, )        ↦ ((a  ) < ( ) ? (a  ) : ( ))
     min(,)          ↦ ((   ) < ( ) ? (   ) : ( ))
     min((,),)       ↦ (((,)) < ( ) ? ((,)) : ( ))

     min()      error→ macro "min" requires 2 arguments, but only 1 given
     min(,,)    error→ macro "min" passed 3 arguments, but takes just 2

   Whitespace is not a preprocessing token, so if a macro ‘foo’ takes
one argument, ‘foo ()’ and ‘foo ( )’ both supply it an empty argument.

   Macro parameters appearing inside string literals are not replaced by
their corresponding actual arguments.

     #define foo(x) x, "x"
     foo(bar)        ↦ bar, "x"

See the next subsection for how to insert macro arguments into a string
literal.

   The token following the macro call and the last token of the macro
expansion do not become one token even if it looks like they could:

     #define foo()  abc
     foo()def        ↦ abc def


File: c,  Node: Stringification,  Next: Concatenation,  Prev: Macro Arguments,  Up: Macros

26.5.4 Stringification
----------------------

Sometimes you may want to convert a macro argument into a string
constant.  Parameters are not replaced inside string constants, but you
can use the ‘#’ preprocessing operator instead.  When a macro parameter
is used with a leading ‘#’, preprocessing replaces it with the literal
text of the actual argument, converted to a string constant.  Unlike
normal parameter replacement, the argument is not macro-expanded first.
This is called “stringification”.

   There is no way to combine an argument with surrounding text and
stringify it all together.  But you can write a series of string
constants and stringified arguments.  After preprocessing replaces the
stringified arguments with string constants, the consecutive string
constants will be concatenated into one long string constant (*note
String Constants::).

   Here is an example that uses stringification and concatenation of
string constants:

     #define WARN_IF(EXP) \
       do { if (EXP) \
               fprintf (stderr, "Warning: " #EXP "\n"); } \
       while (0)

     WARN_IF (x == 0);
          ↦
       do { if (x == 0)
               fprintf (stderr, "Warning: " "x == 0" "\n"); }
       while (0);

The argument for ‘EXP’ is substituted once, as is, into the ‘if’
statement, and once, stringified, into the argument to ‘fprintf’.  If
‘x’ were a macro, it would be expanded in the ‘if’ statement but not in
the string.

   The ‘do’ and ‘while (0)’ are a kludge to make it possible to write
‘WARN_IF (ARG);’.  The resemblance of ‘WARN_IF’ to a function makes that
a natural way to write it.  *Note Swallowing the Semicolon::.

   Stringification in C involves more than putting double-quote
characters around the fragment.  It also backslash-escapes the quotes
surrounding embedded string constants, and all backslashes within string
and character constants, in order to get a valid C string constant with
the proper contents.  Thus, stringifying ‘p = "foo\n";’ results in
"p = \"foo\\n\";".  However, backslashes that are not inside string or
character constants are not duplicated: ‘\n’ by itself stringifies to
"\n".

   All leading and trailing whitespace in text being stringified is
ignored.  Any sequence of whitespace in the middle of the text is
converted to a single space in the stringified result.  Comments are
replaced by whitespace long before stringification happens, so they
never appear in stringified text.

   There is no way to convert a macro argument into a character
constant.

   To stringify the result of expansion of a macro argument, you have to
use two levels of macros, like this:

     #define xstr(S) str(S)
     #define str(s) #s
     #define foo 4
     str (foo)
          ↦ "foo"
     xstr (foo)
          ↦ xstr (4)
          ↦ str (4)
          ↦ "4"

   ‘s’ is stringified when it is used in ‘str’, so it is not
macro-expanded first.  But ‘S’ is an ordinary argument to ‘xstr’, so it
is completely macro-expanded before ‘xstr’ itself is expanded (*note
Argument Prescan::).  Therefore, by the time ‘str’ gets to its argument
text, that text already been macro-expanded.


File: c,  Node: Concatenation,  Next: Variadic Macros,  Prev: Stringification,  Up: Macros

26.5.5 Concatenation
--------------------

It is often useful to merge two tokens into one while expanding macros.
This is called “token pasting” or “token concatenation”.  The ‘##’
preprocessing operator performs token pasting.  When a macro is
expanded, the two tokens on either side of each ‘##’ operator are
combined into a single token, which then replaces the ‘##’ and the two
original tokens in the macro expansion.  Usually both will be
identifiers, or one will be an identifier and the other a preprocessing
number.  When pasted, they make a longer identifier.

   Concatenation into an identifier isn’t the only valid case.  It is
also possible to concatenate two numbers (or a number and a name, such
as ‘1.5’ and ‘e3’) into a number.  Also, multi-character operators such
as ‘+=’ can be formed by token pasting.

   However, two tokens that don’t together form a valid token cannot be
pasted together.  For example, you cannot concatenate ‘x’ with ‘+’, not
in either order.  Trying this issues a warning and keeps the two tokens
separate.  Whether it puts white space between the tokens is undefined.
It is common to find unnecessary uses of ‘##’ in complex macros.  If you
get this warning, it is likely that you can simply remove the ‘##’.

   The tokens combined by ‘##’ could both come from the macro body, but
then you could just as well write them as one token in the first place.
Token pasting is useful when one or both of the tokens comes from a
macro argument.  If either of the tokens next to an ‘##’ is a parameter
name, it is replaced by its actual argument before ‘##’ executes.  As
with stringification, the actual argument is not macro-expanded first.
If the argument is empty, that ‘##’ has no effect.

   Keep in mind that preprocessing converts comments to whitespace
before it looks for uses of macros.  Therefore, you cannot create a
comment by concatenating ‘/’ and ‘*’.  You can put as much whitespace
between ‘##’ and its operands as you like, including comments, and you
can put comments in arguments that will be concatenated.

   It is an error to use ‘##’ at the beginning or end of a macro body.

   Multiple ‘##’ operators are handled left-to-right, so that ‘1 ## e ##
-2’ pastes into ‘1e-2’.  (Right-to-left processing would first generate
‘e-2’, which is an invalid token.)  When ‘#’ and ‘##’ are used together,
they are all handled left-to-right.

   Consider a C program that interprets named commands.  There probably
needs to be a table of commands, perhaps an array of structures declared
as follows:

     struct command
     {
       char *name;
       void (*function) (void);
     };

     struct command commands[] =
     {
       { "quit", quit_command },
       { "help", help_command },
       /* ... */
     };

   It would be cleaner not to have to write each command name twice,
once in the string constant and once in the function name.  A macro that
takes the name of a command as an argument can make this unnecessary.
It can create the string constant with stringification, and the function
name by concatenating the argument with ‘_command’.  Here is how it is
done:

     #define COMMAND(NAME)  { #NAME, NAME ## _command }

     struct command commands[] =
     {
       COMMAND (quit),
       COMMAND (help),
       /* ... */
     };


File: c,  Node: Variadic Macros,  Next: Predefined Macros,  Prev: Concatenation,  Up: Macros

26.5.6 Variadic Macros
----------------------

A macro can be declared to accept a variable number of arguments much as
a function can.  The syntax for defining the macro is similar to that of
a function.  Here is an example:

     #define eprintf(...) fprintf (stderr, __VA_ARGS__)

   This kind of macro is called “variadic”.  When the macro is invoked,
all the tokens in its argument list after the last named argument (this
macro has none), including any commas, become the “variable argument”.
This sequence of tokens replaces the identifier ‘__VA_ARGS__’ in the
macro body wherever it appears.  Thus, we have this expansion:

     eprintf ("%s:%d: ", input_file, lineno)
          ↦  fprintf (stderr, "%s:%d: ", input_file, lineno)

   The variable argument is completely macro-expanded before it is
inserted into the macro expansion, just like an ordinary argument.  You
may use the ‘#’ and ‘##’ operators to stringify the variable argument or
to paste its leading or trailing token with another token.  (But see
below for an important special case for ‘##’.)

   *Warning:* don’t use the identifier ‘__VA_ARGS__’ for anything other
than this.

   If your macro is complicated, you may want a more descriptive name
for the variable argument than ‘__VA_ARGS__’.  You can write an argument
name immediately before the ‘...’; that name is used for the variable
argument.(1)  The ‘eprintf’ macro above could be written thus:

     #define eprintf(args...) fprintf (stderr, args)

   A variadic macro can have named arguments as well as variable
arguments, so ‘eprintf’ can be defined like this, instead:

     #define eprintf(format, ...) \
       fprintf (stderr, format, __VA_ARGS__)

This formulation is more descriptive, but what if you want to specify a
format string that takes no arguments?  In GNU C, you can omit the comma
before the variable arguments if they are empty, but that puts an extra
comma in the expansion:

     eprintf ("success!\n")
          ↦ fprintf(stderr, "success!\n", );

That’s an error in the call to ‘fprintf’.

   To get rid of that comma, the ‘##’ token paste operator has a special
meaning when placed between a comma and a variable argument.(2)  If you
write

     #define eprintf(format, ...) \
       fprintf (stderr, format, ##__VA_ARGS__)

then use the macro ‘eprintf’ with empty variable arguments, ‘##’ deletes
the preceding comma.

     eprintf ("success!\n")
          ↦ fprintf(stderr, "success!\n");

This does _not_ happen if you pass an empty argument, nor does it happen
if the token preceding ‘##’ is anything other than a comma.

When the only macro parameter is a variable arguments parameter, and the
macro call has no argument at all, it is not obvious whether that means
an empty argument or a missing argument.  Should the comma be kept, or
deleted?  The C standard says to keep the comma, but the preexisting GNU
C extension deleted the comma.  Nowadays, GNU C retains the comma when
implementing a specific C standard, and deletes it otherwise.

   C99 mandates that the only place the identifier ‘__VA_ARGS__’ can
appear is in the replacement list of a variadic macro.  It may not be
used as a macro name, macro parameter name, or within a different type
of macro.  It may also be forbidden in open text; the standard is
ambiguous.  We recommend you avoid using that name except for its
special purpose.

   Variadic macros where you specify the parameter name is a GNU C
feature that has been supported for a long time.  Standard C, as of C99,
supports only the form where the parameter is called ‘__VA_ARGS__’.  For
portability to previous versions of GNU C you should use only named
variable argument parameters.  On the other hand, for portability to
other C99 compilers, you should use only ‘__VA_ARGS__’.

   ---------- Footnotes ----------

   (1) GNU C extension.

   (2) GNU C extension.


File: c,  Node: Predefined Macros,  Next: Undefining and Redefining Macros,  Prev: Variadic Macros,  Up: Macros

26.5.7 Predefined Macros
------------------------

Several object-like macros are predefined; you use them without
supplying their definitions.  Here we explain the ones user programs
often need to use.  Many other macro names starting with ‘__’ are
predefined; in general, you should not define such macro names yourself.

‘__FILE__’
     This macro expands to the name of the current input file, in the
     form of a C string constant.  This is the full name by which the
     GCC opened the file, not the short name specified in ‘#include’ or
     as the input file name argument.  For example,
     ‘"/usr/local/include/myheader.h"’ is a possible expansion of this
     macro.

‘__LINE__’
     This macro expands to the current input line number, in the form of
     a decimal integer constant.  While we call it a predefined macro,
     it’s a pretty strange macro, since its “definition” changes with
     each new line of source code.

‘__func__’
‘__FUNCTION__’
     These names are like variables that have as value a string
     containing the name of the current function definition.  They are
     not really macros, but this is the best place to mention them.

     ‘__FUNCTION__’ is the name that has been defined in GNU C since
     time immemorial; ‘__func__’ is defined by the C standard.  With the
     following conditionals, you can use whichever one is defined.

          #if __STDC_VERSION__ < 199901L
          # if __GNUC__ >= 2
          #  define __func__ __FUNCTION__
          # else
          #  define __func__ "<unknown>"
          # endif
          #endif

‘__PRETTY_FUNCTION__’
     This is equivalent to ‘__FUNCTION__’ in C, but in C‘++’ the string
     includes argument type information as well.  It is a GNU C
     extension.

   Those features are useful in generating an error message to report an
inconsistency detected by the program; the message can state the source
line where the inconsistency was detected.  For example,

     fprintf (stderr, "Internal error: "
                      "negative string length "
                      "in function %s "
                      "%d at %s, line %d.",
              __func__, length, __FILE__, __LINE__);

   A ‘#line’ directive changes ‘__LINE__’, and may change ‘__FILE__’ as
well.  *Note Line Control::.

‘__DATE__’
     This macro expands to a string constant that describes the date of
     compilation.  The string constant contains eleven characters and
     looks like ‘"Feb 12 1996"’.  If the day of the month is just one
     digit, an extra space precedes it so that the date is always eleven
     characters.

     If the compiler cannot determine the current date, it emits a
     warning messages (once per compilation) and ‘__DATE__’ expands to
     ‘"??? ?? ????"’.

     We deprecate the use of ‘__DATE__’ for the sake of reproducible
     compilation.

‘__TIME__’
     This macro expands to a string constant that describes the time of
     compilation.  The string constant contains eight characters and
     looks like ‘"23:59:01"’.

     If the compiler cannot determine the current time, it emits a
     warning message (once per compilation) and ‘__TIME__’ expands to
     ‘"??:??:??"’.

     We deprecate the use of ‘__TIME__’ for the sake of reproducible
     compilation.

‘__STDC__’
     In normal operation, this macro expands to the constant 1, to
     signify that this compiler implements ISO Standard C.

‘__STDC_VERSION__’
     This macro expands to the C Standard’s version number, a long
     integer constant of the form ‘YYYYMML’ where YYYY and MM are the
     year and month of the Standard version.  This states which version
     of the C Standard the compiler implements.

     The current default value is ‘201112L’, which signifies the C 2011
     standard.

‘__STDC_HOSTED__’
     This macro is defined, with value 1, if the compiler’s target is a
     “hosted environment”.  A hosted environment provides the full
     facilities of the standard C library.

   The rest of the predefined macros are GNU C extensions.

‘__COUNTER__’
     This macro expands to sequential integral values starting from 0.
     In other words, each time the program uses this acro, it generates
     the next successive integer.  This, with the ‘##’ operator,
     provides a convenient means for macros to generate unique
     identifiers.

‘__GNUC__’
‘__GNUC_MINOR__’
‘__GNUC_PATCHLEVEL__’
     These macros expand to the major version, minor version, and patch
     level of the compiler, as integer constants.  For example, GCC
     3.2.1 expands ‘__GNUC__’ to 3, ‘__GNUC_MINOR__’ to 2, and
     ‘__GNUC_PATCHLEVEL__’ to 1.

     If all you need to know is whether or not your program is being
     compiled by GCC, or a non-GCC compiler that claims to accept the
     GNU C extensions, you can simply test ‘__GNUC__’.  If you need to
     write code that depends on a specific version, you must check more
     carefully.  Each change in the minor version resets the patch level
     to zero; each change in the major version (which happens rarely)
     resets the minor version and the patch level to zero.  To use the
     predefined macros directly in the conditional, write it like this:

          /* Test for version 3.2.0 or later. */
          #if __GNUC__ > 3 || \
              (__GNUC__ == 3 && (__GNUC_MINOR__ > 2 || \
                                 (__GNUC_MINOR__ == 2 && \
                                  __GNUC_PATCHLEVEL__ > 0))

     Another approach is to use the predefined macros to calculate a
     single number, then compare that against a threshold:

          #define GCC_VERSION (__GNUC__ * 10000 \
                               + __GNUC_MINOR__ * 100 \
                               + __GNUC_PATCHLEVEL__)
          /* ... */
          /* Test for GCC > 3.2.0 */
          #if GCC_VERSION > 30200

     Many people find this form easier to understand.

‘__VERSION__’
     This macro expands to a string constant that describes the version
     of the compiler in use.  You should not rely on its contents’
     having any particular form, but you can count on it to contain at
     least the release number.

‘__TIMESTAMP__’
     This macro expands to a string constant that describes the date and
     time of the last modification of the current source file.  The
     string constant contains abbreviated day of the week, month, day of
     the month, time in hh:mm:ss form, and the year, in the format
     ‘"Sun Sep 16 01:03:52 1973"’.  If the day of the month is less than
     10, it is padded with a space on the left.

     If GCC cannot determine that information date, it emits a warning
     message (once per compilation) and ‘__TIMESTAMP__’ expands to
     ‘"??? ??? ?? ??:??:?? ????"’.

     We deprecate the use of this macro for the sake of reproducible
     compilation.


File: c,  Node: Undefining and Redefining Macros,  Next: Directives Within Macro Arguments,  Prev: Predefined Macros,  Up: Macros

26.5.8 Undefining and Redefining Macros
---------------------------------------

You can “undefine” a macro with the ‘#undef’ directive.  ‘#undef’ takes
a single argument, the name of the macro to undefine.  You use the bare
macro name, even if the macro is function-like.  It is an error if
anything appears on the line after the macro name.  ‘#undef’ has no
effect if the name is not a macro.

     #define FOO 4
     x = FOO;        ↦ x = 4;
     #undef FOO
     x = FOO;        ↦ x = FOO;

   Once a macro has been undefined, that identifier may be “redefined”
as a macro by a subsequent ‘#define’ directive.  The new definition need
not have any resemblance to the old definition.

   You can define a macro again without first undefining it only if the
new definition is “effectively the same” as the old one.  Two macro
definitions are effectively the same if:

   • Both are the same type of macro (object- or function-like).
   • All the tokens of the replacement list are the same.
   • If there are any parameters, they are the same.
   • Whitespace appears in the same places in both.  It need not be
     exactly the same amount of whitespace, though.  Remember that
     comments count as whitespace.

These definitions are effectively the same:
     #define FOUR (2 + 2)
     #define FOUR         (2    +    2)
     #define FOUR (2 /* two */ + 2)
but these are not:
     #define FOUR (2 + 2)
     #define FOUR ( 2+2 )
     #define FOUR (2 * 2)
     #define FOUR(score,and,seven,years,ago) (2 + 2)

   This allows two different header files to define a common macro.

   You can redefine an existing macro with #define, but redefining an
existing macro name with a different definition results in a warning.


File: c,  Node: Directives Within Macro Arguments,  Next: Macro Pitfalls,  Prev: Undefining and Redefining Macros,  Up: Macros

26.5.9 Directives Within Macro Arguments
----------------------------------------

GNU C permits and handles preprocessing directives in the text provided
as arguments for a macro.  That case is undefined in the C standard.
but in GNU C conditional directives in macro arguments are clear and
valid.

   A paradoxical case is to redefine a macro within the call to that
same macro.  What happens is, the new definition takes effect in time
for pre-expansion of _all_ the arguments, then the original definition
is expanded to replace the call.  Here is a pathological example:

     #define f(x) x x
     f (first f second
     #undef f
     #define f 2
     f)

which expands to

     first 2 second 2 first 2 second 2

with the semantics described above.  We suggest you avoid writing code
which does this sort of thing.


File: c,  Node: Macro Pitfalls,  Prev: Directives Within Macro Arguments,  Up: Macros

26.5.10 Macro Pitfalls
----------------------

In this section we describe some special rules that apply to macros and
macro expansion, and point out certain cases in which the rules have
counter-intuitive consequences that you must watch out for.

* Menu:

* Misnesting::
* Operator Precedence Problems::
* Swallowing the Semicolon::
* Duplication of Side Effects::
* Macros and Auto Type::
* Self-Referential Macros::
* Argument Prescan::


File: c,  Node: Misnesting,  Next: Operator Precedence Problems,  Up: Macro Pitfalls

26.5.10.1 Misnesting
....................

When a macro is called with arguments, the arguments are substituted
into the macro body and the result is checked, together with the rest of
the input file, for more macro calls.  It is possible to piece together
a macro call coming partially from the macro body and partially from the
arguments.  For example,

     #define twice(x) (2*(x))
     #define call_with_1(x) x(1)
     call_with_1 (twice)
          ↦ twice(1)
          ↦ (2*(1))

   Macro definitions do not have to have balanced parentheses.  By
writing an unbalanced open parenthesis in a macro body, it is possible
to create a macro call that begins inside the macro body but ends
outside of it.  For example,

     #define strange(file) fprintf (file, "%s %d",
     /* ... */
     strange(stderr) p, 35)
          ↦ fprintf (stderr, "%s %d", p, 35)

   The ability to piece together a macro call can be useful, but the use
of unbalanced open parentheses in a macro body is just confusing, and
should be avoided.


File: c,  Node: Operator Precedence Problems,  Next: Swallowing the Semicolon,  Prev: Misnesting,  Up: Macro Pitfalls

26.5.10.2 Operator Precedence Problems
......................................

You may have noticed that in most of the macro definition examples shown
above, each occurrence of a macro parameter name had parentheses around
it.  In addition, another pair of parentheses usually surrounds the
entire macro definition.  Here is why it is best to write macros that
way.

   Suppose you define a macro as follows,

     #define ceil_div(x, y) (x + y - 1) / y

whose purpose is to divide, rounding up.  (One use for this operation is
to compute how many ‘int’ objects are needed to hold a certain number of
‘char’ objects.)  Then suppose it is used as follows:

     a = ceil_div (b & c, sizeof (int));
          ↦ a = (b & c + sizeof (int) - 1) / sizeof (int);

This does not do what is intended.  The operator-precedence rules of C
make it equivalent to this:

     a = (b & (c + sizeof (int) - 1)) / sizeof (int);

What we want is this:

     a = ((b & c) + sizeof (int) - 1)) / sizeof (int);

Defining the macro as

     #define ceil_div(x, y) ((x) + (y) - 1) / (y)

provides the desired result.

   Unintended grouping can result in another way.  Consider ‘sizeof
ceil_div(1, 2)’.  That has the appearance of a C expression that would
compute the size of the type of ‘ceil_div (1, 2)’, but in fact it means
something very different.  Here is what it expands to:

     sizeof ((1) + (2) - 1) / (2)

This would take the size of an integer and divide it by two.  The
precedence rules have put the division outside the ‘sizeof’ when it was
intended to be inside.

   Parentheses around the entire macro definition prevent such problems.
Here, then, is the recommended way to define ‘ceil_div’:

     #define ceil_div(x, y) (((x) + (y) - 1) / (y))


File: c,  Node: Swallowing the Semicolon,  Next: Duplication of Side Effects,  Prev: Operator Precedence Problems,  Up: Macro Pitfalls

26.5.10.3 Swallowing the Semicolon
..................................

Often it is desirable to define a macro that expands into a compound
statement.  Consider, for example, the following macro, that advances a
pointer (the parameter ‘p’ says where to find it) across whitespace
characters:

     #define SKIP_SPACES(p, limit)  \
     { char *lim = (limit);         \
       while (p < lim) {            \
         if (*p++ != ' ') {         \
           p--; break; }}}

Here backslash-newline is used to split the macro definition, which must
be a single logical line, so that it resembles the way such code would
be laid out if not part of a macro definition.

   A call to this macro might be ‘SKIP_SPACES (p, lim)’.  Strictly
speaking, the call expands to a compound statement, which is a complete
statement with no need for a semicolon to end it.  However, since it
looks like a function call, it minimizes confusion if you can use it
like a function call, writing a semicolon afterward, as in ‘SKIP_SPACES
(p, lim);’

   This can cause trouble before ‘else’ statements, because the
semicolon is actually a null statement.  Suppose you write

     if (*p != 0)
       SKIP_SPACES (p, lim);
     else /* ... */

The presence of two statements—the compound statement and a null
statement—in between the ‘if’ condition and the ‘else’ makes invalid C
code.

   The definition of the macro ‘SKIP_SPACES’ can be altered to solve
this problem, using a ‘do ... while’ statement.  Here is how:

     #define SKIP_SPACES(p, limit)     \
     do { char *lim = (limit);         \
          while (p < lim) {            \
            if (*p++ != ' ') {         \
              p--; break; }}}          \
     while (0)

   Now ‘SKIP_SPACES (p, lim);’ expands into

     do { /* ... */ } while (0);

which is one statement.  The loop executes exactly once; most compilers
generate no extra code for it.


File: c,  Node: Duplication of Side Effects,  Next: Macros and Auto Type,  Prev: Swallowing the Semicolon,  Up: Macro Pitfalls

26.5.10.4 Duplication of Side Effects
.....................................

Many C programs define a macro ‘min’, for “minimum”, like this:

     #define min(X, Y)  ((X) < (Y) ? (X) : (Y))

   When you use this macro with an argument containing a side effect, as
shown here,

     next = min (x + y, foo (z));

it expands as follows:

     next = ((x + y) < (foo (z)) ? (x + y) : (foo (z)));

where ‘x + y’ has been substituted for ‘X’ and ‘foo (z)’ for ‘Y’.

   The function ‘foo’ is used only once in the statement as it appears
in the program, but the expression ‘foo (z)’ has been substituted twice
into the macro expansion.  As a result, ‘foo’ might be called twice when
the statement is executed.  If it has side effects or if it takes a long
time to compute, that may be undesirable.  We say that ‘min’ is an
“unsafe” macro.

   The best solution to this problem is to define ‘min’ in a way that
computes the value of ‘foo (z)’ only once.  In general, that requires
using ‘__auto_type’ (*note Auto Type::).  How to use it for this is
described in the following section.  *Note Macros and Auto Type::.

   Otherwise, you will need to be careful when _using_ the macro ‘min’.
For example, you can calculate the value of ‘foo (z)’, save it in a
variable, and use that variable in ‘min’:

     #define min(X, Y)  ((X) < (Y) ? (X) : (Y))
     /* ... */
     {
       int tem = foo (z);
       next = min (x + y, tem);
     }

(where we assume that ‘foo’ returns type ‘int’).

   When the repeated value appears as the condition of the ‘?:’ operator
and again as its IFTRUE expression, you can avoid repeated execution by
omitting the IFTRUE expression, like this:

     #define x_or_y(X, Y)  ((X) ? : (Y))

In GNU C, this expands to use the first macro argument’s value if that
isn’t zero.  If that’s zero, it compiles the second argument and uses
that value.  *Note Conditional Expression::.


File: c,  Node: Macros and Auto Type,  Next: Self-Referential Macros,  Prev: Duplication of Side Effects,  Up: Macro Pitfalls

26.5.10.5 Using ‘__auto_type’ for Local Variables
.................................................

The operator ‘__auto_type’ makes it possible to define macros that can
work on any data type even though they need to generate local variable
declarations.  *Note Auto Type::.

   For instance, here’s how to define a safe “maximum” macro that
operates on any arithmetic type and computes each of its arguments
exactly once:

     #define max(a,b) \
       ({ __auto_type _a = (a); \
           __auto_type _b = (b); \
         _a > _b ? _a : _b; })

   The ‘({ ... })’ notation produces “statement expression”—a statement
that can be used as an expression (*note Statement Exprs::).  Its value
is the value of its last statement.  This permits us to define local
variables and store each argument value into one.

   The reason for using names that start with underscores for the local
variables is to avoid conflicts with variable names that occur within
the expressions that are substituted for ‘a’ and ‘b’.  Underscore
followed by a lower case letter won’t be predefined by the system in any
way.


File: c,  Node: Self-Referential Macros,  Next: Argument Prescan,  Prev: Macros and Auto Type,  Up: Macro Pitfalls

26.5.10.6 Self-Referential Macros
.................................

A “self-referential” macro is one whose name appears in its definition.
Recall that all macro definitions are rescanned for more macros to
replace.  If the self-reference were considered a use of the macro, it
would produce an infinitely large expansion.  To prevent this, the
self-reference is not considered a macro call: preprocessing leaves it
unchanged.  Consider an example:

     #define foo (4 + foo)

where ‘foo’ is also a variable in your program.

   Following the ordinary rules, each reference to ‘foo’ will expand
into ‘(4 + foo)’; then this will be rescanned and will expand into ‘(4 +
(4 + foo))’; and so on until the computer runs out of memory.

   The self-reference rule cuts this process short after one step, at
‘(4 + foo)’.  Therefore, this macro definition has the possibly useful
effect of causing the program to add 4 to the value of ‘foo’ wherever
‘foo’ is referred to.

   In most cases, it is a bad idea to take advantage of this feature.  A
person reading the program who sees that ‘foo’ is a variable will not
expect that it is a macro as well.  The reader will come across the
identifier ‘foo’ in the program and think its value should be that of
the variable ‘foo’, whereas in fact the value is four greater.

   It is useful to make a macro definition that expands to the macro
name itself.  If you write

     #define EPERM EPERM

then the macro ‘EPERM’ expands to ‘EPERM’.  Effectively, preprocessing
leaves it unchanged in the source code.  You can tell that it’s a macro
with ‘#ifdef’.  You might do this if you want to define numeric
constants with an ‘enum’, but have ‘#ifdef’ be true for each constant.

   If a macro ‘x’ expands to use a macro ‘y’, and the expansion of ‘y’
refers to the macro ‘x’, that is an “indirect self-reference” of ‘x’.
‘x’ is not expanded in this case either.  Thus, if we have

     #define x (4 + y)
     #define y (2 * x)

then ‘x’ and ‘y’ expand as follows:

     x    ↦ (4 + y)
          ↦ (4 + (2 * x))

     y    ↦ (2 * x)
          ↦ (2 * (4 + y))

Each macro is expanded when it appears in the definition of the other
macro, but not when it indirectly appears in its own definition.


File: c,  Node: Argument Prescan,  Prev: Self-Referential Macros,  Up: Macro Pitfalls

26.5.10.7 Argument Prescan
..........................

Macro arguments are completely macro-expanded before they are
substituted into a macro body, unless they are stringified or pasted
with other tokens.  After substitution, the entire macro body, including
the substituted arguments, is scanned again for macros to be expanded.
The result is that the arguments are scanned _twice_ to expand macro
calls in them.

   Most of the time, this has no effect.  If the argument contained any
macro calls, they were expanded during the first scan.  The result
therefore contains no macro calls, so the second scan does not change
it.  If the argument were substituted as given, with no prescan, the
single remaining scan would find the same macro calls and produce the
same results.

   You might expect the double scan to change the results when a
self-referential macro is used in an argument of another macro (*note
Self-Referential Macros::): the self-referential macro would be expanded
once in the first scan, and a second time in the second scan.  However,
this is not what happens.  The self-references that do not expand in the
first scan are marked so that they will not expand in the second scan
either.

   You might wonder, “Why mention the prescan, if it makes no
difference?  And why not skip it and make preprocessing go faster?” The
answer is that the prescan does make a difference in three special
cases:

   • Nested calls to a macro.

     We say that “nested” calls to a macro occur when a macro’s argument
     contains a call to that very macro.  For example, if ‘f’ is a macro
     that expects one argument, ‘f (f (1))’ is a nested pair of calls to
     ‘f’.  The desired expansion is made by expanding ‘f (1)’ and
     substituting that into the definition of ‘f’.  The prescan causes
     the expected result to happen.  Without the prescan, ‘f (1)’ itself
     would be substituted as an argument, and the inner use of ‘f’ would
     appear during the main scan as an indirect self-reference and would
     not be expanded.

   • Macros that call other macros that stringify or concatenate.

     If an argument is stringified or concatenated, the prescan does not
     occur.  If you _want_ to expand a macro, then stringify or
     concatenate its expansion, you can do that by causing one macro to
     call another macro that does the stringification or concatenation.
     For instance, if you have

          #define AFTERX(x) X_ ## x
          #define XAFTERX(x) AFTERX(x)
          #define TABLESIZE 1024
          #define BUFSIZE TABLESIZE

     then ‘AFTERX(BUFSIZE)’ expands to ‘X_BUFSIZE’, and
     ‘XAFTERX(BUFSIZE)’ expands to ‘X_1024’.  (Not to ‘X_TABLESIZE’.
     Prescan always does a complete expansion.)

   • Macros used in arguments, whose expansions contain unshielded
     commas.

     This can cause a macro expanded on the second scan to be called
     with the wrong number of arguments.  Here is an example:

          #define foo  a,b
          #define bar(x) lose(x)
          #define lose(x) (1 + (x))

     We would like ‘bar(foo)’ to turn into ‘(1 + (foo))’, which would
     then turn into ‘(1 + (a,b))’.  Instead, ‘bar(foo)’ expands into
     ‘lose(a,b)’, which gives an error because ‘lose’ requires a single
     argument.  In this case, the problem is easily solved by the same
     parentheses that ought to be used to prevent misnesting of
     arithmetic operations:

          #define foo (a,b)
     or
          #define bar(x) lose((x))

     The extra pair of parentheses prevents the comma in ‘foo’’s
     definition from being interpreted as an argument separator.


File: c,  Node: Conditionals,  Next: Diagnostics,  Prev: Macros,  Up: Preprocessing

26.6 Conditionals
=================

A “conditional” is a preprocessing directive that controls whether or
not to include a chunk of code in the final token stream that is
compiled.  Preprocessing conditionals can test arithmetic expressions,
or whether a name is defined as a macro, or both together using the
special ‘defined’ operator.

   A preprocessing conditional in C resembles in some ways an ‘if’
statement in C, but it is important to understand the difference between
them.  The condition in an ‘if’ statement is tested during the execution
of your program.  Its purpose is to allow your program to behave
differently from run to run, depending on the data it is operating on.
The condition in a preprocessing conditional directive is tested when
your program is compiled.  Its purpose is to allow different code to be
included in the program depending on the situation at the time of
compilation.

   Sometimes this distinction makes no practical difference.  GCC and
other modern compilers often do test ‘if’ statements when a program is
compiled, if their conditions are known not to vary at run time, and
eliminate code that can never be executed.  If you can count on your
compiler to do this, you may find that your program is more readable if
you use ‘if’ statements with constant conditions (perhaps determined by
macros).  Of course, you can only use this to exclude code, not type
definitions or other preprocessing directives, and you can only do it if
the file remains syntactically valid when that code is not used.

* Menu:

* Conditional Uses::
* Conditional Syntax::
* Deleted Code::


File: c,  Node: Conditional Uses,  Next: Conditional Syntax,  Up: Conditionals

26.6.1 Uses of Conditional Directives
-------------------------------------

There are three usual reasons to use a preprocessing conditional.

   • A program may need to use different code depending on the machine
     or operating system it is to run on.  In some cases the code for
     one operating system may be erroneous on another operating system;
     for example, it might refer to data types or constants that do not
     exist on the other system.  When this happens, it is not enough to
     avoid executing the invalid code.  Its mere presence will cause the
     compiler to reject the program.  With a preprocessing conditional,
     the offending code can be effectively excised from the program when
     it is not valid.

   • You may want to be able to compile the same source file into two
     different programs.  One version might make frequent time-consuming
     consistency checks on its intermediate data, or print the values of
     those data for debugging, and the other not.

   • A conditional whose condition is always false is one way to exclude
     code from the program but keep it as a sort of comment for future
     reference.

   Simple programs that do not need system-specific logic or complex
debugging hooks generally will not need to use preprocessing
conditionals.


File: c,  Node: Conditional Syntax,  Next: Deleted Code,  Prev: Conditional Uses,  Up: Conditionals

26.6.2 Syntax of Preprocessing Conditionals
-------------------------------------------

A preprocessing conditional begins with a “conditional directive”:
‘#if’, ‘#ifdef’ or ‘#ifndef’.

* Menu:

* ifdef::
* if::
* defined::
* else::
* elif::


File: c,  Node: ifdef,  Next: if,  Up: Conditional Syntax

26.6.2.1 The ‘#ifdef’ directive
...............................

The simplest sort of conditional is

     #ifdef MACRO

     CONTROLLED TEXT

     #endif /* MACRO */

   This block is called a “conditional group”.  The body, CONTROLLED
TEXT, will be included in compilation if and only if MACRO is defined.
We say that the conditional “succeeds” if MACRO is defined, “fails” if
it is not.

   The CONTROLLED TEXT inside a conditional can include preprocessing
directives.  They are executed only if the conditional succeeds.  You
can nest conditional groups inside other conditional groups, but they
must be completely nested.  In other words, ‘#endif’ always matches the
nearest ‘#ifdef’ (or ‘#ifndef’, or ‘#if’).  Also, you cannot start a
conditional group in one file and end it in another.

   Even if a conditional fails, the CONTROLLED TEXT inside it is still
run through initial transformations and tokenization.  Therefore, it
must all be lexically valid C.  Normally the only way this matters is
that all comments and string literals inside a failing conditional group
must still be properly ended.

   The comment following the ‘#endif’ is not required, but it is a good
practice if there is a lot of CONTROLLED TEXT, because it helps people
match the ‘#endif’ to the corresponding ‘#ifdef’.

   Older programs sometimes put MACRO directly after the ‘#endif’
without enclosing it in a comment.  This is invalid code according to
the C standard, but it only causes a warning in GNU C.  It never affects
which ‘#ifndef’ the ‘#endif’ matches.

   Sometimes you wish to use some code if a macro is _not_ defined.  You
can do this by writing ‘#ifndef’ instead of ‘#ifdef’.  One common use of
‘#ifndef’ is to include code only the first time a header file is
included.  *Note Once-Only Headers::.

   Macro definitions can vary between compilations for several reasons.
Here are some samples.

   • Some macros are predefined on each kind of machine (*note
     System-specific Predefined Macros: (gcc)System-specific Predefined
     Macros.).  This allows you to provide code specially tuned for a
     particular machine.

   • System header files define more macros, associated with the
     features they implement.  You can test these macros with
     conditionals to avoid using a system feature on a machine where it
     is not implemented.

   • Macros can be defined or undefined with the ‘-D’ and ‘-U’
     command-line options when you compile the program.  You can arrange
     to compile the same source file into two different programs by
     choosing a macro name to specify which program you want, writing
     conditionals to test whether or how this macro is defined, and then
     controlling the state of the macro with command-line options,
     perhaps set in the file ‘Makefile’.  *Note Invoking GCC:
     (gcc)Invocation.

   • Your program might have a special header file (often called
     ‘config.h’) that is adjusted when the program is compiled.  It can
     define or not define macros depending on the features of the system
     and the desired capabilities of the program.  The adjustment can be
     automated by a tool such as ‘autoconf’, or done by hand.


File: c,  Node: if,  Next: defined,  Prev: ifdef,  Up: Conditional Syntax

26.6.2.2 The ‘#if’ directive
............................

The ‘#if’ directive allows you to test the value of an integer
arithmetic expression, rather than the mere existence of one macro.  Its
syntax is

     #if EXPRESSION

     CONTROLLED TEXT

     #endif /* EXPRESSION */

   EXPRESSION is a C expression of integer type, subject to stringent
restrictions so its value can be computed at compile time.  It may
contain

   • Integer constants.

   • Character constants, which are interpreted as they would be in
     normal code.

   • Arithmetic operators for addition, subtraction, multiplication,
     division, bitwise operations, shifts, comparisons, and logical
     operations (‘&&’ and ‘||’).  The latter two obey the usual
     short-circuiting rules of standard C.

   • Macros.  All macros in the expression are expanded before actual
     computation of the expression’s value begins.

   • Uses of the ‘defined’ operator, which lets you check whether macros
     are defined in the middle of an ‘#if’.

   • Identifiers that are not macros, which are all considered to be the
     number zero.  This allows you to write ‘#if MACRO’ instead of
     ‘#ifdef MACRO’, if you know that MACRO, when defined, will always
     have a nonzero value.  Function-like macros used without their
     function call parentheses are also treated as zero.

     In some contexts this shortcut is undesirable.  The ‘-Wundef’
     requests warnings for any identifier in an ‘#if’ that is not
     defined as a macro.

   Preprocessing does not know anything about the data types of C.
Therefore, ‘sizeof’ operators are not recognized in ‘#if’; ‘sizeof’ is
simply an identifier, and if it is not a macro, it stands for zero.
This is likely to make the expression invalid.  Preprocessing does not
recognize ‘enum’ constants; they too are simply identifiers, so if they
are not macros, they stand for zero.

   Preprocessing calculates the value of EXPRESSION, and carries out all
calculations in the widest integer type known to the compiler; on most
machines supported by GNU C this is 64 bits.  This is not the same rule
as the compiler uses to calculate the value of a constant expression,
and may give different results in some cases.  If the value comes out to
be nonzero, the ‘#if’ succeeds and the CONTROLLED TEXT is compiled;
otherwise it is skipped.


File: c,  Node: defined,  Next: else,  Prev: if,  Up: Conditional Syntax

26.6.2.3 The ‘defined’ test
...........................

The special operator ‘defined’ is used in ‘#if’ and ‘#elif’ expressions
to test whether a certain name is defined as a macro.  ‘defined NAME’
and ‘defined (NAME)’ are both expressions whose value is 1 if NAME is
defined as a macro at the current point in the program, and 0 otherwise.
Thus, ‘#if defined MACRO’ is precisely equivalent to ‘#ifdef MACRO’.

   ‘defined’ is useful when you wish to test more than one macro for
existence at once.  For example,

     #if defined (__arm__) || defined (__PPC__)

would succeed if either of the names ‘__arm__’ or ‘__PPC__’ is defined
as a macro—in other words, when compiling for ARM processors or PowerPC
processors.

   Conditionals written like this:

     #if defined BUFSIZE && BUFSIZE >= 1024

can generally be simplified to just ‘#if BUFSIZE >= 1024’, since if
‘BUFSIZE’ is not defined, it will be interpreted as having the value
zero.

   In GCC, you can include ‘defined’ as part of another macro
definition, like this:

     #define MACRO_DEFINED(X) defined X

     #if MACRO_DEFINED(BUFSIZE)

which would expand the ‘#if’ expression to:

     #if defined BUFSIZE

Generating ‘defined’ in this way is a GNU C extension.


File: c,  Node: else,  Next: elif,  Prev: defined,  Up: Conditional Syntax

26.6.2.4 The ‘#else’ directive
..............................

The ‘#else’ directive can be added to a conditional to provide
alternative text to be used if the condition fails.  This is what it
looks like:

     #if EXPRESSION
     TEXT-IF-TRUE
     #else /* Not EXPRESSION */
     TEXT-IF-FALSE
     #endif /* Not EXPRESSION */

If EXPRESSION is nonzero, the TEXT-IF-TRUE is included and the
TEXT-IF-FALSE is skipped.  If EXPRESSION is zero, the opposite happens.

   You can use ‘#else’ with ‘#ifdef’ and ‘#ifndef’, too.


File: c,  Node: elif,  Prev: else,  Up: Conditional Syntax

26.6.2.5 The ‘#elif’ directive
..............................

One common case of nested conditionals is used to check for more than
two possible alternatives.  For example, you might have

     #if X == 1
     /* ... */
     #else /* X != 1 */
     #if X == 2
     /* ... */
     #else /* X != 2 */
     /* ... */
     #endif /* X != 2 */
     #endif /* X != 1 */

   Another conditional directive, ‘#elif’, allows this to be abbreviated
as follows:

     #if X == 1
     /* ... */
     #elif X == 2
     /* ... */
     #else /* X != 2 and X != 1*/
     /* ... */
     #endif /* X != 2 and X != 1*/

   ‘#elif’ stands for “else if”.  Like ‘#else’, it goes in the middle of
a conditional group and subdivides it; it does not require a matching
‘#endif’ of its own.  Like ‘#if’, the ‘#elif’ directive includes an
expression to be tested.  The text following the ‘#elif’ is processed
only if the original ‘#if’-condition failed and the ‘#elif’ condition
succeeds.

   More than one ‘#elif’ can go in the same conditional group.  Then the
text after each ‘#elif’ is processed only if the ‘#elif’ condition
succeeds after the original ‘#if’ and all previous ‘#elif’ directives
within it have failed.

   ‘#else’ is allowed after any number of ‘#elif’ directives, but
‘#elif’ may not follow ‘#else’.


File: c,  Node: Deleted Code,  Prev: Conditional Syntax,  Up: Conditionals

26.6.3 Deleted Code
-------------------

If you replace or delete a part of the program but want to keep the old
code in the file for future reference, commenting it out is not so
straightforward in C. Block comments do not nest, so the first comment
inside the old code will end the commenting-out.  The probable result is
a flood of syntax errors.

   One way to avoid this problem is to use an always-false conditional
instead.  For instance, put ‘#if 0’ before the deleted code and ‘#endif’
after it.  This works even if the code being turned off contains
conditionals, but they must be entire conditionals (balanced ‘#if’ and
‘#endif’).

   Some people use ‘#ifdef notdef’ instead.  This is risky, because
‘notdef’ might be accidentally defined as a macro, and then the
conditional would succeed.  ‘#if 0’ can be counted on to fail.

   Do not use ‘#if 0’ around text that is not C code.  Use a real
comment, instead.  The interior of ‘#if 0’ must consist of complete
tokens; in particular, single-quote characters must balance.  Comments
often contain unbalanced single-quote characters (known in English as
apostrophes).  These confuse ‘#if 0’.  They don’t confuse ‘/*’.


File: c,  Node: Diagnostics,  Next: Line Control,  Prev: Conditionals,  Up: Preprocessing

26.7 Diagnostics
================

The directive ‘#error’ reports a fatal error.  The tokens forming the
rest of the line following ‘#error’ are used as the error message.

   The usual place to use ‘#error’ is inside a conditional that detects
a combination of parameters that you know the program does not properly
support.  For example,

     #if !defined(UNALIGNED_INT_ASM_OP) && defined(DWARF2_DEBUGGING_INFO)
     #error "DWARF2_DEBUGGING_INFO requires UNALIGNED_INT_ASM_OP."
     #endif

   The directive ‘#warning’ is like ‘#error’, but it reports a warning
instead of an error.  The tokens following ‘#warning’ are used as the
warning message.

   You might use ‘#warning’ in obsolete header files, with a message
saying which header file to use instead.

   Neither ‘#error’ nor ‘#warning’ macro-expands its argument.  Internal
whitespace sequences are each replaced with a single space.  The line
must consist of complete tokens.  It is wisest to make the argument of
these directives be a single string constant; this avoids problems with
apostrophes and the like.


File: c,  Node: Line Control,  Next: Null Directive,  Prev: Diagnostics,  Up: Preprocessing

26.8 Line Control
=================

Due to C’s widespread availability and low-level nature, it is often
used as the target language for translation of other languages, or for
the output of lexical analyzers and parsers (e.g., lex/flex and
yacc/bison).  Line control enables the user to track diagnostics back to
the location in the original language.

   The C compiler knows the location in the source file where each token
came from: file name, starting line and column, and final line and
column.  (Column numbers are used only for error messages.)

   When a program generates C source code, as the Bison parser generator
does, often it copies some of that C code from another file.  For
instance parts of the output from Bison are generated from scratch or
come from a standard parser file, but Bison copies the rest from Bison’s
input file.  Errors in that code, at compile time or run time, should
refer to that file, which is the real source code.  To make that happen,
Bison generates line-control directives that the C compiler understands.

   ‘#line’ is a directive that specifies the original line number and
source file name for subsequent code.  ‘#line’ has three variants:

‘#line LINENUM’
     LINENUM is a non-negative decimal integer constant.  It specifies
     the line number that should be reported for the following line of
     input.  Subsequent lines are counted from LINENUM.

‘#line LINENUM FILENAME’
     LINENUM is the same as for the first form, and has the same effect.
     In addition, FILENAME is a string constant that specifies the
     source file name.  Subsequent source lines are recorded as coming
     from that file, until something else happens to change that.
     FILENAME is interpreted according to the normal rules for a string
     constant.  Backslash escapes are interpreted, in contrast to
     ‘#include’.

‘#line ANYTHING ELSE’
     ANYTHING ELSE is checked for macro calls, which are expanded.  The
     result should match one of the above two forms.

   ‘#line’ directives alter the results of the ‘__FILE__’ and ‘__LINE__’
symbols from that point on.  *Note Predefined Macros::.


File: c,  Node: Null Directive,  Prev: Line Control,  Up: Preprocessing

26.9 Null Directive
===================

The “null directive” consists of a ‘#’ followed by a newline, with only
whitespace and comments in between.  It has no effect on the output of
the compiler.


File: c,  Node: Integers in Depth,  Next: Floating Point in Depth,  Prev: Preprocessing,  Up: Top

27 Integers in Depth
********************

This chapter explains the machine-level details of integer types: how
they are represented as bits in memory, and the range of possible values
for each integer type.

* Menu:

* Integer Representations::      How integer values appear in memory.
* Maximum and Minimum Values::   Value ranges of integer types.


File: c,  Node: Integer Representations,  Next: Maximum and Minimum Values,  Up: Integers in Depth

27.1 Integer Representations
============================

Modern computers store integer values as binary (base-2) numbers that
occupy a single unit of storage, typically either as an 8-bit ‘char’, a
16-bit ‘short int’, a 32-bit ‘int’, or possibly, a 64-bit ‘long long
int’.  Whether a ‘long int’ is a 32-bit or a 64-bit value is system
dependent.(1)

   The macro ‘CHAR_BIT’, defined in ‘limits.h’, gives the number of bits
in type ‘char’.  On any real operating system, the value is 8.

   The fixed sizes of numeric types necessarily limits their “range of
values”, and the particular encoding of integers decides what that range
is.

   For unsigned integers, the entire space is used to represent a
nonnegative value.  Signed integers are stored using “two’s-complement
representation”: a signed integer with N bits has a range from -2^{(N -
1)} to −1 to 0 to 1 to +2^{(N - 1)} - 1, inclusive.  The leftmost, or
high-order, bit is called the “sign bit”.

   There is only one value that means zero, and the most negative number
lacks a positive counterpart.  As a result, negating that number causes
overflow; in practice, its result is that number back again.  For
example, a two’s-complement signed 8-bit integer can represent all
decimal numbers from −128 to +127.  We will revisit that peculiarity
shortly.

   Decades ago, there were computers that didn’t use two’s-complement
representation for integers (*note Integers in Depth::), but they are
long gone and not worth any effort to support.

   When an arithmetic operation produces a value that is too big to
represent, the operation is said to “overflow”.  In C, integer overflow
does not interrupt the control flow or signal an error.  What it does
depends on signedness.

   For unsigned arithmetic, the result of an operation that overflows is
the N low-order bits of the correct value.  If the correct value is
representable in N bits, that is always the result; thus we often say
that “integer arithmetic is exact,” omitting the crucial qualifying
phrase “as long as the exact result is representable.”

   In principle, a C program should be written so that overflow never
occurs for signed integers, but in GNU C you can specify various ways of
handling such overflow (*note Integer Overflow::).

   Integer representations are best understood by looking at a table for
a tiny integer size; here are the possible values for an integer with
three bits:

Unsigned           Signed             Bits               2s Complement
----------------------------------------------------------------------------
0                  0                  000                000 (0)
1                  1                  001                111 (-1)
2                  2                  010                110 (-2)
3                  3                  011                101 (-3)
4                  -4                 100                100 (-4)
5                  -3                 101                011 (3)
6                  -2                 110                010 (2)
7                  -1                 111                001 (1)

   The parenthesized decimal numbers in the last column represent the
signed meanings of the two’s-complement of the line’s value.  Recall
that, in two’s-complement encoding, the high-order bit is 0 when the
number is nonnegative.

   We can now understand the peculiar behavior of negation of the most
negative two’s-complement integer: start with 0b100, invert the bits to
get 0b011, and add 1: we get 0b100, the value we started with.

   We can also see overflow behavior in two’s-complement:

     3 + 1 = 0b011 + 0b001 = 0b100 = (-4)
     3 + 2 = 0b011 + 0b010 = 0b101 = (-3)
     3 + 3 = 0b011 + 0b011 = 0b110 = (-2)

A sum of two nonnegative signed values that overflows has a 1 in the
sign bit, so the exact positive result is truncated to a negative value.

   ---------- Footnotes ----------

   (1) In theory, any of these types could have some other size, bit
it’s not worth even a minute to cater to that possibility.  It never
happens on GNU/Linux.


File: c,  Node: Maximum and Minimum Values,  Prev: Integer Representations,  Up: Integers in Depth

27.2 Maximum and Minimum Values
===============================

For each primitive integer type, there is a standard macro defined in
‘limits.h’ that gives the largest value that type can hold.  For
instance, for type ‘int’, the maximum value is ‘INT_MAX’.  On a 32-bit
computer, that is equal to 2,147,483,647.  The maximum value for
‘unsigned int’ is ‘UINT_MAX’, which on a 32-bit computer is equal to
4,294,967,295.  Likewise, there are ‘SHRT_MAX’, ‘LONG_MAX’, and
‘LLONG_MAX’, and corresponding unsigned limits ‘USHRT_MAX’, ‘ULONG_MAX’,
and ‘ULLONG_MAX’.

   Since there are three ways to specify a ‘char’ type, there are also
three limits: ‘CHAR_MAX’, ‘SCHAR_MAX’, and ‘UCHAR_MAX’.

   For each type that is or might be signed, there is another symbol
that gives the minimum value it can hold.  (Just replace ‘MAX’ with
‘MIN’ in the names listed above.)  There is no minimum limit symbol for
types specified with ‘unsigned’ because the minimum for them is
universally zero.

   ‘INT_MIN’ is not the negative of ‘INT_MAX’.  In two’s-complement
representation, the most negative number is 1 less than the negative of
the most positive number.  Thus, ‘INT_MIN’ on a 32-bit computer has the
value −2,147,483,648.  You can’t actually write the value that way in C,
since it would overflow.  That’s a good reason to use ‘INT_MIN’ to
specify that value.  Its definition is written to avoid overflow.


File: c,  Node: Floating Point in Depth,  Next: Compilation,  Prev: Integers in Depth,  Up: Top

28 Floating Point in Depth
**************************

* Menu:

* Floating Representations::
* Floating Type Specs::
* Special Float Values::
* Invalid Optimizations::
* Exception Flags::
* Exact Floating-Point::
* Rounding::
* Rounding Issues::
* Significance Loss::
* Fused Multiply-Add::
* Error Recovery::
* Exact Floating Constants::
* Handling Infinity::
* Handling NaN::
* Signed Zeros::
* Scaling by the Base::
* Rounding Control::
* Machine Epsilon::
* Complex Arithmetic::
* Round-Trip Base Conversion::
* Further Reading::


File: c,  Node: Floating Representations,  Next: Floating Type Specs,  Up: Floating Point in Depth

28.1 Floating-Point Representations
===================================

Storing numbers as “floating point” allows representation of numbers
with fractional values, in a range larger than that of hardware
integers.  A floating-point number consists of a sign bit, a
“significand” (also called the “mantissa”), and a power of a fixed base.
GNU C uses the floating-point representations specified by the ‘IEEE
754-2008 Standard for Floating-Point Arithmetic’.

   The IEEE 754-2008 specification defines basic binary floating-point
formats of five different sizes: 16-bit, 32-bit, 64-bit, 128-bit, and
256-bit.  The formats of 32, 64, and 128 bits are used for the standard
C types ‘float’, ‘double’, and ‘long double’.  GNU C supports the 16-bit
floating point type ‘_Float16’ on some platforms, but does not support
the 256-bit floating point type.

   Each of the formats encodes the floating-point number as a sign bit.
After this comes an exponent that specifies a power of 2 (with a fixed
offset).  Then comes the significand.

   The first bit of the significand, before the binary point, is always
1, so there is no need to store it in memory.  It is called the “hidden
bit” because it doesn’t appear in the floating-point number as used in
the computer itself.

   All of those floating-point formats are sign-magnitude
representations, so +0 and −0 are different values.

   Besides the IEEE 754 format 128-bit float, GNU C also offers a format
consisting of a pair of 64-bit floating point numbers.  This lacks the
full exponent range of the IEEE 128-bit format, but is useful when the
underlying hardware platform does not support that.


File: c,  Node: Floating Type Specs,  Next: Special Float Values,  Prev: Floating Representations,  Up: Floating Point in Depth

28.2 Floating-Point Type Specifications
=======================================

The standard library header file ‘float.h’ defines a number of constants
that describe the platform’s implementation of floating-point types
‘float’, ‘double’ and ‘long double’.  They include:

‘FLT_MIN’
‘DBL_MIN’
‘LDBL_MIN’
     Defines the minimum normalized positive floating-point values that
     can be represented with the type.

‘FLT_HAS_SUBNORM’
‘DBL_HAS_SUBNORM’
‘LDBL_HAS_SUBNORM’
     Defines if the floating-point type supports subnormal (or
     “denormalized”) numbers or not (*note subnormal numbers::).

‘FLT_TRUE_MIN’
‘DBL_TRUE_MIN’
‘LDBL_TRUE_MIN’
     Defines the minimum positive values (including subnormal values)
     that can be represented with the type.

‘FLT_MAX’
‘DBL_MAX’
‘LDBL_MAX’
     Defines the largest values that can be represented with the type.

‘FLT_DECIMAL_DIG’
‘DBL_DECIMAL_DIG’
‘LDBL_DECIMAL_DIG’
     Defines the number of decimal digits ‘n’ such that any
     floating-point number that can be represented in the type can be
     rounded to a floating-point number with ‘n’ decimal digits, and
     back again, without losing any precision of the value.


File: c,  Node: Special Float Values,  Next: Invalid Optimizations,  Prev: Floating Type Specs,  Up: Floating Point in Depth

28.3 Special Floating-Point Values
==================================

IEEE floating point provides for special values that are not ordinary
numbers.

infinities
     ‘+Infinity’ and ‘-Infinity’ are two different infinite values, one
     positive and one negative.  These result from operations such as ‘1
     / 0’, ‘Infinity + Infinity’, ‘Infinity * Infinity’, and ‘Infinity +
     FINITE’, and also from a result that is finite, but larger than the
     most positive possible value or smaller than the most negative
     possible value.

     *Note Handling Infinity::, for more about working with infinities.

NaNs (not a number)
     There are two special values, called Not-a-Number (NaN): a quiet
     NaN (QNaN), and a signaling NaN (SNaN).

     A QNaN is produced by operations for which the value is undefined
     in real arithmetic, such as ‘0 / 0’, ‘sqrt (-1)’, ‘Infinity -
     Infinity’, and any basic operation in which an operand is a QNaN.

     The signaling NaN is intended for initializing otherwise-unassigned
     storage, and the goal is that unlike a QNaN, an SNaN _does_ cause
     an interrupt that can be caught by a software handler, diagnosed,
     and reported.  In practice, little use has been made of signaling
     NaNs, because the most common CPUs in desktop and portable
     computers fail to implement the full IEEE 754 Standard, and supply
     only one kind of NaN, the quiet one.  Also, programming-language
     standards have taken decades to catch up to the IEEE 754 standard,
     and implementations of those language standards make an additional
     delay before programmers become willing to use these features.

     To enable support for signaling NaNs, use the GCC command-line
     option ‘-fsignaling-nans’, but this is an experimental feature and
     may not work as expected in every situation.

     A NaN has a sign bit, but its value means nothing.

     *Note Handling NaN::, for more about working with NaNs.

subnormal numbers
     It can happen that a computed floating-point value is too small to
     represent, such as when two tiny numbers are multiplied.  The
     result is then said to “underflow”.  The traditional behavior
     before the IEEE 754 Standard was to use zero as the result, and
     possibly to report the underflow in some sort of program output.

     The IEEE 754 Standard is vague about whether rounding happens
     before detection of floating underflow and overflow, or after, and
     CPU designers may choose either.

     However, the Standard does something unusual compared to earlier
     designs, and that is that when the result is smaller than the
     smallest “normalized” representable value (i.e., one in which the
     leading significand bit is ‘1’), the normalization requirement is
     relaxed, leading zero bits are permitted, and precision is
     gradually lost until there are no more bits in the significand.
     That phenomenon is called “gradual underflow”, and it serves
     important numerical purposes, although it does reduce the precision
     of the final result.  Some floating-point designs allow you to
     choose at compile time, or even at run time, whether underflows are
     gradual, or are flushed abruptly to zero.  Numbers that have
     entered the region of gradual underflow are called “subnormal”.

     You can use the library functions ‘fesetround’ and ‘fegetround’ to
     set and get the rounding mode.  Rounding modes are defined (if
     supported by the platform) in ‘fenv.h’ as: ‘FE_UPWARD’ to round
     toward positive infinity; ‘FE_DOWNWARD’ to round toward negative
     infinity; ‘FE_TOWARDZERO’ to round toward zero; and ‘FE_TONEAREST’
     to round to the nearest representable value, the default mode.  It
     is best to use ‘FE_TONEAREST’ except when there is a special need
     for some other mode.


File: c,  Node: Invalid Optimizations,  Next: Exception Flags,  Prev: Special Float Values,  Up: Floating Point in Depth

28.4 Invalid Optimizations
==========================

Signed zeros, Infinity, and NaN invalidate some optimizations by
programmers and compilers that might otherwise have seemed obvious:

   • ‘x + 0’ and ‘x - 0’ are not the same as ‘x’ when ‘x’ is zero,
     because the result depends on the rounding rule.  *Note Rounding::,
     for more about rounding rules.

   • ‘x * 0.0’ is not the same as ‘0.0’ when ‘x’ is Infinity, a NaN, or
     negative zero.

   • ‘x / x’ is not the same as ‘1.0’ when ‘x’ is Infinity, a NaN, or
     zero.

   • ‘(x - y)’ is not the same as ‘-(y - x)’ because when the operands
     are finite and equal, one evaluates to ‘+0’ and the other to ‘-0’.

   • ‘x - x’ is not the same as ‘0.0’ when X is Infinity or a NaN.

   • ‘x == x’ and ‘x != x’ are not equivalent to ‘1’ and ‘0’ when X is a
     NaN.

   • ‘x < y’ and ‘isless (x, y)’ are not equivalent, because the first
     sets a sticky exception flag (*note Exception Flags::) when an
     operand is a NaN, whereas the second does not affect that flag.
     The same holds for the other ‘isxxx’ functions that are companions
     to relational operators.  *Note (libc)FP Comparison Functions::.

   The ‘-funsafe-math-optimizations’ option enables these optimizations.


File: c,  Node: Exception Flags,  Next: Exact Floating-Point,  Prev: Invalid Optimizations,  Up: Floating Point in Depth

28.5 Floating Arithmetic Exception Flags
========================================

“Sticky exception flags” record the occurrence of particular conditions:
once set, they remain set until the program explicitly clears them.

   The conditions include _invalid operand_, _division-by_zero_,
_inexact result_ (i.e., one that required rounding), _underflow_, and
_overflow_.  Some extended floating-point designs offer several
additional exception flags.  The functions ‘feclearexcept’,
‘feraiseexcept’, ‘fetestexcept’, ‘fegetexceptflags’, and
‘fesetexceptflags’ provide a standardized interface to those flags.
*Note (libc)Status bit operations::.

   One important use of those flags is to do a computation that is
normally expected to be exact in floating-point arithmetic, but
occasionally might not be, in which case, corrective action is needed.
You can clear the _inexact result_ flag with a call to ‘feclearexcept
(FE_INEXACT)’, do the computation, and then test the flag with
‘fetestexcept (FE_INEXACT)’; the result of that call is 0 if the flag is
not set (there was no rounding), and 1 when there was rounding (which,
we presume, implies the program has to correct for that).


File: c,  Node: Exact Floating-Point,  Next: Rounding,  Prev: Exception Flags,  Up: Floating Point in Depth

28.6 Exact Floating-Point Arithmetic
====================================

As long as the numbers are exactly representable (fractions whose
denominator is a power of 2), and intermediate results do not require
rounding, then floating-point arithmetic is _exact_.  It is easy to
predict how many digits are needed for the results of arithmetic
operations:

   • addition and subtraction of two N-digit values with the _same_
     exponent require at most ‘N + 1’ digits, but when the exponents
     differ, many more digits may be needed;

   • multiplication of two N-digit values requires exactly 2 N digits;

   • although integer division produces a quotient and a remainder of no
     more than N-digits, floating-point remainder and square root may
     require an unbounded number of digits, and the quotient can need
     many more digits than can be stored.

   Whenever a result requires more than N digits, rounding is needed.


File: c,  Node: Rounding,  Next: Rounding Issues,  Prev: Exact Floating-Point,  Up: Floating Point in Depth

28.7 Rounding
=============

When floating-point arithmetic produces a result that can’t fit exactly
in the significand of the type that’s in use, it has to “round” the
value.  The basic arithmetic operations—addition, subtraction,
multiplication, division, and square root—always produce a result that
is equivalent to the exact, possibly infinite-precision result rounded
to storage precision according to the current rounding rule.

   Rounding sets the ‘FE_INEXACT’ exception flag (*note Exception
Flags::).  This enables programs to determine that rounding has
occurred.

   Rounding consists of adjusting the exponent to bring the significand
back to the required base-point alignment, then applying the current
“rounding rule” to squeeze the significand into the fixed available
size.

   The current rule is selected at run time from four options.  Here
they are:

   * _round-to-nearest_, with ties rounded to an even integer;

   * _round-up_, towards ‘+Infinity’;

   * _round-down_, towards ‘-Infinity’;

   * _round-towards-zero_.

   Under those four rounding rules, a decimal value ‘-1.2345’ that is to
be rounded to a four-digit result would become ‘-1.234’, ‘-1.234’,
‘-1.235’, and ‘-1.234’, respectively.

   The default rounding rule is _round-to-nearest_, because that has the
least bias, and produces the lowest average error.  When the true result
lies exactly halfway between two representable machine numbers, the
result is rounded to the one that ends with an even digit.

   The _round-towards-zero_ rule was common on many early computer
designs, because it is the easiest to implement: it just requires silent
truncation of all extra bits.

   The two other rules, _round-up_ and _round-down_, are essential for
implementing “interval arithmetic”, whereby each arithmetic operation
produces lower and upper bounds that are guaranteed to enclose the exact
result.

   *Note Rounding Control::, for details on getting and setting the
current rounding mode.


File: c,  Node: Rounding Issues,  Next: Significance Loss,  Prev: Rounding,  Up: Floating Point in Depth

28.8 Rounding Issues
====================

The default IEEE 754 rounding mode minimizes errors, and most normal
computations should not suffer any serious accumulation of errors from
rounding.

   Of course, you can contrive examples where that is not so.  Here is
one: iterate a square root, then attempt to recover the original value
by repeated squaring.

     #include <stdio.h>
     #include <math.h>

     int main (void)
     {
       double x = 100.0;
       double y;
       for (n = 10; n <= 100; n += 10)
         {
           y = x;
           for (k = 0; k < n; ++k) y = sqrt (y);
           for (k = 0; k < n; ++k) y *= y;
           printf ("n = %3d; x = %.0f\ty = %.6f\n", n, x, y);
         }
       return 0;
     }

Here is the output:

     n =  10; x = 100        y = 100.000000
     n =  20; x = 100        y = 100.000000
     n =  30; x = 100        y = 99.999977
     n =  40; x = 100        y = 99.981025
     n =  50; x = 100        y = 90.017127
     n =  60; x = 100        y = 1.000000
     n =  70; x = 100        y = 1.000000
     n =  80; x = 100        y = 1.000000
     n =  90; x = 100        y = 1.000000
     n = 100; x = 100        y = 1.000000

   After 50 iterations, ‘y’ has barely one correct digit, and soon
after, there are no correct digits.


File: c,  Node: Significance Loss,  Next: Fused Multiply-Add,  Prev: Rounding Issues,  Up: Floating Point in Depth

28.9 Significance Loss
======================

A much more serious source of error in floating-point computation is
“significance loss” from subtraction of nearly equal values.  This means
that the number of bits in the significand of the result is fewer than
the size of the value would permit.  If the values being subtracted are
close enough, but still not equal, a _single subtraction_ can wipe out
all correct digits, possibly contaminating all future computations.

   Floating-point calculations can sometimes be carefully designed so
that significance loss is not possible, such as summing a series where
all terms have the same sign.  For example, the Taylor series expansions
of the trigonometric and hyperbolic sines have terms of identical
magnitude, of the general form ‘X**(2*N + 1) / (2*N + 1)!’.  However,
those in the trigonometric sine series alternate in sign, while those in
the hyperbolic sine series are all positive.  Here is the output of two
small programs that sum K terms of the series for ‘sin (X)’, and compare
the computed sums with known-to-be-accurate library functions:

     x = 10      k = 51
     s (x)   = -0.544_021_110_889_270
     sin (x) = -0.544_021_110_889_370

     x = 20      k = 81
     s (x)   = 0.912_945_250_749_573
     sin (x) = 0.912_945_250_727_628

     x = 30      k = 109
     s (x)   = -0.987_813_746_058_855
     sin (x) = -0.988_031_624_092_862

     x = 40      k = 137
     s (x)   = 0.617_400_430_980_474
     sin (x) = 0.745_113_160_479_349

     x = 50      k = 159
     s (x)   = 57_105.187_673_745_720_532
     sin (x) = -0.262_374_853_703_929

     // sinh(x) series summation with positive signs
     // with k terms needed to converge to machine precision

     x = 10      k = 47
     t (x)    = 1.101_323_287_470_340e+04
     sinh (x) = 1.101_323_287_470_339e+04

     x = 20      k = 69
     t (x)    = 2.425_825_977_048_951e+08
     sinh (x) = 2.425_825_977_048_951e+08

     x = 30      k = 87
     t (x)    = 5.343_237_290_762_229e+12
     sinh (x) = 5.343_237_290_762_231e+12

     x = 40      k = 105
     t (x)    = 1.176_926_334_185_100e+17
     sinh (x) = 1.176_926_334_185_100e+17

     x = 50      k = 121
     t (x)    = 2.592_352_764_293_534e+21
     sinh (x) = 2.592_352_764_293_536e+21

We have added underscores to the numbers to enhance readability.

   The ‘sinh (X)’ series with positive terms can be summed to high
accuracy.  By contrast, the series for ‘sin (X)’ suffers increasing
significance loss, so that when X = 30 only two correct digits remain.
Soon after, all digits are wrong, and the answers are complete nonsense.

   An important skill in numerical programming is to recognize when
significance loss is likely to contaminate a computation, and revise the
algorithm to reduce this problem.  Sometimes, the only practical way to
do so is to compute in higher intermediate precision, which is why the
extended types like ‘long double’ are important.


File: c,  Node: Fused Multiply-Add,  Next: Error Recovery,  Prev: Significance Loss,  Up: Floating Point in Depth

28.10 Fused Multiply-Add
========================

In 1990, when IBM introduced the POWER architecture, the CPU provided a
previously unknown instruction, the “fused multiply-add” (FMA). It
computes the value ‘x * y + z’ with an *exact* double-length product,
followed by an addition with a _single_ rounding.  Numerical computation
often needs pairs of multiply and add operations, for which the FMA is
well-suited.

   On the POWER architecture, there are two dedicated registers that
hold permanent values of ‘0.0’ and ‘1.0’, and the normal _multiply_ and
_add_ instructions are just wrappers around the FMA that compute ‘x * y
+ 0.0’ and ‘x * 1.0 + z’, respectively.

   In the early days, it appeared that the main benefit of the FMA was
getting two floating-point operations for the price of one, almost
doubling the performance of some algorithms.  However, numerical
analysts have since shown numerous uses of the FMA for significantly
enhancing accuracy.  We discuss one of the most important ones in the
next section.

   A few other architectures have since included the FMA, and most
provide variants for the related operations ‘x * y - z’ (FMS), ‘-x * y +
z’ (FNMA), and ‘-x * y - z’ (FNMS).

   The functions ‘fmaf’, ‘fma’, and ‘fmal’ implement fused multiply-add
for the ‘float’, ‘double’, and ‘long double’ data types.  Correct
implementation of the FMA in software is difficult, and some systems
that appear to provide those functions do not satisfy the
single-rounding requirement.  That situation should change as more
programmers use the FMA operation, and more CPUs provide FMA in
hardware.

   Use the ‘-ffp-contract=fast’ option to allow generation of FMA
instructions, or ‘-ffp-contract=off’ to disallow it.


File: c,  Node: Error Recovery,  Next: Exact Floating Constants,  Prev: Fused Multiply-Add,  Up: Floating Point in Depth

28.11 Error Recovery
====================

When two numbers are combined by one of the four basic operations, the
result often requires rounding to storage precision.  For accurate
computation, one would like to be able to recover that rounding error.
With historical floating-point designs, it was difficult to do so
portably, but now that IEEE 754 arithmetic is almost universal, the job
is much easier.

   For addition with the default _round-to-nearest_ rounding mode, we
can determine the error in a sum like this:

     volatile double err, sum, tmp, x, y;

     if (fabs (x) >= fabs (y))
       {
         sum = x + y;
         tmp = sum - x;
         err = y - tmp;
       }
     else /* fabs (x) < fabs (y) */
       {
         sum = x + y;
         tmp = sum - y;
         err = x - tmp;
       }

Now, ‘x + y’ is _exactly_ represented by ‘sum + err’.  This basic
operation, which has come to be called “twosum” in the
numerical-analysis literature, is the first key to tracking, and
accounting for, rounding error.

   To determine the error in subtraction, just swap the ‘+’ and ‘-’
operators.

   We used the ‘volatile’ qualifier (*note volatile::) in the
declaration of the variables, which forces the compiler to store and
retrieve them from memory, and prevents the compiler from optimizing
‘err = y - ((x + y) - x)’ into ‘err = 0’.

   For multiplication, we can compute the rounding error without
magnitude tests with the FMA operation (*note Fused Multiply-Add::),
like this:

     volatile double err, prod, x, y;
     prod = x * y;                /* rounded product */
     err  = fma (x, y, -prod);    /* exact product ‘= PROD + ERR’ */

   For addition, subtraction, and multiplication, we can represent the
exact result with the notional sum of two values.  However, the exact
result of division, remainder, or square root potentially requires an
infinite number of digits, so we can at best approximate it.
Nevertheless, we can compute an error term that is close to the true
error: it is just that error value, rounded to machine precision.

   For division, you can approximate ‘x / y’ with ‘quo + err’ like this:

     volatile double err, quo, x, y;
     quo = x / y;
     err = fma (-quo, y, x) / y;

   For square root, we can approximate ‘sqrt (x)’ with ‘root + err’ like
this:

     volatile double err, root, x;
     root = sqrt (x);
     err = fma (-root, root, x) / (root + root);

   With the reliable and predictable floating-point design provided by
IEEE 754 arithmetic, we now have the tools we need to track errors in
the five basic floating-point operations, and we can effectively
simulate computing in twice working precision, which is sometimes
sufficient to remove almost all traces of arithmetic errors.


File: c,  Node: Exact Floating Constants,  Next: Handling Infinity,  Prev: Error Recovery,  Up: Floating Point in Depth

28.12 Exact Floating-Point Constants
====================================

One of the frustrations that numerical programmers have suffered with
since the dawn of digital computers is the inability to precisely
specify numbers in their programs.  On the early decimal machines, that
was not an issue: you could write a constant ‘1e-30’ and be confident of
that exact value being used in floating-point operations.  However, when
the hardware works in a base other than 10, then human-specified numbers
have to be converted to that base, and then converted back again at
output time.  The two base conversions are rarely exact, and unwanted
rounding errors are introduced.

   As computers usually represent numbers in a base other than 10,
numbers often must be converted to and from different bases, and
rounding errors can occur during conversion.  This problem is solved in
C using hexademical floating-point constants.  For example,
‘+0x1.fffffcp-1’ is the number that is the IEEE 754 32-bit value closest
to, but below, ‘1.0’.  The significand is represented as a hexadecimal
fraction, and the _power of two_ is written in decimal following the
exponent letter ‘p’ (the traditional exponent letter ‘e’ is not
possible, because it is a hexadecimal digit).

   In ‘printf’ and ‘scanf’ and related functions, you can use the ‘%a’
and ‘%A’ format specifiers for writing and reading hexadecimal
floating-point values.  ‘%a’ writes them with lower case letters and
‘%A’ writes them with upper case letters.  For instance, this code
reproduces our sample number:

     printf ("%a\n", 1.0 - pow (2.0, -23));
         ⊣ 0x1.fffffcp-1

The ‘strtod’ family was similarly extended to recognize numbers in that
new format.

   If you want to ensure exact data representation for transfer of
floating-point numbers between C programs on different computers, then
hexadecimal constants are an optimum choice.


File: c,  Node: Handling Infinity,  Next: Handling NaN,  Prev: Exact Floating Constants,  Up: Floating Point in Depth

28.13 Handling Infinity
=======================

As we noted earlier, the IEEE 754 model of computing is not to stop the
program when exceptional conditions occur.  It takes note of exceptional
values or conditions by setting sticky “exception flags”, or by
producing results with the special values Infinity and QNaN. In this
section, we discuss Infinity; *note Handling NaN:: for the other.

   In GNU C, you can create a value of negative Infinity in software
like this:

double x;

x = -1.0 / 0.0;

   GNU C supplies the ‘__builtin_inf’, ‘__builtin_inff’, and
‘__builtin_infl’ macros, and the GNU C Library provides the ‘INFINITY’
macro, all of which are compile-time constants for positive infinity.

   GNU C also provides a standard function to test for an Infinity:
‘isinf (x)’ returns ‘1’ if the argument is a signed infinity, and ‘0’ if
not.

   Infinities can be compared, and all Infinities of the same sign are
equal: there is no notion in IEEE 754 arithmetic of different kinds of
Infinities, as there are in some areas of mathematics.  Positive
Infinity is larger than any finite value, and negative Infinity is
smaller than finite value.

   Infinities propagate in addition, subtraction, multiplication, and
square root, but in division, they disappear, because of the rule that
‘finite / Infinity’ is ‘0.0’.  Thus, an overflow in an intermediate
computation that produces an Infinity is likely to be noticed later in
the final results.  The programmer can then decide whether the overflow
is expected, and acceptable, or whether the code possibly has a bug, or
needs to be run in higher precision, or redesigned to avoid the
production of the Infinity.


File: c,  Node: Handling NaN,  Next: Signed Zeros,  Prev: Handling Infinity,  Up: Floating Point in Depth

28.14 Handling NaN
==================

NaNs are not numbers: they represent values from computations that
produce undefined results.  They have a distinctive property that makes
them unlike any other floating-point value: they are _unequal to
everything, including themselves_!  Thus, you can write a test for a NaN
like this:

     if (x != x)
       printf ("x is a NaN\n");

This test works in GNU C, but some compilers might evaluate that test
expression as false without properly checking for the NaN value.  A more
portable way to test for NaN is to use the ‘isnan’ function declared in
‘math.h’:

     if (isnan (x))
       printf ("x is a NaN\n");

*Note (libc)Floating Point Classes::.

   One important use of NaNs is marking of missing data.  For example,
in statistics, such data must be omitted from computations.  Use of any
particular finite value for missing data would eventually collide with
real data, whereas such data could never be a NaN, so it is an ideal
marker.  Functions that deal with collections of data that may have
holes can be written to test for, and ignore, NaN values.

   It is easy to generate a NaN in computations: evaluating ‘0.0 / 0.0’
is the commonest way, but ‘Infinity - Infinity’, ‘Infinity / Infinity’,
and ‘sqrt (-1.0)’ also work.  Functions that receive out-of-bounds
arguments can choose to return a stored NaN value, such as with the
‘NAN’ macro defined in ‘math.h’, but that does not set the _invalid
operand_ exception flag, and that can fool some programs.

   Like Infinity, NaNs propagate in computations, but they are even
stickier, because they never disappear in division.  Thus, once a NaN
appears in a chain of numerical operations, it is almost certain to pop
out into the final results.  The programmer has to decide whether that
is expected, or whether there is a coding or algorithmic error that
needs repair.

   In general, when function gets a NaN argument, it usually returns a
NaN. However, there are some exceptions in the math-library functions
that you need to be aware of, because they violate the
_NaNs-always-propagate_ rule:

   • ‘pow (x, 0.0)’ always returns ‘1.0’, even if ‘x’ is 0.0, Infinity,
     or a NaN.

   • ‘pow (1, y)’ always returns ‘1’, even if ‘y’ is a NaN.

   • ‘hypot (INFINITY, y)’ and ‘hypot (-INFINITY, y)’ both always return
     ‘INFINITY’, even if ‘y’ is a Nan.

   • If just one of the arguments to ‘fmax (x, y)’ or ‘fmin (x, y)’ is a
     NaN, it returns the other argument.  If both arguments are NaNs, it
     returns a NaN, but there is no requirement about where it comes
     from: it could be ‘x’, or ‘y’, or some other quiet NaN.

   NaNs are also used for the return values of math-library functions
where the result is not representable in real arithmetic, or is
mathematically undefined or uncertain, such as ‘sqrt (-1.0)’ and ‘sin
(Infinity)’.  However, note that a result that is merely too big to
represent should always produce an Infinity, such as with ‘exp (1000.0)’
(too big) and ‘exp (Infinity)’ (truly infinite).


File: c,  Node: Signed Zeros,  Next: Scaling by the Base,  Prev: Handling NaN,  Up: Floating Point in Depth

28.15 Signed Zeros
==================

The sign of zero is significant, and important, because it records the
creation of a value that is too small to represent, but came from either
the negative axis, or from the positive axis.  Such fine distinctions
are essential for proper handling of “branch cuts” in complex arithmetic
(*note Complex Arithmetic::).

   The key point about signed zeros is that in comparisons, their sign
does not matter: ‘0.0 == -0.0’ must _always_ evaluate to ‘1’ (true).
However, they are not _the same number_, and ‘-0.0’ in C code stands for
a negative zero.


File: c,  Node: Scaling by the Base,  Next: Rounding Control,  Prev: Signed Zeros,  Up: Floating Point in Depth

28.16 Scaling by Powers of the Base
===================================

We have discussed rounding errors several times in this chapter, but it
is important to remember that when results require no more bits than the
exponent and significand bits can represent, those results are _exact_.

   One particularly useful exact operation is scaling by a power of the
base.  While one, in principle, could do that with code like this:

     y = x * pow (2.0, (double)k);   /* Undesirable scaling: avoid! */

that is not advisable, because it relies on the quality of the
math-library power function, and that happens to be one of the most
difficult functions in the C math library to make accurate.  What is
likely to happen on many systems is that the returned value from ‘pow’
will be close to a power of two, but slightly different, so the
subsequent multiplication introduces rounding error.

   The correct, and fastest, way to do the scaling is either via the
traditional C library function, or with its C99 equivalent:

     y = ldexp (x, k);            /* Traditional pre-C99 style. */
     y = scalbn (x, k);           /* C99 style. */

Both functions return ‘x * 2**k’.  *Note (libc)Normalization
Functions::.


File: c,  Node: Rounding Control,  Next: Machine Epsilon,  Prev: Scaling by the Base,  Up: Floating Point in Depth

28.17 Rounding Control
======================

Here we describe how to specify the rounding mode at run time.  System
header file ‘fenv.h’ provides the prototypes for these functions.  *Note
(libc)Rounding::.

That header file also provides constant names for the four rounding
modes: ‘FE_DOWNWARD’, ‘FE_TONEAREST’, ‘FE_TOWARDZERO’, and ‘FE_UPWARD’.

   The function ‘fegetround’ examines and returns the current rounding
mode.  On a platform with IEEE 754 floating point, the value will always
equal one of those four constants.  On other platforms, it may return a
negative value.  The function ‘fesetround’ sets the current rounding
mode.

   Changing the rounding mode can be slow, so it is useful to minimize
the number of changes.  For interval arithmetic, we seem to need three
changes for each operation, but we really only need two, because we can
write code like this example for interval addition of two reals:

     {
       struct interval_double
         {
           double hi, lo;
         } v;
       volatile double x, y;
       int rule;

       rule = fegetround ();

       if (fesetround (FE_UPWARD) == 0)
         {
           v.hi = x + y;
           v.lo = -(-x - y);
         }
       else
         fatal ("ERROR: failed to change rounding rule");

       if (fesetround (rule) != 0)
         fatal ("ERROR: failed to restore rounding rule");
     }

The ‘volatile’ qualifier (*note volatile::) is essential on x86
platforms to prevent an optimizing compiler from producing the same
value for both bounds.


File: c,  Node: Machine Epsilon,  Next: Complex Arithmetic,  Prev: Rounding Control,  Up: Floating Point in Depth

28.18 Machine Epsilon
=====================

In any floating-point system, three attributes are particularly
important to know: “base” (the number that the exponent specifies a
power of), “precision” (number of digits in the significand), and
“range” (difference between most positive and most negative values).
The allocation of bits between exponent and significand decides the
answers to those questions.

   A measure of the precision is the answer to the question: what is the
smallest number that can be added to ‘1.0’ such that the sum differs
from ‘1.0’?  That number is called the “machine epsilon”.

   We could define the needed machine-epsilon constants for ‘float’,
‘double’, and ‘long double’ like this:

     static const float  epsf = 0x1p-23;  /* about 1.192e-07 */
     static const double eps  = 0x1p-52;  /* about 2.220e-16 */
     static const long double epsl = 0x1p-63;  /* about 1.084e-19 */

Instead of the hexadecimal constants, we could also have used the
Standard C macros, ‘FLT_EPSILON’, ‘DBL_EPSILON’, and ‘LDBL_EPSILON’.

   It is useful to be able to compute the machine epsilons at run time,
and we can easily generalize the operation by replacing the constant
‘1.0’ with a user-supplied value:

     double
     macheps (double x)
     { /* Return machine epsilon for X,  */
           such that X + macheps (X) > X.  */
       static const double base = 2.0;
       double eps;

       if (isnan (x))
           eps = x;
       else
         {
           eps = (x == 0.0) ? 1.0 : x;

           while ((x + eps / base) != x)
               eps /= base;          /* Always exact!  */
         }

       return (eps);
     }

If we call that function with arguments from ‘0’ to ‘10’, as well as
Infinity and NaN, and print the returned values in hexadecimal, we get
output like this:

     macheps (  0) = 0x1.0000000000000p-1074
     macheps (  1) = 0x1.0000000000000p-52
     macheps (  2) = 0x1.0000000000000p-51
     macheps (  3) = 0x1.8000000000000p-52
     macheps (  4) = 0x1.0000000000000p-50
     macheps (  5) = 0x1.4000000000000p-51
     macheps (  6) = 0x1.8000000000000p-51
     macheps (  7) = 0x1.c000000000000p-51
     macheps (  8) = 0x1.0000000000000p-49
     macheps (  9) = 0x1.2000000000000p-50
     macheps ( 10) = 0x1.4000000000000p-50
     macheps (Inf) = infinity
     macheps (NaN) = nan

Notice that ‘macheps’ has a special test for a NaN to prevent an
infinite loop.

   Our code made another test for a zero argument to avoid getting a
zero return.  The returned value in that case is the smallest
representable floating-point number, here the subnormal value
‘2**(-1074)’, which is about ‘4.941e-324’.

   No special test is needed for an Infinity, because the
‘eps’-reduction loop then terminates at the first iteration.

   Our ‘macheps’ function here assumes binary floating point; some
architectures may differ.

   The C library includes some related functions that can also be used
to determine machine epsilons at run time:

     #include <math.h>           /* Include for these prototypes. */

     double      nextafter  (double x, double y);
     float       nextafterf (float x, float y);
     long double nextafterl (long double x, long double y);

These return the machine number nearest X in the direction of Y.  For
example, ‘nextafter (1.0, 2.0)’ produces the same result as ‘1.0 +
macheps (1.0)’ and ‘1.0 + DBL_EPSILON’.  *Note (libc)FP Bit Twiddling::.

   It is important to know that the machine epsilon is not symmetric
about all numbers.  At the boundaries where normalization changes the
exponent, the epsilon below X is smaller than that just above X by a
factor ‘1 / base’.  For example, ‘macheps (1.0)’ returns ‘+0x1p-52’,
whereas ‘macheps (-1.0)’ returns ‘+0x1p-53’.  Some authors distinguish
those cases by calling them the _positive_ and _negative_, or _big_ and
_small_, machine epsilons.  You can produce their values like this:

     eps_neg = 1.0 - nextafter (1.0, -1.0);
     eps_pos = nextafter (1.0, +2.0) - 1.0;

   If X is a variable, such that you do not know its value at compile
time, then you can substitute literal Y values with either ‘-inf()’ or
‘+inf()’, like this:

     eps_neg = x - nextafter (x, -inf ());
     eps_pos = nextafter (x, +inf() - x);

In such cases, if X is Infinity, then _the ‘nextafter’ functions return
Y if X equals Y_.  Our two assignments then produce
‘+0x1.fffffffffffffp+1023’ (about 1.798e+308) for EPS_NEG and Infinity
for EPS_POS.  Thus, the call ‘nextafter (INFINITY, -INFINITY)’ can be
used to find the largest representable finite number, and with the call
‘nextafter (0.0, 1.0)’, the smallest representable number (here,
‘0x1p-1074’ (about 4.491e-324), a number that we saw before as the
output from ‘macheps (0.0)’).


File: c,  Node: Complex Arithmetic,  Next: Round-Trip Base Conversion,  Prev: Machine Epsilon,  Up: Floating Point in Depth

28.19 Complex Arithmetic
========================

We’ve already looked at defining and referring to complex numbers (*note
Complex Data Types::).  What is important to discuss here are some
issues that are unlikely to be obvious to programmers without extensive
experience in both numerical computing, and in complex arithmetic in
mathematics.

   The first important point is that, unlike real arithmetic, in complex
arithmetic, the danger of significance loss is _pervasive_, and affects
_every one_ of the basic operations, and _almost all_ of the
math-library functions.  To understand why, recall the rules for complex
multiplication and division:

     a = u + I*v              /* First operand. */
     b = x + I*y              /* Second operand. */

     prod = a * b
          = (u + I*v) * (x + I*y)
          = (u * x - v * y) + I*(v * x + u * y)

     quo  = a / b
          = (u + I*v) / (x + I*y)
          = [(u + I*v) * (x - I*y)] / [(x + I*y) * (x - I*y)]
          = [(u * x + v * y) + I*(v * x - u * y)] / (x**2 + y**2)

There are four critical observations about those formulas:

   • the multiplications on the right-hand side introduce the
     possibility of premature underflow or overflow;

   • the products must be accurate to twice working precision;

   • there is _always_ one subtraction on the right-hand sides that is
     subject to catastrophic significance loss; and

   • complex multiplication has up to _six_ rounding errors, and complex
     division has _ten_ rounding errors.

   Another point that needs careful study is the fact that many
functions in complex arithmetic have “branch cuts”.  You can view a
function with a complex argument, ‘f (z)’, as ‘f (x + I*y)’, and thus,
it defines a relation between a point ‘(x, y)’ on the complex plane with
an elevation value on a surface.  A branch cut looks like a tear in that
surface, so approaching the cut from one side produces a particular
value, and from the other side, a quite different value.  Great care is
needed to handle branch cuts properly, and even small numerical errors
can push a result from one side to the other, radically changing the
returned value.  As we reported earlier, correct handling of the sign of
zero is critically important for computing near branch cuts.

   The best advice that we can give to programmers who need complex
arithmetic is to always use the _highest precision available_, and then
to carefully check the results of test calculations to gauge the likely
accuracy of the computed results.  It is easy to supply test values of
real and imaginary parts where all five basic operations in complex
arithmetic, and almost all of the complex math functions, lose _all_
significance, and fail to produce even a single correct digit.

   Even though complex arithmetic makes some programming tasks easier,
it may be numerically preferable to rework the algorithm so that it can
be carried out in real arithmetic.  That is commonly possible in matrix
algebra.

   GNU C can perform code optimization on complex number multiplication
and division if certain boundary checks will not be needed.  The
command-line option ‘-fcx-limited-range’ tells the compiler that a range
reduction step is not needed when performing complex division, and that
there is no need to check if a complex multiplication or division
results in the value ‘Nan + I*NaN’.  By default these checks are
enabled.  You can explicitly enable them with the
‘-fno-cx-limited-range’ option.


File: c,  Node: Round-Trip Base Conversion,  Next: Further Reading,  Prev: Complex Arithmetic,  Up: Floating Point in Depth

28.20 Round-Trip Base Conversion
================================

Most numeric programs involve converting between base-2 floating-point
numbers, as represented by the computer, and base-10 floating-point
numbers, as entered and handled by the programmer.  What might not be
obvious is the number of base-2 bits vs.  base-10 digits required for
each representation.  Consider the following tables showing the number
of decimal digits representable in a given number of bits, and vice
versa:

binary in                            24      53      64      113     237
decimal out                          9       17      21      36      73

decimal in                           7       16      34      70
binary out                           25      55      114     234

   We can compute the table numbers with these two functions:

     int
     matula(int nbits)
     {   /* Return output decimal digits needed for nbits-bits input. */
         return ((int)ceil((double)nbits / log2(10.0) + 1.0));
     }

     int
     goldberg(int ndec)
     {   /* Return output bits needed for ndec-digits input. */
         return ((int)ceil((double)ndec / log10(2.0) + 1.0));
     }

   One significant observation from those numbers is that we cannot
achieve correct round-trip conversion between the decimal and binary
formats in the same storage size!  For example, we need 25 bits to
represent a 7-digit value from the 32-bit decimal format, but the binary
format only has 24 available.  Similar observations hold for each of the
other conversion pairs.

   The general input/output base-conversion problem is astonishingly
complicated, and solutions were not generally known until the
publication of two papers in 1990 that are listed later near the end of
this chapter.  For the 128-bit formats, the worst case needs more than
11,500 decimal digits of precision to guarantee correct rounding in a
binary-to-decimal conversion!

   For further details see the references for Bennett Goldberg and David
Matula.


File: c,  Node: Further Reading,  Prev: Round-Trip Base Conversion,  Up: Floating Point in Depth

28.21 Further Reading
=====================

The subject of floating-point arithmetic is much more complex than many
programmers seem to think, and few books on programming languages spend
much time in that area.  In this chapter, we have tried to expose the
reader to some of the key ideas, and to warn of easily overlooked
pitfalls that can soon lead to nonsensical results.  There are a few
good references that we recommend for further reading, and for finding
other important material about computer arithmetic:

   • Paul H. Abbott and 15 others, ‘Architecture and software support in
     IBM S/390 Parallel Enterprise Servers for IEEE Floating-Point
     arithmetic’, IBM Journal of Research and Development 43(5/6)
     723–760 (1999), <https://doi.org/10.1147/rd.435.0723>.  This
     article gives a good description of IBM’s algorithm for exact
     decimal-to-binary conversion, complementing earlier ones by Clinger
     and others.

   • Nelson H. F. Beebe, ‘The Mathematical-Function Computation
     Handbook: Programming Using the MathCW Portable Software Library’,
     Springer (2017), ISBN 3-319-64109-3 (hardcover), 3-319-64110-7
     (e-book) (xxxvi + 1114 pages),
     <https://doi.org/10.1007/978-3-319-64110-2>.  This book describes
     portable implementations of a large superset of the mathematical
     functions available in many programming languages, extended to a
     future 256-bit format (70 decimal digits), for both binary and
     decimal floating point.  It includes a substantial portion of the
     functions described in the famous ‘NIST Handbook of Mathematical
     Functions’, Cambridge (2018), ISBN 0-521-19225-0.  See
     <http://www.math.utah.edu/pub/mathcw> for compilers and libraries.

   • William D. Clinger, ‘How to Read Floating Point Numbers
     Accurately’, ACM SIGPLAN Notices 25(6) 92–101 (June 1990),
     <https://doi.org/10.1145/93548.93557>.  See also the papers by
     Steele & White.

   • William D. Clinger, ‘Retrospective: How to read floating point
     numbers accurately’, ACM SIGPLAN Notices 39(4) 360–371 (April
     2004), <http://doi.acm.org/10.1145/989393.989430>.  Reprint of 1990
     paper, with additional commentary.

   • I. Bennett Goldberg, ‘27 Bits Are Not Enough For 8-Digit Accuracy’,
     Communications of the ACM 10(2) 105–106 (February 1967),
     <http://doi.acm.org/10.1145/363067.363112>.  This paper, and its
     companions by David Matula, address the base-conversion problem,
     and show that the naive formulas are wrong by one or two digits.

   • David Goldberg, ‘What Every Computer Scientist Should Know About
     Floating-Point Arithmetic’, ACM Computing Surveys 23(1) 5–58 (March
     1991), corrigendum 23(3) 413 (September 1991),
     <https://doi.org/10.1145/103162.103163>.  This paper has been
     widely distributed, and reissued in vendor programming-language
     documentation.  It is well worth reading, and then rereading from
     time to time.

   • Norbert Juffa and Nelson H. F. Beebe, ‘A Bibliography of
     Publications on Floating-Point Arithmetic’,
     <http://www.math.utah.edu/pub/tex/bib/fparith.bib>.  This is the
     largest known bibliography of publications about floating-point,
     and also integer, arithmetic.  It is actively maintained, and in
     mid 2019, contains more than 6400 references to original research
     papers, reports, theses, books, and Web sites on the subject
     matter.  It can be used to locate the latest research in the field,
     and the historical coverage dates back to a 1726 paper on
     signed-digit arithmetic, and an 1837 paper by Charles Babbage, the
     intellectual father of mechanical computers.  The entries for the
     Abbott, Clinger, and Steele & White papers cited earlier contain
     pointers to several other important related papers on the
     base-conversion problem.

   • William Kahan, ‘Branch Cuts for Complex Elementary Functions, or
     Much Ado About Nothing’s Sign Bit’, (1987),
     <http://people.freebsd.org/~das/kahan86branch.pdf>.  This Web
     document about the fine points of complex arithmetic also appears
     in the volume edited by A. Iserles and M. J. D. Powell, ‘The State
     of the Art in Numerical Analysis: Proceedings of the Joint IMA/SIAM
     Conference on the State of the Art in Numerical Analysis held at
     the University of Birmingham, 14–18 April 1986’, Oxford University
     Press (1987), ISBN 0-19-853614-3 (xiv + 719 pages).  Its author is
     the famous chief architect of the IEEE 754 arithmetic system, and
     one of the world’s greatest experts in the field of floating-point
     arithmetic.  An entire generation of his students at the University
     of California, Berkeley, have gone on to careers in academic and
     industry, spreading the knowledge of how to do floating-point
     arithmetic right.

   • Donald E. Knuth, ‘A Simple Program Whose Proof Isn’t’, in ‘Beauty
     is our business: a birthday salute to Edsger W. Dijkstra’, W. H. J.
     Feijen, A. J. M. van Gasteren, D. Gries, and J. Misra (eds.),
     Springer (1990), ISBN 1-4612-8792-8,
     <https://doi.org/10.1007/978-1-4612-4476-9>.  This book chapter
     supplies a correctness proof of the decimal to binary, and binary
     to decimal, conversions in fixed-point arithmetic in the TeX
     typesetting system.  The proof evaded its author for a dozen years.

   • David W. Matula, ‘In-and-out conversions’, Communications of the
     ACM 11(1) 57–50 (January 1968),
     <https://doi.org/10.1145/362851.362887>.

   • David W. Matula, ‘The Base Conversion Theorem’, Proceedings of the
     American Mathematical Society 19(3) 716–723 (June 1968).  See also
     other papers here by this author, and by I. Bennett Goldberg.

   • David W. Matula, ‘A Formalization of Floating-Point Numeric Base
     Conversion’, IEEE Transactions on Computers C-19(8) 681–692 (August
     1970), <https://doi.org/10.1109/T-C.1970.223017>.

   • Jean-Michel Muller and eight others, ‘Handbook of Floating-Point
     Arithmetic’, Birkhäuser-Boston (2010), ISBN 0-8176-4704-X (xxiii +
     572 pages), <https://doi.org/10.1007/978-0-8176-4704-9>.  This is a
     comprehensive treatise from a French team who are among the world’s
     greatest experts in floating-point arithmetic, and among the most
     prolific writers of research papers in that field.  They have much
     to teach, and their book deserves a place on the shelves of every
     serious numerical programmer.

   • Jean-Michel Muller and eight others, ‘Handbook of Floating-Point
     Arithmetic’, Second edition, Birkhäuser-Boston (2018), ISBN
     3-319-76525-6 (xxv + 627 pages),
     <https://doi.org/10.1007/978-3-319-76526-6>.  This is a new edition
     of the preceding entry.

   • Michael Overton, ‘Numerical Computing with IEEE Floating Point
     Arithmetic, Including One Theorem, One Rule of Thumb, and One
     Hundred and One Exercises’, SIAM (2001), ISBN 0-89871-482-6 (xiv +
     104 pages), <http://www.ec-securehost.com/SIAM/ot76.html>.  This is
     a small volume that can be covered in a few hours.

   • Guy L. Steele Jr.  and Jon L. White, ‘How to Print Floating-Point
     Numbers Accurately’, ACM SIGPLAN Notices 25(6) 112–126 (June 1990),
     <https://doi.org/10.1145/93548.93559>.  See also the papers by
     Clinger.

   • Guy L. Steele Jr.  and Jon L. White, ‘Retrospective: How to Print
     Floating-Point Numbers Accurately’, ACM SIGPLAN Notices 39(4)
     372–389 (April 2004), <http://doi.acm.org/10.1145/989393.989431>.
     Reprint of 1990 paper, with additional commentary.

   • Pat H. Sterbenz, ‘Floating Point Computation’, Prentice-Hall
     (1974), ISBN 0-13-322495-3 (xiv + 316 pages).  This often-cited
     book provides solid coverage of what floating-point arithmetic was
     like _before_ the introduction of IEEE 754 arithmetic.


File: c,  Node: Compilation,  Next: Directing Compilation,  Prev: Floating Point in Depth,  Up: Top

29 Compilation
**************

Early in the manual we explained how to compile a simple C program that
consists of a single source file (*note Compile Example::).  However, we
handle only short programs that way.  A typical C program consists of
many source files, each of which is a separate “compilation
module”—meaning that it has to be compiled separately.

   The full details of how to compile with GCC are documented in xxxx.
Here we give only a simple introduction.

   These are the commands to compile two compilation modules, ‘foo.c’
and ‘bar.c’, with a command for each module:

     gcc -c -O -g foo.c
     gcc -c -O -g bar.c

In these commands, ‘-g’ says to generate debugging information, ‘-O’
says to do some optimization, and ‘-c’ says to put the compiled code for
that module into a corresponding “object file” and go no further.  The
object file for ‘foo.c’ is called ‘foo.o’, and so on.

   If you wish, you can specify the additional options ‘-Wformat
-Wparenthesis -Wstrict-prototypes’, which request additional warnings.

   One reason to divide a large program into multiple compilation
modules is to control how each module can access the internals of the
others.  When a module declares a function or variable ‘extern’, other
modules can access it.  The other functions and variables in a module
can’t be accessed from outside that module.

   The other reason for using multiple modules is so that changing one
source file does not require recompiling all of them in order to try the
modified program.  Dividing a large program into many substantial
modules in this way typically makes recompilation much faster.

   After you compile all the program’s modules, in order to run the
program you must “link” the object files into a combined executable,
like this:

     gcc -o foo foo.o bar.o

In this command, ‘-o foo’ species the file name for the executable file,
and the other arguments are the object files to link.  Always specify
the executable file name in a command that generates one.

   Normally we don’t run any of these commands directly.  Instead we
write a set of “make rules” for the program, then use the ‘make’ program
to recompile only the source files that need to be recompiled.


File: c,  Node: Directing Compilation,  Next: Type Alignment,  Prev: Compilation,  Up: Top

30 Directing Compilation
************************

This chapter describes C constructs that don’t alter the program’s
meaning _as such_, but rather direct the compiler how to treat some
aspects of the program.

* Menu:

* Pragmas::                      Controling compilation of some constructs.
* Static Assertions::            Compile-time tests for conditions.


File: c,  Node: Pragmas,  Next: Static Assertions,  Up: Directing Compilation

30.1 Pragmas
============

A “pragma” is an annotation in a program that gives direction to the
compiler.

* Menu:

* Pragma Basics::         Pragma syntax and usage.
* Severity Pragmas::      Settings for compile-time pragma output.
* Optimization Pragmas::  Controlling optimizations.


File: c,  Node: Pragma Basics,  Next: Severity Pragmas,  Up: Pragmas

30.1.1 Pragma Basics
--------------------

C defines two syntactical forms for pragmas, the line form and the token
form.  You can write any pragma in either form, with the same meaning.

   The line form is a line in the source code, like this:

     #pragma LINE

The line pragma has no effect on the parsing of the lines around it.
This form has the drawback that it can’t be generated by a macro
expansion.

   The token form is a series of tokens; it can appear anywhere in the
program between the other tokens.

     _Pragma (STRINGCONSTANT)

The pragma has no effect on the syntax of the tokens that surround it;
thus, here’s a pragma in the middle of an ‘if’ statement:

     if _Pragma ("hello") (x > 1)

However, that’s an unclear thing to do; for the sake of
understandability, it is better to put a pragma on a line by itself and
not embedded in the middle of another construct.

   Both forms of pragma have a textual argument.  In a line pragma, the
text is the rest of the line.  The textual argument to ‘_Pragma’ uses
the same syntax as a C string constant: surround the text with two ‘"’
characters, and add a backslash before each ‘"’ or ‘\’ character in it.

   With either syntax, the textual argument specifies what to do.  It
begins with one or several words that specify the operation.  If the
compiler does not recognize them, it ignores the pragma.

   Here are the pragma operations supported in GNU C.

‘#pragma GCC dependency "FILE" [MESSAGE]’
‘_Pragma ("GCC dependency \"FILE\" [MESSAGE]")’
     Declares that the current source file depends on FILE, so GNU C
     compares the file times and gives a warning if FILE is newer than
     the current source file.

     This directive searches for FILE the way ‘#include’ searches for a
     non-system header file.

     If MESSAGE is given, the warning message includes that text.

     Examples:

          #pragma GCC dependency "parse.y"
          _pragma ("GCC dependency \"/usr/include/time.h\" \
          rerun fixincludes")

‘#pragma GCC poison IDENTIFIERS’
‘_Pragma ("GCC poison IDENTIFIERS")’
     Poisons the identifiers listed in IDENTIFIERS.

     This is useful to make sure all mention of IDENTIFIERS has been
     deleted from the program and that no reference to them creeps back
     in.  If any of those identifiers appears anywhere in the source
     after the directive, it causes a compilation error.  For example,

          #pragma GCC poison printf sprintf fprintf
          sprintf(some_string, "hello");

     generates an error.

     If a poisoned identifier appears as part of the expansion of a
     macro that was defined before the identifier was poisoned, it will
     _not_ cause an error.  Thus, system headers that define macros that
     use the identifier will not cause errors.

     For example,

          #define strrchr rindex
          _Pragma ("GCC poison rindex")
          strrchr(some_string, 'h');

     does not cause a compilation error.

‘#pragma GCC system_header’
‘_Pragma ("GCC system_header")’
     Specify treating the rest of the current source file as if it came
     from a system header file.  *Note System Headers: (gcc)System
     Headers.

‘#pragma GCC warning MESSAGE’
‘_Pragma ("GCC warning MESSAGE")’
     Equivalent to ‘#warning’.  Its advantage is that the ‘_Pragma’ form
     can be included in a macro definition.

‘#pragma GCC error MESSAGE’
‘_Pragma ("GCC error MESSAGE")’
     Equivalent to ‘#error’.  Its advantage is that the ‘_Pragma’ form
     can be included in a macro definition.

‘#pragma GCC message MESSAGE’
‘_Pragma ("GCC message MESSAGE")’
     Similar to ‘GCC warning’ and ‘GCC error’, this simply prints an
     informational message, and could be used to include additional
     warning or error text without triggering more warnings or errors.
     (Note that unlike ‘warning’ and ‘error’, ‘message’ does not include
     ‘GCC’ as part of the pragma.)


File: c,  Node: Severity Pragmas,  Next: Optimization Pragmas,  Prev: Pragma Basics,  Up: Pragmas

30.1.2 Severity Pragmas
-----------------------

These pragmas control the severity of classes of diagnostics.  You can
specify the class of diagnostic with the GCC option that causes those
diagnostics to be generated.

‘#pragma GCC diagnostic error OPTION’
‘_Pragma ("GCC diagnostic error OPTION")’
     For code following this pragma, treat diagnostics of the variety
     specified by OPTION as errors.  For example:

          _Pragma ("GCC diagnostic error -Wformat")

     specifies to treat diagnostics enabled by the -WFORMAT option as
     errors rather than warnings.

‘#pragma GCC diagnostic warning OPTION’
‘_Pragma ("GCC diagnostic warning OPTION")’
     For code following this pragma, treat diagnostics of the variety
     specified by OPTION as warnings.  This overrides the -WERROR option
     which says to treat warnings as errors.

‘#pragma GCC diagnostic ignore OPTION’
‘_Pragma ("GCC diagnostic ignore OPTION")’
     For code following this pragma, refrain from reporting any
     diagnostics of the variety specified by OPTION.

‘#pragma GCC diagnostic push’
‘_Pragma ("GCC diagnostic push")’
‘#pragma GCC diagnostic pop’
‘_Pragma ("GCC diagnostic pop")’
     These pragmas maintain a stack of states for severity settings.
     ‘GCC diagnostic push’ saves the current settings on the stack, and
     ‘GCC diagnostic pop’ pops the last stack item and restores the
     current settings from that.

     ‘GCC diagnostic pop’ when the severity setting stack is empty
     restores the settings to what they were at the start of
     compilation.

     Here is an example:

          _Pragma ("GCC diagnostic error -Wformat")

          /* ‘-Wformat’ messages treated as errors.  */

          _Pragma ("GCC diagnostic push")
          _Pragma ("GCC diagnostic warning -Wformat")

          /* ‘-Wformat’ messages treated as warnings.  */

          _Pragma ("GCC diagnostic push")
          _Pragma ("GCC diagnostic ignored -Wformat")

          /* ‘-Wformat’ messages suppressed.  */

          _Pragma ("GCC diagnostic pop")

          /* ‘-Wformat’ messages treated as warnings again.  */

          _Pragma ("GCC diagnostic pop")

          /* ‘-Wformat’ messages treated as errors again.  */

          /* This is an excess ‘pop’ that matches no ‘push’.  */
          _Pragma ("GCC diagnostic pop")

          /* ‘-Wformat’ messages treated once again
             as specified by the GCC command-line options.  */


File: c,  Node: Optimization Pragmas,  Prev: Severity Pragmas,  Up: Pragmas

30.1.3 Optimization Pragmas
---------------------------

These pragmas enable a particular optimization for specific function
definitions.  The settings take effect at the end of a function
definition, so the clean place to use these pragmas is between function
definitions.

‘#pragma GCC optimize OPTIMIZATION’
‘_Pragma ("GCC optimize OPTIMIZATION")’
     These pragmas enable the optimization OPTIMIZATION for the
     following functions.  For example,

          _Pragma ("GCC optimize -fforward-propagate")

     says to apply the ‘forward-propagate’ optimization to all following
     function definitions.  Specifying optimizations for individual
     functions, rather than for the entire program, is rare but can be
     useful for getting around a bug in the compiler.

     If OPTIMIZATION does not correspond to a defined optimization
     option, the pragma is erroneous.  To turn off an optimization, use
     the corresponding ‘-fno-’ option, such as ‘-fno-forward-propagate’.

‘#pragma GCC target OPTIMIZATIONS’
‘_Pragma ("GCC target OPTIMIZATIONS")’
     The pragma ‘GCC target’ is similar to ‘GCC optimize’ but is used
     for platform-specific optimizations.  Thus,

          _Pragma ("GCC target popcnt")

     activates the optimization ‘popcnt’ for all following function
     definitions.  This optimization is supported on a few common
     targets but not on others.

‘#pragma GCC push_options’
‘_Pragma ("GCC push_options")’
     The ‘push_options’ pragma saves on a stack the current settings
     specified with the ‘target’ and ‘optimize’ pragmas.

‘#pragma GCC pop_options’
‘_Pragma ("GCC pop_options")’
     The ‘pop_options’ pragma pops saved settings from that stack.

     Here’s an example of using this stack.

          _Pragma ("GCC push_options")
          _Pragma ("GCC optimize forward-propagate")

          /* Functions to compile
             with the ‘forward-propagate’ optimization. */

          _Pragma ("GCC pop_options")
          /* Ends enablement of ‘forward-propagate’. */

‘#pragma GCC reset_options’
‘_Pragma ("GCC reset_options")’
     Clears all pragma-defined ‘target’ and ‘optimize’ optimization
     settings.


File: c,  Node: Static Assertions,  Prev: Pragmas,  Up: Directing Compilation

30.2 Static Assertions
======================

You can add compiler-time tests for necessary conditions into your code
using ‘_Static_assert’.  This can be useful, for example, to check that
the compilation target platform supports the type sizes that the code
expects.  For example,

     _Static_assert ((sizeof (long int) >= 8),
         "long int needs to be at least 8 bytes");

reports a compile-time error if compiled on a system with long integers
smaller than 8 bytes, with ‘long int needs to be at least 8 bytes’ as
the error message.

   Since calls ‘_Static_assert’ are processed at compile time, the
expression must be computable at compile time and the error message must
be a literal string.  The expression can refer to the sizes of
variables, but can’t refer to their values.  For example, the following
static assertion is invalid for two reasons:

     char *error_message
       = "long int needs to be at least 8 bytes";
     int size_of_long_int = sizeof (long int);

     _Static_assert (size_of_long_int == 8, error_message);

The expression ‘size_of_long_int == 8’ isn’t computable at compile time,
and the error message isn’t a literal string.

   You can, though, use preprocessor definition values with
‘_Static_assert’:

     #define LONG_INT_ERROR_MESSAGE "long int needs to be \
     at least 8 bytes"

     _Static_assert ((sizeof (long int) == 8),
       LONG_INT_ERROR_MESSAGE);

   Static assertions are permitted wherever a statement or declaration
is permitted, including at top level in the file, and also inside the
definition of a type.

     union y
     {
       int i;
       int *ptr;
       _Static_assert (sizeof (int *) == sizeof (int),
     		  "Pointer and int not same size");
     };


File: c,  Node: Type Alignment,  Next: Aliasing,  Prev: Directing Compilation,  Up: Top

Appendix A Type Alignment
*************************

Code for device drivers and other communication with low-level hardware
sometimes needs to be concerned with the alignment of data objects in
memory.

   Each data type has a required “alignment”, always a power of 2, that
says at which memory addresses an object of that type can validly start.
A valid address for the type must be a multiple of its alignment.  If a
type’s alignment is 1, that means it can validly start at any address.
If a type’s alignment is 2, that means it can only start at an even
address.  If a type’s alignment is 4, that means it can only start at an
address that is a multiple of 4.

   The alignment of a type (except ‘char’) can vary depending on the
kind of computer in use.  To refer to the alignment of a type in a C
program, use ‘_Alignof’, whose syntax parallels that of ‘sizeof’.  Like
‘sizeof’, ‘_Alignof’ is a compile-time operation, and it doesn’t compute
the value of the expression used as its argument.

   Nominally, each integer and floating-point type has an alignment
equal to the largest power of 2 that divides its size.  Thus, ‘int’ with
size 4 has a nominal alignment of 4, and ‘long long int’ with size 8 has
a nominal alignment of 8.

   However, each kind of computer generally has a maximum alignment, and
no type needs more alignment than that.  If the computer’s maximum
alignment is 4 (which is common), then no type’s alignment is more than
4.

   The size of any type is always a multiple of its alignment; that way,
in an array whose elements have that type, all the elements are properly
aligned if the first one is.

   These rules apply to all real computers today, but some embedded
controllers have odd exceptions.  We don’t have references to cite for
them.

   Ordinary C code guarantees that every object of a given type is in
fact aligned as that type requires.

   If the operand of ‘_Alignof’ is a structure field, the value is the
alignment it requires.  It may have a greater alignment by coincidence,
due to the other fields, but ‘_Alignof’ is not concerned about that.
*Note Structures::.

   Older versions of GNU C used the keyword ‘__alignof__’ for this, but
now that the feature has been standardized, it is better to use the
standard keyword ‘_Alignof’.

   You can explicitly specify an alignment requirement for a particular
variable or structure field by adding ‘_Alignas (ALIGNMENT)’ to the
declaration, where ALIGNMENT is a power of 2 or a type name.  For
instance:

     char _Alignas (8) x;

or

     char _Alignas (double) x;

specifies that ‘x’ must start on an address that is a multiple of 8.
However, if ALIGNMENT exceeds the maximum alignment for the machine,
that maximum is how much alignment ‘x’ will get.

   The older GNU C syntax for this feature looked like ‘__attribute__
((__aligned__ (ALIGNMENT)))’ to the declaration, and was added after the
variable.  For instance:

     char x __attribute__ ((__aligned__ 8));

   *Note Attributes::.


File: c,  Node: Aliasing,  Next: Digraphs,  Prev: Type Alignment,  Up: Top

Appendix B Aliasing
*******************

We have already presented examples of casting a ‘void *’ pointer to
another pointer type, and casting another pointer type to ‘void *’.

   One common kind of pointer cast is guaranteed safe: casting the value
returned by ‘malloc’ and related functions (*note Dynamic Memory
Allocation::).  It is safe because these functions do not save the
pointer anywhere else; the only way the program will access the newly
allocated memory is via the pointer just returned.

   In fact, C allows casting any pointer type to any other pointer type.
Using this to access the same place in memory using two different data
types is called “aliasing”.

   Aliasing is necessary in some programs that do sophisticated memory
management, such as GNU Emacs, but most C programs don’t need to do
aliasing.  When it isn’t needed, *stay away from it!*  To do aliasing
correctly requires following the rules stated below.  Otherwise, the
aliasing may result in malfunctions when the program runs.

   The rest of this appendix explains the pitfalls and rules of
aliasing.

* Menu:

* Aliasing Alignment::   Memory alignment considerations for
                           casting between pointer types.
* Aliasing Length::      Type size considerations for
                           casting between pointer types.
* Aliasing Type Rules::  Even when type alignment and size matches,
                           aliasing can still have surprising results.


File: c,  Node: Aliasing Alignment,  Next: Aliasing Length,  Up: Aliasing

B.1 Aliasing and Alignment
==========================

In order for a type-converted pointer to be valid, it must have the
alignment that the new pointer type requires.  For instance, on most
computers, ‘int’ has alignment 4; the address of an ‘int’ must be a
multiple of 4.  However, ‘char’ has alignment 1, so the address of a
‘char’ is usually not a multiple of 4.  Taking the address of such a
‘char’ and casting it to ‘int *’ probably results in an invalid pointer.
Trying to dereference it may cause a ‘SIGBUS’ signal, depending on the
platform in use (*note Signals::).

     foo ()
     {
       char i[4];
       int *p = (int *) &i[1]; /* Misaligned pointer! */
       return *p;              /* Crash! */
     }

   This requirement is never a problem when casting the return value of
‘malloc’ because that function always returns a pointer with as much
alignment as any type can require.


File: c,  Node: Aliasing Length,  Next: Aliasing Type Rules,  Prev: Aliasing Alignment,  Up: Aliasing

B.2 Aliasing and Length
=======================

When converting a pointer to a different pointer type, make sure the
object it really points to is at least as long as the target of the
converted pointer.  For instance, suppose ‘p’ has type ‘int *’ and it’s
cast as follows:

     int *p;

     struct
       {
         double d, e, f;
       } foo;

     struct foo *q = (struct foo *)p;

     q->f = 5.14159;

the value ‘q->f’ will run past the end of the ‘int’ that ‘p’ points to.
If ‘p’ was initialized to the start of an array of type ‘int[6]’, the
object is long enough for three ‘double’s.  But if ‘p’ points to
something shorter, ‘q->f’ will run on beyond the end of that, overlaying
some other data.  Storing that will garble that other data.  Or it could
extend past the end of memory space and cause a ‘SIGSEGV’ signal (*note
Signals::).


File: c,  Node: Aliasing Type Rules,  Prev: Aliasing Length,  Up: Aliasing

B.3 Type Rules for Aliasing
===========================

C code that converts a pointer to a different pointer type can use the
pointers to access the same memory locations with two different data
types.  If the same address is accessed with different types in a single
control thread, optimization can make the code do surprising things (in
effect, make it malfunction).

   Here’s a concrete example where aliasing that can change the code’s
behavior when it is optimized.  We assume that ‘float’ is 4 bytes long,
like ‘int’, and so is every pointer.  Thus, the structures ‘struct a’
and ‘struct b’ are both 8 bytes.

     #include <stdio.h>
     struct a { int size; char *data; };
     struct b { float size; char *data; };

     void sub (struct a *p, struct b *q)
     {
       int x;
       p->size = 0;
       q->size = 1;
       x = p->size;
       printf("x       =%d\n", x);
       printf("p->size =%d\n", (int)p->size);
       printf("q->size =%d\n", (int)q->size);
     }

     int main(void)
     {
       struct a foo;
       struct a *p = &foo;
       struct b *q = (struct b *) &foo;

       sub (p, q);
     }

   This code works as intended when compiled without optimization.  All
the operations are carried out sequentially as written.  The code sets
‘x’ to ‘p->size’, but what it actually gets is the bits of the floating
point number 1, as type ‘int’.

   However, when optimizing, the compiler is allowed to assume
(mistakenly, here) that ‘q’ does not point to the same storage as ‘p’,
because their data types are not allowed to alias.

   From this assumption, the compiler can deduce (falsely, here) that
the assignment into ‘q->size’ has no effect on the value of ‘p->size’,
which must therefore still be 0.  Thus, ‘x’ will be set to 0.

   GNU C, following the C standard, _defines_ this optimization as
legitimate.  Code that misbehaves when optimized following these rules
is, by definition, incorrect C code.

   The rules for storage aliasing in C are based on the two data types:
the type of the object, and the type it is accessed through.  The rules
permit accessing part of a storage object of type T using only these
types:

   • T.

   • A type compatible with T.  *Note Compatible Types::.

   • A signed or unsigned version of one of the above.

   • A qualifed version of one of the above.  *Note Type Qualifiers::.

   • An array, structure (*note Structures::), or union type (‘Unions’)
     that contains one of the above, either directly as a field or
     through multiple levels of fields.  If T is ‘double’, this would
     include ‘struct s { union { double d[2]; int i[4]; } u; int i; };’
     because there’s a ‘double’ inside it somewhere.

   • A character type.

   What do these rules say about the example in this subsection?

   For ‘foo.size’ (equivalently, ‘a->size’), T is ‘int’.  The type
‘float’ is not allowed as an aliasing type by those rules, so ‘b->size’
is not supposed to alias with elements of ‘j’.  Based on that
assumption, GNU C makes a permitted optimization that was not, in this
case, consistent with what the programmer intended the program to do.

   Whether GCC actually performs type-based aliasing analysis depends on
the details of the code.  GCC has other ways to determine (in some
cases) whether objects alias, and if it gets a reliable answer that way,
it won’t fall back on type-based heuristics.

   The importance of knowing the type-based aliasing rules is not so as
to ensure that the optimization is done where it would be safe, but so
as to ensure it is _not_ done in a way that would break the program.
You can turn off type-based aliasing analysis by giving GCC the option
‘-fno-strict-aliasing’.


File: c,  Node: Digraphs,  Next: Attributes,  Prev: Aliasing,  Up: Top

Appendix C Digraphs
*******************

C accepts aliases for certain characters.  Apparently in the 1990s some
computer systems had trouble inputting these characters, or trouble
displaying them.  These digraphs almost never appear in C programs
nowadays, but we mention them for completeness.

‘<:’
     An alias for ‘[’.
‘:>’
     An alias for ‘]’.
‘<%’
     An alias for ‘{’.
‘%>’
     An alias for ‘}’.
‘%:’
     An alias for ‘#’, used for preprocessing directives (*note
     Directives::) and macros (*note Macros::).


File: c,  Node: Attributes,  Next: Signals,  Prev: Digraphs,  Up: Top

Appendix D Attributes in Declarations
*************************************

You can specify certain additional requirements in a declaration, to get
fine-grained control over code generation, and helpful informational
messages during compilation.  We use a few attributes in code examples
throughout this manual, including

‘aligned’
     The ‘aligned’ attribute specifies a minimum alignment for a
     variable or structure field, measured in bytes:

          int foo __attribute__ ((aligned (8))) = 0;

     This directs GNU C to allocate ‘foo’ at an address that is a
     multiple of 8 bytes.  However, you can’t force an alignment bigger
     than the computer’s maximum meaningful alignment.

‘packed’
     The ‘packed’ attribute specifies to compact the fields of a
     structure by not leaving gaps between fields.  For example,

          struct __attribute__ ((packed)) bar
          {
            char a;
            int b;
          };

     allocates the integer field ‘b’ at byte 1 in the structure,
     immediately after the character field ‘a’.  The packed structure is
     just 5 bytes long (assuming ‘int’ is 4 bytes) and its alignment is
     1, that of ‘char’.

‘deprecated’
     Applicable to both variables and functions, the ‘deprecated’
     attribute tells the compiler to issue a warning if the variable or
     function is ever used in the source file.

          int old_foo __attribute__ ((deprecated));

          int old_quux () __attribute__ ((deprecated));

‘__noinline__’
     The ‘__noinline__’ attribute, in a function’s declaration or
     definition, specifies never to inline calls to that function.  All
     calls to that function, in a compilation unit where it has this
     attribute, will be compiled to invoke the separately compiled
     function.  *Note Inline Function Definitions::.

‘__noclone__’
     The ‘__noclone__’ attribute, in a function’s declaration or
     definition, specifies never to clone that function.  Thus, there
     will be only one compiled version of the function.  *Note Label
     Value Caveats::, for more information about cloning.

‘always_inline’
     The ‘always_inline’ attribute, in a function’s declaration or
     definition, specifies to inline all calls to that function (unless
     something about the function makes inlining impossible).  This
     applies to all calls to that function in a compilation unit where
     it has this attribute.  *Note Inline Function Definitions::.

‘gnu_inline’
     The ‘gnu_inline’ attribute, in a function’s declaration or
     definition, specifies to handle the ‘inline’ keywprd the way GNU C
     originally implemented it, many years before ISO C said anything
     about inlining.  *Note Inline Function Definitions::.

   For full documentation of attributes, see the GCC manual.  *Note
Attribute Syntax: (gcc)Attribute Syntax.


File: c,  Node: Signals,  Next: GNU Free Documentation License,  Prev: Attributes,  Up: Top

Appendix E Signals
******************

Some program operations bring about an error condition called a
“signal”.  These signals terminate the program, by default.

   There are various different kinds of signals, each with a name.  We
have seen several such error conditions through this manual:

‘SIGSEGV’
     This signal is generated when a program tries to read or write
     outside the memory that is allocated for it, or to write memory
     that can only be read.  The name is an abbreviation for
     “segmentation violation”.

‘SIGFPE’
     This signal indicates a fatal arithmetic error.  The name is an
     abbreviation for “floating-point exception”, but covers all types
     of arithmetic errors, including division by zero and overflow.

‘SIGBUS’
     This signal is generated when an invalid pointer is dereferenced,
     typically the result of dereferencing an uninintalized pointer.  It
     is similar to ‘SIGSEGV’, except that ‘SIGSEGV’ indicates invalid
     access to valid memory, while ‘SIGBUS’ indicates an attempt to
     access an invalid address.

   These kinds of signal allow the program to specify a function as a
“signal handler”.  When a signal has a handler, it doesn’t terminate the
program; instead it calls the handler.

   There are many other kinds of signal; here we list only those that
come from run-time errors in C operations.  The rest have to do with the
functioning of the operating system.  The GNU C Library Reference Manual
gives more explanation about signals (*note The GNU C Library:
(libc)Program Signal Handling.).


File: c,  Node: GNU Free Documentation License,  Next: Symbol Index,  Prev: Signals,  Up: Top

Appendix F GNU Free Documentation License
*****************************************

                     Version 1.3, 3 November 2008

     Copyright © 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
     <http://fsf.org/>

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     functional and useful document “free” in the sense of freedom: to
     assure everyone the effective freedom to copy and redistribute it,
     with or without modifying it, either commercially or
     noncommercially.  Secondarily, this License preserves for the
     author and publisher a way to get credit for their work, while not
     being considered responsible for modifications made by others.

     This License is a kind of “copyleft”, which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.  We
     recommend this License principally for works whose purpose is
     instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work, in any medium,
     that contains a notice placed by the copyright holder saying it can
     be distributed under the terms of this License.  Such a notice
     grants a world-wide, royalty-free license, unlimited in duration,
     to use that work under the conditions stated herein.  The
     “Document”, below, refers to any such manual or work.  Any member
     of the public is a licensee, and is addressed as “you”.  You accept
     the license if you copy, modify or distribute the work in a way
     requiring permission under copyright law.

     A “Modified Version” of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A “Secondary Section” is a named appendix or a front-matter section
     of the Document that deals exclusively with the relationship of the
     publishers or authors of the Document to the Document’s overall
     subject (or to related matters) and contains nothing that could
     fall directly within that overall subject.  (Thus, if the Document
     is in part a textbook of mathematics, a Secondary Section may not
     explain any mathematics.)  The relationship could be a matter of
     historical connection with the subject or with related matters, or
     of legal, commercial, philosophical, ethical or political position
     regarding them.

     The “Invariant Sections” are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in the
     notice that says that the Document is released under this License.
     If a section does not fit the above definition of Secondary then it
     is not allowed to be designated as Invariant.  The Document may
     contain zero Invariant Sections.  If the Document does not identify
     any Invariant Sections then there are none.

     The “Cover Texts” are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.  A
     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
     be at most 25 words.

     A “Transparent” copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, that is suitable for revising the document
     straightforwardly with generic text editors or (for images composed
     of pixels) generic paint programs or (for drawings) some widely
     available drawing editor, and that is suitable for input to text
     formatters or for automatic translation to a variety of formats
     suitable for input to text formatters.  A copy made in an otherwise
     Transparent file format whose markup, or absence of markup, has
     been arranged to thwart or discourage subsequent modification by
     readers is not Transparent.  An image format is not Transparent if
     used for any substantial amount of text.  A copy that is not
     “Transparent” is called “Opaque”.

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and standard-conforming
     simple HTML, PostScript or PDF designed for human modification.
     Examples of transparent image formats include PNG, XCF and JPG.
     Opaque formats include proprietary formats that can be read and
     edited only by proprietary word processors, SGML or XML for which
     the DTD and/or processing tools are not generally available, and
     the machine-generated HTML, PostScript or PDF produced by some word
     processors for output purposes only.

     The “Title Page” means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, “Title
     Page” means the text near the most prominent appearance of the
     work’s title, preceding the beginning of the body of the text.

     The “publisher” means any person or entity that distributes copies
     of the Document to the public.

     A section “Entitled XYZ” means a named subunit of the Document
     whose title either is precisely XYZ or contains XYZ in parentheses
     following text that translates XYZ in another language.  (Here XYZ
     stands for a specific section name mentioned below, such as
     “Acknowledgements”, “Dedications”, “Endorsements”, or “History”.)
     To “Preserve the Title” of such a section when you modify the
     Document means that it remains a section “Entitled XYZ” according
     to this definition.

     The Document may include Warranty Disclaimers next to the notice
     which states that this License applies to the Document.  These
     Warranty Disclaimers are considered to be included by reference in
     this License, but only as regards disclaiming warranties: any other
     implication that these Warranty Disclaimers may have is void and
     has no effect on the meaning of this License.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow the
     conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies (or copies in media that commonly
     have printed covers) of the Document, numbering more than 100, and
     the Document’s license notice requires Cover Texts, you must
     enclose the copies in covers that carry, clearly and legibly, all
     these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the title
     equally prominent and visible.  You may add other material on the
     covers in addition.  Copying with changes limited to the covers, as
     long as they preserve the title of the Document and satisfy these
     conditions, can be treated as verbatim copying in other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a machine-readable
     Transparent copy along with each Opaque copy, or state in or with
     each Opaque copy a computer-network location from which the general
     network-using public has access to download using public-standard
     network protocols a complete Transparent copy of the Document, free
     of added material.  If you use the latter option, you must take
     reasonably prudent steps, when you begin distribution of Opaque
     copies in quantity, to ensure that this Transparent copy will
     remain thus accessible at the stated location until at least one
     year after the last time you distribute an Opaque copy (directly or
     through your agents or retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of copies,
     to give them a chance to provide you with an updated version of the
     Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with the
     Modified Version filling the role of the Document, thus licensing
     distribution and modification of the Modified Version to whoever
     possesses a copy of it.  In addition, you must do these things in
     the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of previous
          versions (which should, if there were any, be listed in the
          History section of the Document).  You may use the same title
          as a previous version if the original publisher of that
          version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has fewer than five), unless they release you
          from this requirement.

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document’s
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section Entitled “History”, Preserve its Title,
          and add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on the
          Title Page.  If there is no section Entitled “History” in the
          Document, create one stating the title, year, authors, and
          publisher of the Document as given on its Title Page, then add
          an item describing the Modified Version as stated in the
          previous sentence.

       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in the
          “History” section.  You may omit a network location for a work
          that was published at least four years before the Document
          itself, or if the original publisher of the version it refers
          to gives permission.

       K. For any section Entitled “Acknowledgements” or “Dedications”,
          Preserve the Title of the section, and preserve in the section
          all the substance and tone of each of the contributor
          acknowledgements and/or dedications given therein.

       L. Preserve all the Invariant Sections of the Document, unaltered
          in their text and in their titles.  Section numbers or the
          equivalent are not considered part of the section titles.

       M. Delete any section Entitled “Endorsements”.  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section to be Entitled
          “Endorsements” or to conflict in title with any Invariant
          Section.

       O. Preserve any Warranty Disclaimers.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option designate
     some or all of these sections as invariant.  To do this, add their
     titles to the list of Invariant Sections in the Modified Version’s
     license notice.  These titles must be distinct from any other
     section titles.

     You may add a section Entitled “Endorsements”, provided it contains
     nothing but endorsements of your Modified Version by various
     parties—for example, statements of peer review or that the text has
     been approved by an organization as the authoritative definition of
     a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end of
     the list of Cover Texts in the Modified Version.  Only one passage
     of Front-Cover Text and one of Back-Cover Text may be added by (or
     through arrangements made by) any one entity.  If the Document
     already includes a cover text for the same cover, previously added
     by you or by arrangement made by the same entity you are acting on
     behalf of, you may not add another; but you may replace the old
     one, on explicit permission from the previous publisher that added
     the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination all
     of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice, and that you preserve all
     their Warranty Disclaimers.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections Entitled
     “History” in the various original documents, forming one section
     Entitled “History”; likewise combine any sections Entitled
     “Acknowledgements”, and any sections Entitled “Dedications”.  You
     must delete all sections Entitled “Endorsements.”

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the documents
     in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow this
     License in all other respects regarding verbatim copying of that
     document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of a
     storage or distribution medium, is called an “aggregate” if the
     copyright resulting from the compilation is not used to limit the
     legal rights of the compilation’s users beyond what the individual
     works permit.  When the Document is included in an aggregate, this
     License does not apply to the other works in the aggregate which
     are not themselves derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one half
     of the entire aggregate, the Document’s Cover Texts may be placed
     on covers that bracket the Document within the aggregate, or the
     electronic equivalent of covers if the Document is in electronic
     form.  Otherwise they must appear on printed covers that bracket
     the whole aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License, and all the license notices in the
     Document, and any Warranty Disclaimers, provided that you also
     include the original English version of this License and the
     original versions of those notices and disclaimers.  In case of a
     disagreement between the translation and the original version of
     this License or a notice or disclaimer, the original version will
     prevail.

     If a section in the Document is Entitled “Acknowledgements”,
     “Dedications”, or “History”, the requirement (section 4) to
     Preserve its Title (section 1) will typically require changing the
     actual title.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense, or distribute it is void,
     and will automatically terminate your rights under this License.

     However, if you cease all violation of this License, then your
     license from a particular copyright holder is reinstated (a)
     provisionally, unless and until the copyright holder explicitly and
     finally terminates your license, and (b) permanently, if the
     copyright holder fails to notify you of the violation by some
     reasonable means prior to 60 days after the cessation.

     Moreover, your license from a particular copyright holder is
     reinstated permanently if the copyright holder notifies you of the
     violation by some reasonable means, this is the first time you have
     received notice of violation of this License (for any work) from
     that copyright holder, and you cure the violation prior to 30 days
     after your receipt of the notice.

     Termination of your rights under this section does not terminate
     the licenses of parties who have received copies or rights from you
     under this License.  If your rights have been terminated and not
     permanently reinstated, receipt of a copy of some or all of the
     same material does not give you any rights to use it.

  10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     <http://www.gnu.org/copyleft/>.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License “or any later version” applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If the
     Document does not specify a version number of this License, you may
     choose any version ever published (not as a draft) by the Free
     Software Foundation.  If the Document specifies that a proxy can
     decide which future versions of this License can be used, that
     proxy’s public statement of acceptance of a version permanently
     authorizes you to choose that version for the Document.

  11. RELICENSING

     “Massive Multiauthor Collaboration Site” (or “MMC Site”) means any
     World Wide Web server that publishes copyrightable works and also
     provides prominent facilities for anybody to edit those works.  A
     public wiki that anybody can edit is an example of such a server.
     A “Massive Multiauthor Collaboration” (or “MMC”) contained in the
     site means any set of copyrightable works thus published on the MMC
     site.

     “CC-BY-SA” means the Creative Commons Attribution-Share Alike 3.0
     license published by Creative Commons Corporation, a not-for-profit
     corporation with a principal place of business in San Francisco,
     California, as well as future copyleft versions of that license
     published by that same organization.

     “Incorporate” means to publish or republish a Document, in whole or
     in part, as part of another Document.

     An MMC is “eligible for relicensing” if it is licensed under this
     License, and if all works that were first published under this
     License somewhere other than this MMC, and subsequently
     incorporated in whole or in part into the MMC, (1) had no cover
     texts or invariant sections, and (2) were thus incorporated prior
     to November 1, 2008.

     The operator of an MMC Site may republish an MMC contained in the
     site under CC-BY-SA on the same site at any time before August 1,
     2009, provided the MMC is eligible for relicensing.

ADDENDUM: How to use this License for your documents
====================================================

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.3
       or any later version published by the Free Software Foundation;
       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
       Texts.  A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.

   If you have Invariant Sections, Front-Cover Texts and Back-Cover
Texts, replace the “with...Texts.” line with this:

         with the Invariant Sections being LIST THEIR TITLES, with
         the Front-Cover Texts being LIST, and with the Back-Cover Texts
         being LIST.

   If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of free
software license, such as the GNU General Public License, to permit
their use in free software.


File: c,  Node: Symbol Index,  Next: Concept Index,  Prev: GNU Free Documentation License,  Up: Top

Index of Symbols and Keywords
*****************************

 [index ]
* Menu:

* #define:                               Object-like Macros.   (line 12)
* #elif:                                 elif.                 (line  6)
* #else:                                 else.                 (line  6)
* #endif:                                ifdef.                (line  6)
* #error:                                Diagnostics.          (line  6)
* #if:                                   Conditional Syntax.   (line  6)
* #ifdef:                                ifdef.                (line  6)
* #ifndef:                               ifdef.                (line 41)
* #include:                              include Syntax.       (line  6)
* #line:                                 Line Control.         (line 24)
* #undef:                                Undefining and Redefining Macros.
                                                               (line  6)
* #warning:                              Diagnostics.          (line 17)
* _Alignas:                              Type Alignment.       (line 54)
* _Alignof:                              Type Alignment.       (line  6)
* _Complex:                              Complex Data Types.   (line  6)
* _Static_assert:                        Static Assertions.    (line  6)
* __aligned__:                           Type Alignment.       (line 54)
* __alignof__:                           Type Alignment.       (line  6)
* __attribute__:                         Attributes.           (line  6)
* __auto_type:                           Auto Type.            (line  6)
* __complex__:                           Complex Data Types.   (line  6)
* __label__:                             Local Labels.         (line  6)
* auto:                                  auto and register.    (line  6)
* bool:                                  Boolean Type.         (line  6)
* break:                                 break Statement.      (line  6)
* case:                                  switch Statement.     (line  6)
* char:                                  Basic Integers.       (line  6)
* CHAR_MAX:                              Maximum and Minimum Values.
                                                               (line  6)
* const:                                 const.                (line  6)
* continue:                              continue Statement.   (line  6)
* DBL_DECIMAL_DIG:                       Floating Type Specs.  (line 10)
* DBL_HAS_SUBNORM:                       Floating Type Specs.  (line 10)
* DBL_MAX:                               Floating Type Specs.  (line 10)
* DBL_MIN:                               Floating Type Specs.  (line 10)
* DBL_TRUE_MIN:                          Floating Type Specs.  (line 10)
* default:                               switch Statement.     (line  6)
* do:                                    do-while Statement.   (line  6)
* double:                                Floating-Point Data Types.
                                                               (line  6)
* else:                                  if-else Statement.    (line  6)
* extern:                                Extern Declarations.  (line  6)
* float:                                 Floating-Point Data Types.
                                                               (line  6)
* FLT_DECIMAL_DIG:                       Floating Type Specs.  (line 10)
* FLT_HAS_SUBNORM:                       Floating Type Specs.  (line 10)
* FLT_MAX:                               Floating Type Specs.  (line 10)
* FLT_MIN:                               Floating Type Specs.  (line 10)
* FLT_TRUE_MIN:                          Floating Type Specs.  (line 10)
* for:                                   for Statement.        (line  6)
* goto:                                  goto Statement.       (line  6)
* if:                                    if Statement.         (line  6)
* inline:                                Inline Function Definitions.
                                                               (line  6)
* int:                                   Basic Integers.       (line  6)
* INT_MAX:                               Maximum and Minimum Values.
                                                               (line  6)
* LDBL_DECIMAL_DIG:                      Floating Type Specs.  (line 10)
* LDBL_HAS_SUBNORM:                      Floating Type Specs.  (line 10)
* LDBL_MAX:                              Floating Type Specs.  (line 10)
* LDBL_MIN:                              Floating Type Specs.  (line 10)
* LDBL_TRUE_MIN:                         Floating Type Specs.  (line 10)
* LLONG_MAX:                             Maximum and Minimum Values.
                                                               (line  6)
* long double:                           Floating-Point Data Types.
                                                               (line  6)
* long int:                              Basic Integers.       (line  6)
* long long int:                         Basic Integers.       (line  6)
* LONG_MAX:                              Maximum and Minimum Values.
                                                               (line  6)
* main:                                  The main Function.    (line  6)
* register:                              auto and register.    (line  6)
* restrict:                              restrict Pointers.    (line  6)
* return:                                return Statement.     (line  6)
* SCHAR_MAX:                             Maximum and Minimum Values.
                                                               (line  6)
* short int:                             Basic Integers.       (line  6)
* SHRT_MAX:                              Maximum and Minimum Values.
                                                               (line  6)
* signed:                                Signed and Unsigned Types.
                                                               (line  6)
* sizeof:                                Type Size.            (line  6)
* static:                                Static Local Variables.
                                                               (line  6)
* static <1>:                            Static Functions.     (line  6)
* struct:                                Structures.           (line  6)
* switch:                                switch Statement.     (line  6)
* typedef:                               Defining Typedef Names.
                                                               (line  6)
* typeof:                                Auto Type.            (line  6)
* UCHAR_MAX:                             Maximum and Minimum Values.
                                                               (line  6)
* UINT_MAX:                              Maximum and Minimum Values.
                                                               (line  6)
* ULLONG_MAX:                            Maximum and Minimum Values.
                                                               (line  6)
* ULONG_MAX:                             Maximum and Minimum Values.
                                                               (line  6)
* union:                                 Unions.               (line  6)
* unsigned:                              Signed and Unsigned Types.
                                                               (line  6)
* USHRT_MAX:                             Maximum and Minimum Values.
                                                               (line  6)
* void:                                  The Void Type.        (line  6)
* volatile:                              volatile.             (line  6)
* while:                                 while Statement.      (line  6)

