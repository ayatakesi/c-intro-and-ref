<?xml version="1.0"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [
  <!ENTITY tex "TeX">
  <!ENTITY latex "LaTeX">
]>
<book id="c.docbook" lang="en">
<title>GNU C Language Manual</title>


<bookinfo><legalnotice><para>Copyright &#169; 2022 Richard Stallman and Free Software Foundation, Inc.
</para>
<para>(The work of Trevis Rothwell and Nelson Beebe has been assigned or
licensed to the FSF.)
</para>
<blockquote><para>Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being &#8220;GNU General Public License,&#8221; with the
Front-Cover Texts being &#8220;A GNU Manual,&#8221; and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled &#8220;GNU Free Documentation License.&#8221;
</para>
<para>(a) The FSF&#8217;s Back-Cover Text is: &#8220;You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom.&#8221;
</para></blockquote></legalnotice></bookinfo>


GNU C Language Intro and Reference Manual
<!-- @center @value{EDITION} Edition -->
Richard Stallman
and
Trevis Rothwell
plus Nelson Beebe
on floating point

<para>Copyright &#169; 2022 Richard Stallman and Free Software Foundation, Inc.
</para>
<para>(The work of Trevis Rothwell and Nelson Beebe has been assigned or
licensed to the FSF.)
</para>
<blockquote><para>Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being &#8220;GNU General Public License,&#8221; with the
Front-Cover Texts being &#8220;A GNU Manual,&#8221; and with the Back-Cover
Texts as in (a) below.  A copy of the license is included in the
section entitled &#8220;GNU Free Documentation License.&#8221;
</para>
<para>(a) The FSF&#8217;s Back-Cover Text is: &#8220;You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom.&#8221;
</para></blockquote>
<para>WILL BE Published by the Free Software Foundation 

51 Franklin Street, Fifth Floor 

Boston, MA 02110-1301 USA 

ISBN ?-??????-??-?
</para>




<chapter label="" id="Top">
<title>GNU C Manual</title>

<para>This manual explains the C language for use with the GNU Compiler
Collection (GCC) on the GNU/Linux system and other systems.  We refer
to this dialect as GNU C.  If you already know C, you can use this as
a reference manual.
</para>
<para>If you understand basic concepts of programming but know nothing about
C, you can read this manual sequentially from the beginning to learn
the C language.
</para>
<para>If you are a beginner to programming, we recommend you first learn a
language with automatic garbage collection and no explicit pointers,
rather than starting with C.  Good choices include Lisp, Scheme,
Python and Java.  C&#8217;s explicit pointers mean that programmers must be
careful to avoid certain kinds of errors.
</para>
<para>C is a venerable language; it was first used in 1973.  The GNU C
Compiler, which was subsequently extended into the GNU Compiler
Collection, was first released in 1987.  Other important languages
were designed based on C: once you know C, it gives you a useful base
for learning C<literal>++</literal>, C#, Java, Scala, D, Go, and more.
</para>
<para>The special advantage of C is that it is fairly simple while allowing
close access to the computer&#8217;s hardware, which previously required
writing in assembler language to describe the individual machine
instructions.  Some have called C a &#8220;high-level assembler language&#8221;
because of its explicit pointers and lack of automatic management of
storage.  As one wag put it, &#8220;C combines the power of assembler
language with the convenience of assembler language.&#8221;  However, C is
far more portable, and much easier to read and write, than assembler
language.
</para>
<para>This manual focuses on the GNU C language supported by the GNU
Compiler Collection, version ???.  When a construct may be absent or
work differently in other C compilers, we say so.  When it is not part
of ISO standard C, we say it is a &#8220;GNU C extension,&#8221; because it is
useful to know that; however, other dialects and standards are not the
focus of this manual.  We keep those notes short, unless it is vital
to say more.  For the same reason, we hardly mention C<literal>++</literal> or other
languages that the GNU Compiler Collection supports.
</para>
<para>Some aspects of the meaning of C programs depend on the target
platform: which computer, and which operating system, the compiled
code will run on.  Where this is the case, we say so.
</para>
<para>The C language provides no built-in facilities for performing such
common operations as input/output, memory management, string
manipulation, and the like.  Instead, these facilities are defined in
a standard library, which is automatically available in every C
program.  See section &#8220;The GNU C Library&#8221; in <citetitle>The GNU C Library
Reference Manual</citetitle>.
</para>
<para>This manual incorporates the former GNU C Preprocessor Manual, which
was among the earliest GNU Manuals.  It also uses some text from the
earlier GNU C Manual that was written by Trevis Rothwell and James
Youngman.
</para>
<para>GNU C has many obscure features, each one either for historical
compatibility or meant for very special situations.  We have left them
to a companion manual, the GNU C Obscurities Manual, which will be
published digitally later.
</para>

</chapter>
<chapter label="1" id="The-First-Example">
<title>The First Example</title>

<para>This chapter presents the source code for a very simple C program and
uses it to explain a few features of the language.  If you already
know the basic points of C presented in this chapter, you can skim it
or skip it.
</para>

<sect1 label="1.1" id="Recursive-Fibonacci">
<title>Example: Recursive Fibonacci</title>
<indexterm role="cp"><primary>recursive Fibonacci function</primary></indexterm>
<indexterm role="cp"><primary>Fibonacci function, recursive</primary></indexterm>

<para>To introduce the most basic features of C, let&#8217;s look at code for a
simple mathematical function that does calculations on integers.  This
function calculates the <replaceable>n</replaceable>th number in the Fibonacci series, in
which each number is the sum of the previous two: 1, 1, 2, 3, 5, 8,
13, 21, 34, 55, &#8230;.
</para>
<screen>int
fib (int n)
{
  if (n &lt;= 2)  /* This avoids infinite recursion.  */
    return 1;
  else
    return fib (n - 1) + fib (n - 2);
}
</screen>
<para>This very simple program illustrates several features of C:
</para>
<itemizedlist><listitem><para>A function definition, whose first two lines constitute the function
header.  See <link linkend="Function-Definitions">Function Definitions</link>.
</para>
</listitem><listitem><para>A function parameter <literal>n</literal>, referred to as the variable <literal>n</literal>
inside the function body.  See <link linkend="Function-Parameter-Variables">Function Parameter Variables</link>.
A function definition uses parameters to refer to the argument
values provided in a call to that function.
</para>
</listitem><listitem><para>Arithmetic.  C programs add with &#8216;<literal>+</literal>&#8217; and subtract with
&#8216;<literal>-</literal>&#8217;.  See <link linkend="Arithmetic">Arithmetic</link>.
</para>
</listitem><listitem><para>Numeric comparisons.  The operator &#8216;<literal>&lt;=</literal>&#8217; tests for &#8220;less than or
equal.&#8221;  See <link linkend="Numeric-Comparisons">Numeric Comparisons</link>.
</para>
</listitem><listitem><para>Integer constants written in base 10.
See <link linkend="Integer-Constants">Integer Constants</link>.
</para>
</listitem><listitem><para>A function call.  The function call <literal>fib (n - 1)</literal> calls the
function <literal>fib</literal>, passing as its argument the value <literal>n - 1</literal>.
See <link linkend="Function-Calls">Function Calls</link>.
</para>
</listitem><listitem><para>A comment, which starts with &#8216;<literal>/*</literal>&#8217; and ends with &#8216;<literal>*/</literal>&#8217;.  The
comment has no effect on the execution of the program.  Its purpose is
to provide explanations to people reading the source code.  Including
comments in the code is tremendously important&#8212;they provide
background information so others can understand the code more quickly.
See <link linkend="Comments">Comments</link>.
</para>
</listitem><listitem><para>Two kinds of statements, the <literal>return</literal> statement and the
<literal>if</literal>&#8230;<literal>else</literal> statement.  See <link linkend="Statements">Statements</link>.
</para>
</listitem><listitem><para>Recursion.  The function <literal>fib</literal> calls itself; that is called a
<firstterm>recursive call</firstterm>.  These are valid in C, and quite common.
</para>
<para>The <literal>fib</literal> function would not be useful if it didn&#8217;t return.
Thus, recursive definitions, to be of any use, must avoid infinite
recursion.
</para>
<para>This function definition prevents infinite recursion by specially
handling the case where <literal>n</literal> is two or less.  Thus the maximum
depth of recursive calls is less than <literal>n</literal>.
</para></listitem></itemizedlist>

<sect2 label="1.1.1" id="Function-Header">
<title>Function Header</title>
<indexterm role="cp"><primary>function header</primary></indexterm>

<para>In our example, the first two lines of the function definition are the
<firstterm>header</firstterm>.  Its purpose is to state the function&#8217;s name and say how
it is called:
</para>
<screen>int
fib (int n)
</screen>
<para>says that the function returns an integer (type <literal>int</literal>), its name is
<literal>fib</literal>, and it takes one argument named <literal>n</literal> which is also an
integer.  (Data types will be explained later, in <link linkend="Primitive-Types">Primitive Types</link>.)
</para>
</sect2>
<sect2 label="1.1.2" id="Function-Body">
<title>Function Body</title>
<indexterm role="cp"><primary>function body</primary></indexterm>
<indexterm role="cp"><primary>recursion</primary></indexterm>

<para>The rest of the function definition is called the <firstterm>function body</firstterm>.
Like every function body, this one starts with &#8216;<literal>{</literal>&#8217;, ends with
&#8216;<literal>}</literal>&#8217;, and contains zero or more <firstterm>statements</firstterm> and
<firstterm>declarations</firstterm>.  Statements specify actions to take, whereas
declarations define names of variables, functions, and so on.  Each
statement and each declaration ends with a semicolon (&#8216;<literal>;</literal>&#8217;).
</para>
<para>Statements and declarations often contain <firstterm>expressions</firstterm>; an
expression is a construct whose execution produces a <firstterm>value</firstterm> of
some data type, but may also take actions through &#8220;side effects&#8221;
that alter subsequent execution.  A statement, by contrast, does not
have a value; it affects further execution of the program only through
the actions it takes.
</para>
<para>This function body contains no declarations, and just one statement,
but that one is a complex statement in that it contains nested
statements.  This function uses two kinds of statements:
</para>
<variablelist><varlistentry><term><literal>return</literal>
</term><listitem><para>The <literal>return</literal> statement makes the function return immediately.
It looks like this:
</para>
<screen>return <replaceable>value</replaceable>;
</screen>
<para>Its meaning is to compute the expression <replaceable>value</replaceable> and exit the
function, making it return whatever value that expression produced.
For instance,
</para>
<screen>return 1;
</screen>
<para>returns the integer 1 from the function, and
</para>
<screen>return fib (n - 1) + fib (n - 2);
</screen>
<para>returns a value computed by performing two function calls
as specified and adding their results.
</para>
</listitem></varlistentry><varlistentry><term><literal><literal>if</literal>&#8230;<literal>else</literal></literal>
</term><listitem><para>The <literal>if</literal>&#8230;<literal>else</literal> statement is a <firstterm>conditional</firstterm>.
Each time it executes, it chooses one of its two substatements to execute
and ignores the other.  It looks like this:
</para>
<screen>if (<replaceable>condition</replaceable>)
  <replaceable>if-true-statement</replaceable>
else
  <replaceable>if-false-statement</replaceable>
</screen>
<para>Its meaning is to compute the expression <replaceable>condition</replaceable> and, if it&#8217;s
&#8220;true,&#8221; execute <replaceable>if-true-statement</replaceable>.  Otherwise, execute
<replaceable>if-false-statement</replaceable>.  See <link linkend="if_002delse-Statement">if-else Statement</link>.
</para>
<para>Inside the <literal>if</literal>&#8230;<literal>else</literal> statement, <replaceable>condition</replaceable> is
simply an expression.  It&#8217;s considered &#8220;true&#8221; if its value is
nonzero.  (A comparison operation, such as <literal>n &lt;= 2</literal>, produces the
value 1 if it&#8217;s &#8220;true&#8221; and 0 if it&#8217;s &#8220;false.&#8221;  See <link linkend="Numeric-Comparisons">Numeric
Comparisons</link>.)  Thus,
</para>
<screen>if (n &lt;= 2)
  return 1;
else
  return fib (n - 1) + fib (n - 2);
</screen>
<para>first tests whether the value of <literal>n</literal> is less than or equal to 2.
If so, the expression <literal>n &lt;= 2</literal> has the value 1.  So execution
continues with the statement
</para>
<screen>return 1;
</screen>
<para>Otherwise, execution continues with this statement:
</para>
<screen>return fib (n - 1) + fib (n - 2);
</screen>
<para>Each of these statements ends the execution of the function and
provides a value for it to return.  See <link linkend="return-Statement">return Statement</link>.
</para></listitem></varlistentry></variablelist>
<para>Calculating <literal>fib</literal> using ordinary integers in C works only for
<replaceable>n</replaceable> &lt; 47, because the value of <literal>fib (47)</literal> is too large to fit
in type <literal>int</literal>.  The addition operation that tries to add
<literal>fib (46)</literal> and <literal>fib (45)</literal> cannot deliver the correct result.
This occurrence is called <firstterm>integer overflow</firstterm>.
</para>
<para>Overflow can manifest itself in various ways, but one thing that can&#8217;t
possibly happen is to produce the correct value, since that can&#8217;t fit
in the space for the value.  See <link linkend="Integer-Overflow">Integer Overflow</link>.
</para>
<para>See <link linkend="Functions">Functions</link>, for a full explanation about functions.
</para>
</sect2>
</sect1>
<sect1 label="1.2" id="Stack">
<title>The Stack, And Stack Overflow</title>
<indexterm role="cp"><primary>stack</primary></indexterm>
<indexterm role="cp"><primary>stack frame</primary></indexterm>
<indexterm role="cp"><primary>stack overflow</primary></indexterm>
<indexterm role="cp"><primary>recursion, drawbacks of</primary></indexterm>

<indexterm role="cp"><primary>stack frame</primary></indexterm>
<para>Recursion has a drawback: there are limits to how many nested function
calls a program can make.  In C, each function call allocates a block
of memory which it uses until the call returns.  C allocates these
blocks consecutively within a large area of memory known as the
<firstterm>stack</firstterm>, so we refer to the blocks as <firstterm>stack frames</firstterm>.
</para>
<para>The size of the stack is limited; if the program tries to use too
much, that causes the program to fail because the stack is full.  This
is called <firstterm>stack overflow</firstterm>.
</para>
<indexterm role="cp"><primary>crash</primary></indexterm>
<indexterm role="cp"><primary>segmentation fault</primary></indexterm>
<para>Stack overflow on GNU/Linux typically manifests itself as the
<firstterm>signal</firstterm> named <literal>SIGSEGV</literal>, also known as a &#8220;segmentation
fault.&#8221;  By default, this signal terminates the program immediately,
rather than letting the program try to recover, or reach an expected
ending point.  (We commonly say in this case that the program
&#8220;crashes&#8221;).  See <link linkend="Signals">Signals</link>.
</para>
<para>It is inconvenient to observe a crash by passing too large
an argument to recursive Fibonacci, because the program would run a
long time before it crashes.  This algorithm is simple but
ridiculously slow: in calculating <literal>fib (<replaceable>n</replaceable>)</literal>, the number of
(recursive) calls <literal>fib (1)</literal> or <literal>fib (2)</literal> that it makes equals
the final result.
</para>
<para>However, you can observe stack overflow very quickly if you use
this function instead:
</para>
<screen>int
fill_stack (int n)
{
  if (n &lt;= 1)  /* This limits the depth of recursion.  */
    return 1;
  else
    return fill_stack (n - 1);
}
</screen>
<para>Under gNewSense GNU/Linux on the Lemote Yeeloong, without optimization
and using the default configuration, an experiment showed there is
enough stack space to do 261906 nested calls to that function.  One
more, and the stack overflows and the program crashes.  On another
platform, with a different configuration, or with a different
function, the limit might be bigger or smaller.
</para>
</sect1>
<sect1 label="1.3" id="Iterative-Fibonacci">
<title>Example: Iterative Fibonacci</title>
<indexterm role="cp"><primary>iterative Fibonacci function</primary></indexterm>
<indexterm role="cp"><primary>Fibonacci function, iterative</primary></indexterm>

<para>Here&#8217;s a much faster algorithm for computing the same Fibonacci
series.  It is faster for two reasons.  First, it uses <firstterm>iteration</firstterm>
(that is, repetition or looping) rather than recursion, so it doesn&#8217;t
take time for a large number of function calls.  But mainly, it is
faster because the number of repetitions is small&#8212;only <literal><replaceable>n</replaceable></literal>.
</para>
<!-- If you change this, change the duplicate in node Example of for. -->

<screen>int
fib (int n)
{
  int last = 1;   /* Initial value is <literal>fib (1)</literal>.  */
  int prev = 0;   /* Initial value controls <literal>fib (2)</literal>.  */
  int i;

  for (i = 1; i &lt; n; ++i)
    /* If <literal>n</literal> is 1 or less, the loop runs zero times,  */
    /* since <literal>i &lt; n</literal> is false the first time.  */
    {
      /* Now <literal>last</literal> is <literal>fib (<literal>i</literal>)</literal>
         and <literal>prev</literal> is <literal>fib (<literal>i</literal> &#8722; 1)</literal>.  */
      /* Compute <literal>fib (<literal>i</literal> + 1)</literal>.  */
      int next = prev + last;
      /* Shift the values down.  */
      prev = last;
      last = next;
      /* Now <literal>last</literal> is <literal>fib (<literal>i</literal> + 1)</literal>
         and <literal>prev</literal> is <literal>fib (<literal>i</literal>)</literal>.
         But that won&#8217;t stay true for long,
         because we are about to increment <literal>i</literal>.  */
    }

  return last;
}
</screen>
<para>This definition computes <literal>fib (<replaceable>n</replaceable>)</literal> in a time proportional
to <literal><replaceable>n</replaceable></literal>.  The comments in the definition explain how it works: it
advances through the series, always keeps the last two values in
<literal>last</literal> and <literal>prev</literal>, and adds them to get the next value.
</para>
<para>Here are the additional C features that this definition uses:
</para>
<variablelist><varlistentry><term>Internal blocks
</term><listitem><para>Within a function, wherever a statement is called for, you can write a
<firstterm>block</firstterm>.  It looks like <literal>{ &#8230; }</literal> and contains zero or
more statements and declarations.  (You can also use additional
blocks as statements in a block.)
</para>
<para>The function body also counts as a block, which is why it can contain
statements and declarations.
</para>
<para>See <link linkend="Blocks">Blocks</link>.
</para>
</listitem></varlistentry><varlistentry><term>Declarations of local variables
</term><listitem><para>This function body contains declarations as well as statements.  There
are three declarations directly in the function body, as well as a
fourth declaration in an internal block.  Each starts with <literal>int</literal>
because it declares a variable whose type is integer.  One declaration
can declare several variables, but each of these declarations is
simple and declares just one variable.
</para>
<para>Variables declared inside a block (either a function body or an
internal block) are <firstterm>local variables</firstterm>.  These variables exist only
within that block; their names are not defined outside the block, and
exiting the block deallocates their storage.  This example declares
four local variables: <literal>last</literal>, <literal>prev</literal>, <literal>i</literal>, and
<literal>next</literal>.
</para>
<para>The most basic local variable declaration looks like this:
</para>
<screen><replaceable>type</replaceable> <replaceable>variablename</replaceable>;
</screen>
<para>For instance,
</para>
<screen>int i;
</screen>
<para>declares the local variable <literal>i</literal> as an integer.
See <link linkend="Variable-Declarations">Variable Declarations</link>.
</para>
</listitem></varlistentry><varlistentry><term>Initializers
</term><listitem><para>When you declare a variable, you can also specify its initial value,
like this:
</para>
<screen><replaceable>type</replaceable> <replaceable>variablename</replaceable> = <replaceable>value</replaceable>;
</screen>
<para>For instance,
</para>
<screen>int last = 1;
</screen>
<para>declares the local variable <literal>last</literal> as an integer (type
<literal>int</literal>) and starts it off with the value 1.  See <link linkend="Initializers">Initializers</link>.
</para>
</listitem></varlistentry><varlistentry><term>Assignment
</term><listitem><para>Assignment: a specific kind of expression, written with the &#8216;<literal>=</literal>&#8217;
operator, that stores a new value in a variable or other place.  Thus,
</para>
<screen><replaceable>variable</replaceable> = <replaceable>value</replaceable>
</screen>
<para>is an expression that computes <literal><replaceable>value</replaceable></literal> and stores the value in
<literal><replaceable>variable</replaceable></literal>.  See <link linkend="Assignment-Expressions">Assignment Expressions</link>.
</para>
</listitem></varlistentry><varlistentry><term>Expression statements
</term><listitem><para>An expression statement is an expression followed by a semicolon.
That computes the value of the expression, then ignores the value.
</para>
<para>An expression statement is useful when the expression changes some
data or has other side effects&#8212;for instance, with function calls, or
with assignments as in this example.  See <link linkend="Expression-Statement">Expression Statement</link>.
</para>
<para>Using an expression with no side effects in an expression statement is
pointless except in very special cases.  For instance, the expression
statement <literal>x;</literal> would examine the value of <literal>x</literal> and ignore it.
That is not useful.
</para>
</listitem></varlistentry><varlistentry><term>Increment operator
</term><listitem><para>The increment operator is &#8216;<literal>++</literal>&#8217;.  <literal>++i</literal> is an
expression that is short for <literal>i = i + 1</literal>.
See <link linkend="Increment_002fDecrement">Increment/Decrement</link>.
</para>
</listitem></varlistentry><varlistentry><term><literal>for</literal> statements
</term><listitem><para>A <literal>for</literal> statement is a clean way of executing a statement
repeatedly&#8212;a <firstterm>loop</firstterm> (see <link linkend="Loop-Statements">Loop Statements</link>).  Specifically,
</para>
<screen>for (i = 1; i &lt; n; ++i)
  <replaceable>body</replaceable>
</screen>
<para>means to start by doing <literal>i = 1</literal> (set <literal>i</literal> to one) to prepare
for the loop.  The loop itself consists of
</para>
<itemizedlist><listitem><para>Testing <literal>i &lt; n</literal> and exiting the loop if that&#8217;s false.
</para>
</listitem><listitem><para>Executing <replaceable>body</replaceable>.
</para>
</listitem><listitem><para>Advancing the loop (executing <literal>++i</literal>, which increments <literal>i</literal>).
</para></listitem></itemizedlist>
<para>The net result is to execute <replaceable>body</replaceable> with 0 in <literal>i</literal>,
then with 1 in <literal>i</literal>, and so on, stopping just before the repetition
where <literal>i</literal> would equal <literal>n</literal>.
</para>
<para>The body of the <literal>for</literal> statement must be one and only one
statement.  You can&#8217;t write two statements in a row there; if you try
to, only the first of them will be treated as part of the loop.
</para>
<para>The way to put multiple statements in those places is to group them
with a block, and that&#8217;s what we do in this example.
</para></listitem></varlistentry></variablelist>
</sect1>
</chapter>
<chapter label="2" id="Complete-Program">
<title>A Complete Program</title>
<indexterm role="cp"><primary>complete example program</primary></indexterm>
<indexterm role="cp"><primary>example program, complete</primary></indexterm>

<para>It&#8217;s all very well to write a Fibonacci function, but you cannot run
it by itself.  It is a useful program, but it is not a complete
program.
</para>
<para>In this chapter we present a complete program that contains the
<literal>fib</literal> function.  This example shows how to make the program
start, how to make it finish, how to do computation, and how to print
a result.
</para>

<sect1 label="2.1" id="Complete-Example">
<title>Complete Program Example</title>

<para>Here is the complete program that uses the simple, recursive version
of the <literal>fib</literal> function (see <link linkend="Recursive-Fibonacci">Recursive Fibonacci</link>):
</para>
<screen>#include &lt;stdio.h&gt;

int
fib (int n)
{
  if (n &lt;= 2)  /* This avoids infinite recursion.  */
    return 1;
  else
    return fib (n - 1) + fib (n - 2);
}

int
main (void)
{
  printf (&quot;Fibonacci series item %d is %d\n&quot;,
          20, fib (20));
  return 0;
}
</screen>
<para>This program prints a message that shows the value of <literal>fib (20)</literal>.
</para>
<para>Now for an explanation of what that code means.
</para>
</sect1>
<sect1 label="2.2" id="Complete-Explanation">
<title>Complete Program Explanation</title>

<para>Here&#8217;s the explanation of the code of the example in the
previous section.
</para>
<para>This sample program prints a message that shows the value of <literal>fib
(20)</literal>, and exits with code 0 (which stands for successful execution).
</para>
<para>Every C program is started by running the function named <literal>main</literal>.
Therefore, the example program defines a function named <literal>main</literal> to
provide a way to start it.  Whatever that function does is what the
program does.  See <link linkend="The-main-Function">The main Function</link>.
</para>
<para>The <literal>main</literal> function is the first one called when the program
runs, but it doesn&#8217;t come first in the example code.  The order of the
function definitions in the source code makes no difference to the
program&#8217;s meaning.
</para>
<para>The initial call to <literal>main</literal> always passes certain arguments, but
<literal>main</literal> does not have to pay attention to them.  To ignore those
arguments, define <literal>main</literal> with <literal>void</literal> as the parameter list.
(<literal>void</literal> as a function&#8217;s parameter list normally means &#8220;call with
no arguments,&#8221; but <literal>main</literal> is a special case.)
</para>
<para>The function <literal>main</literal> returns 0 because that is
the conventional way for <literal>main</literal> to indicate successful execution.
It could instead return a positive integer to indicate failure, and
some utility programs have specific conventions for the meaning of
certain numeric <firstterm>failure codes</firstterm>.  See <link linkend="Values-from-main">Values from main</link>.
</para>
<indexterm role="cp"><primary><literal>printf</literal></primary></indexterm>
<para>The simplest way to print text in C is by calling the <literal>printf</literal>
function, so here we explain what that does.
</para>
<indexterm role="cp"><primary>standard output</primary></indexterm>
<para>The first argument to <literal>printf</literal> is a <firstterm>string constant</firstterm>
(see <link linkend="String-Constants">String Constants</link>) that is a template for output.  The
function <literal>printf</literal> copies most of that string directly as output,
including the newline character at the end of the string, which is
written as &#8216;<literal>\n</literal>&#8217;.  The output goes to the program&#8217;s <firstterm>standard
output</firstterm> destination, which in the usual case is the terminal.
</para>
<para>&#8216;<literal>%</literal>&#8217; in the template introduces a code that substitutes other text
into the output.  Specifically, &#8216;<literal>%d</literal>&#8217; means to take the next
argument to <literal>printf</literal> and substitute it into the text as a decimal
number.  (The argument for &#8216;<literal>%d</literal>&#8217; must be of type <literal>int</literal>; if it
isn&#8217;t, <literal>printf</literal> will malfunction.)  So the output is a line that
looks like this:
</para>
<screen>Fibonacci series item 20 is 6765
</screen>
<para>This program does not contain a definition for <literal>printf</literal> because
it is defined by the C library, which makes it available in all C
programs.  However, each program does need to <firstterm>declare</firstterm>
<literal>printf</literal> so it will be called correctly.  The <literal>#include</literal>
line takes care of that; it includes a <firstterm>header file</firstterm> called
<filename>stdio.h</filename> into the program&#8217;s code.  That file is provided by the
operating system and it contains declarations for the many standard
input/output functions in the C library, one of which is
<literal>printf</literal>.
</para>
<para>Don&#8217;t worry about header files for now; we&#8217;ll explain them later in
<link linkend="Header-Files">Header Files</link>.
</para>
<para>The first argument of <literal>printf</literal> does not have to be a string
constant; it can be any string (see <link linkend="Strings">Strings</link>).  However, using a
constant is the most common case.
</para>
<para>To learn more about <literal>printf</literal> and other facilities of the C
library, see section &#8220;The GNU C Library&#8221; in <citetitle>The GNU C Library
Reference Manual</citetitle>.
</para>
</sect1>
<sect1 label="2.3" id="Complete-Line_002dby_002dLine">
<title>Complete Program, Line by Line</title>

<para>Here&#8217;s the same example, explained line by line.
<emphasis role="bold">Beginners, do you find this helpful or not?
Would you prefer a different layout for the example?
Please tell rms@gnu.org.</emphasis>
</para>
<screen>#include &lt;stdio.h&gt;      /* Include declaration of usual */
                        /*   I/O functions such as <literal>printf</literal>.  */
                        /* Most programs need these.  */

int                     /* This function returns an <literal>int</literal>.  */
fib (int n)             /* Its name is <literal>fib</literal>;  */
                        /*   its argument is called <literal>n</literal>.  */
{                       /* Start of function body.  */
  /* This stops the recursion from being infinite.  */
  if (n &lt;= 2)           /* If <literal>n</literal> is 1 or 2,  */
    return 1;           /*   make <literal>fib</literal> return 1.  */
  else                  /* otherwise, add the two previous  */
                        /* fibonacci numbers.  */
    return fib (n - 1) + fib (n - 2);
}

int                     /* This function returns an <literal>int</literal>.  */
main (void)             /* Start here; ignore arguments.  */
{                       /* Print message with numbers in it.  */
  printf (&quot;Fibonacci series item %d is %d\n&quot;,
          20, fib (20));
  return 0;             /* Terminate program, report success.  */
}
</screen>
</sect1>
<sect1 label="2.4" id="Compile-Example">
<title>Compiling the Example Program</title>
<indexterm role="cp"><primary>compiling</primary></indexterm>
<indexterm role="cp"><primary>executable file</primary></indexterm>

<para>To run a C program requires converting the source code into an
<firstterm>executable file</firstterm>.  This is called <firstterm>compiling</firstterm> the program,
and the command to do that using GNU C is <command>gcc</command>.
</para>
<para>This example program consists of a single source file.  If we
call that file <filename>fib1.c</filename>, the complete command to compile it is
this:
</para>
<screen>gcc -g -O -o fib1 fib1.c
</screen>
<para>Here, <option>-g</option> says to generate debugging information, <option>-O</option>
says to optimize at the basic level, and <option>-o fib1</option> says to put
the executable program in the file <filename>fib1</filename>.
</para>
<para>To run the program, use its file name as a shell command.
For instance,
</para>
<screen>./fib1
</screen>
<para>However, unless you are sure the program is correct, you should
expect to need to debug it.  So use this command,
</para>
<screen>gdb fib1
</screen>
<para>which starts the GDB debugger (see section &#8220;A Sample GDB Session&#8221; in <citetitle>Debugging with GDB</citetitle>) so you can run and
debug the executable program <literal>fib1</literal>.
</para>

<para>See <link linkend="Compilation">Compilation</link>, for an introduction to compiling more complex
programs which consist of more than one source file.
</para>
</sect1>
</chapter>
<chapter label="3" id="Storage">
<title>Storage and Data</title>
<indexterm role="cp"><primary>bytes</primary></indexterm>
<indexterm role="cp"><primary>storage organization</primary></indexterm>
<indexterm role="cp"><primary>memory organization</primary></indexterm>

<para>Storage in C programs is made up of units called <firstterm>bytes</firstterm>.  On
nearly all computers, a byte consists of 8 bits, but there are a few
peculiar computers (mostly &#8220;embedded controllers&#8221; for very small
systems) where a byte is longer than that.  This manual does not try
to explain the peculiarity of those computers; we assume that a byte
is 8 bits.
</para>
<para>Every C data type is made up of a certain number of bytes; that number
is the data type&#8217;s <firstterm>size</firstterm>.  See <link linkend="Type-Size">Type Size</link>, for details.  The
types <literal>signed char</literal> and <literal>unsigned char</literal> are one byte long;
use those types to operate on data byte by byte.  See <link linkend="Signed-and-Unsigned-Types">Signed and
Unsigned Types</link>.  You can refer to a series of consecutive bytes as an
array of <literal>char</literal> elements; that&#8217;s what an ASCII string looks like
in memory.  See <link linkend="String-Constants">String Constants</link>.
</para>
</chapter>
<chapter label="4" id="Beyond-Integers">
<title>Beyond Integers</title>

<para>So far we&#8217;ve presented programs that operate on integers.  In this
chapter we&#8217;ll present examples of handling non-integral numbers and
arrays of numbers.
</para>

<sect1 label="4.1" id="Float-Example">
<title>An Example with Non-Integer Numbers</title>
<indexterm role="cp"><primary>floating point example</primary></indexterm>

<para>Here&#8217;s a function that operates on and returns <firstterm>floating point</firstterm>
numbers that don&#8217;t have to be integers.  Floating point represents a
number as a fraction together with a power of 2.  (For more detail,
see <link linkend="Floating_002dPoint-Data-Types">Floating-Point Data Types</link>.)  This example calculates the
average of three floating point numbers that are passed to it as
arguments:
</para>
<screen>double
average_of_three (double a, double b, double c)
{
  return (a + b + c) / 3;
}
</screen>
<para>The values of the parameter <replaceable>a</replaceable>, <replaceable>b</replaceable> and <replaceable>c</replaceable> do not have to be
integers, and even when they happen to be integers, most likely their
average is not an integer.
</para>
<para><literal>double</literal> is the usual data type in C for calculations on
floating-point numbers.
</para>
<para>To print a <literal>double</literal> with <literal>printf</literal>, we must use &#8216;<literal>%f</literal>&#8217;
instead of &#8216;<literal>%d</literal>&#8217;:
</para>
<screen>printf (&quot;Average is %f\n&quot;,
        average_of_three (1.1, 9.8, 3.62));
</screen>
<para>The code that calls <literal>printf</literal> must pass a <literal>double</literal> for
printing with &#8216;<literal>%f</literal>&#8217; and an <literal>int</literal> for printing with &#8216;<literal>%d</literal>&#8217;.
If the argument has the wrong type, <literal>printf</literal> will produce garbage
output.
</para>
<para>Here&#8217;s a complete program that computes the average of three
specific numbers and prints the result:
</para>
<screen>double
average_of_three (double a, double b, double c)
{
  return (a + b + c) / 3;
}

int
main (void)
{
    printf (&quot;Average is %f\n&quot;,
            average_of_three (1.1, 9.8, 3.62));
    return 0;
}
</screen>
<para>From now on we will not present examples of calls to <literal>main</literal>.
Instead we encourage you to write them for yourself when you want
to test executing some code.
</para>
</sect1>
<sect1 label="4.2" id="Array-Example">
<title>An Example with Arrays</title>
<indexterm role="cp"><primary>array example</primary></indexterm>

<para>A function to take the average of three numbers is very specific and
limited.  A more general function would take the average of any number
of numbers.  That requires passing the numbers in an array.  An array
is an object in memory that contains a series of values of the same
data type.  This chapter presents the basic concepts and use of arrays
through an example; for the full explanation, see <link linkend="Arrays">Arrays</link>.
</para>
<para>Here&#8217;s a function definition to take the average of several
floating-point numbers, passed as type <literal>double</literal>.  The first
parameter, <literal>length</literal>, specifies how many numbers are passed.  The
second parameter, <literal>input_data</literal>, is an array that holds those
numbers.
</para>
<screen>double
avg_of_double (int length, double input_data[])
{
  double sum = 0;
  int i;

  for (i = 0; i &lt; length; i++)
    sum = sum + input_data[i];

  return sum / length;
}
</screen>
<para>This introduces the expression to refer to an element of an array:
<literal>input_data[i]</literal> means the element at index <literal>i</literal> in
<literal>input_data</literal>.  The index of the element can be any expression
with an integer value; in this case, the expression is <literal>i</literal>.
See <link linkend="Accessing-Array-Elements">Accessing Array Elements</link>.
</para>
<indexterm role="cp"><primary>zero-origin indexing</primary></indexterm>
<para>The lowest valid index in an array is 0, <emphasis>not</emphasis> 1, and the highest
valid index is one less than the number of elements.  (This is known
as <firstterm>zero-origin indexing</firstterm>.)
</para>
<para>This example also introduces the way to declare that a function
parameter is an array.  Such declarations are modeled after the syntax
for an element of the array.  Just as <literal>double foo</literal> declares that
<literal>foo</literal> is of type <literal>double</literal>, <literal>double input_data[]</literal>
declares that each element of <literal>input_data</literal> is of type
<literal>double</literal>.  Therefore, <literal>input_data</literal> itself has type &#8220;array
of <literal>double</literal>.&#8221;
</para>
<para>When declaring an array parameter, it&#8217;s not necessary to say how long
the array is.  In this case, the parameter <literal>input_data</literal> has no
length information.  That&#8217;s why the function needs another parameter,
<literal>length</literal>, for the caller to provide that information to the
function <literal>avg_of_double</literal>.
</para>
</sect1>
<sect1 label="4.3" id="Array-Example-Call">
<title>Calling the Array Example</title>

<para>To call the function <literal>avg_of_double</literal> requires making an
array and then passing it as an argument.  Here is an example.
</para>
<screen>{
  /* The array of values to average.  */
  double nums_to_average[5];
  /* The average, once we compute it.  */
  double average;

  /* Fill in elements of <literal>nums_to_average</literal>.  */

  nums_to_average[0] = 58.7;
  nums_to_average[1] = 5.1;
  nums_to_average[2] = 7.7;
  nums_to_average[3] = 105.2;
  nums_to_average[4] = -3.14159;

  average = avg_of_double (5, nums_to_average);

  /* &#8230;now make use of <literal>average</literal>&#8230; */
}
</screen>
<para>This shows an array subscripting expression again, this time
on the left side of an assignment, storing a value into an
element of an array.
</para>
<para>It also shows how to declare a local variable that is an array:
<literal>double nums_to_average[5];</literal>.  Since this declaration allocates the
space for the array, it needs to know the array&#8217;s length.  You can
specify the length with any expression whose value is an integer, but
in this declaration the length is a constant, the integer 5.
</para>
<para>The name of the array, when used by itself as an expression, stands
for the address of the array&#8217;s data, and that&#8217;s what gets passed to
the function <literal>avg_of_double</literal> in <literal>avg_of_double (5,
nums_to_average)</literal>.
</para>
<para>We can make the code easier to maintain by avoiding the need to write
5, the array length, when calling <literal>avg_of_double</literal>.  That way, if
we change the array to include more elements, we won&#8217;t have to change
that call.  One way to do this is with the <literal>sizeof</literal> operator:
</para>
<screen>  average = avg_of_double ((sizeof (nums_to_average)
                            / sizeof (nums_to_average[0])),
                           nums_to_average);
</screen>
<para>This computes the number of elements in <literal>nums_to_average</literal> by dividing
its total size by the size of one element.  See <link linkend="Type-Size">Type Size</link>, for more
details of using <literal>sizeof</literal>.
</para>
<para>We don&#8217;t show in this example what happens after storing the result of
<literal>avg_of_double</literal> in the variable <literal>average</literal>.  Presumably
more code would follow that uses that result somehow.  (Why compute
the average and not use it?)  But that isn&#8217;t part of this topic.
</para>
</sect1>
<sect1 label="4.4" id="Array-Example-Variations">
<title>Variations for Array Example</title>

<para>The code to call <literal>avg_of_double</literal> has two declarations that
start with the same data type:
</para>
<screen>  /* The array of values to average.  */
  double nums_to_average[5];
  /* The average, once we compute it.  */
  double average;
</screen>
<para>In C, you can combine the two, like this:
</para>
<screen>  double nums_to_average[5], average;
</screen>
<para>This declares <literal>nums_to_average</literal> so each of its elements is a
<literal>double</literal>, and <literal>average</literal> so that it simply is a
<literal>double</literal>.
</para>
<para>However, while you <emphasis>can</emphasis> combine them, that doesn&#8217;t mean you
<emphasis>should</emphasis>.  If it is useful to write comments about the variables,
and usually it is, then it&#8217;s clearer to keep the declarations separate
so you can put a comment on each one.
</para>
<para>We set all of the elements of the array <literal>nums_to_average</literal> with
assignments, but it is more convenient to use an initializer in the
declaration:
</para>
<screen>{
  /* The array of values to average.  */
  double nums_to_average[]
    = { 58.7, 5.1, 7.7, 105.2, -3.14159 };

  /* The average, once we compute it.  */
  average = avg_of_double ((sizeof (nums_to_average)
                            / sizeof (nums_to_average[0])),
                           nums_to_average);

  /* &#8230;now make use of <literal>average</literal>&#8230; */
}
</screen>
<para>The array initializer is a comma-separated list of values, delimited
by braces.  See <link linkend="Initializers">Initializers</link>.
</para>
<para>Note that the declaration does not specify a size for
<literal>nums_to_average</literal>, so the size is determined from the
initializer.  There are five values in the initializer, so
<literal>nums_to_average</literal> gets length 5.  If we add another element to
the initializer, <literal>nums_to_average</literal> will have six elements.
</para>
<para>Because the code computes the number of elements from the size of
the array, using <literal>sizeof</literal>, the program will operate on all the
elements in the initializer, regardless of how many those are.
</para>
</sect1>
</chapter>
<chapter label="5" id="Lexical-Syntax">
<title>Lexical Syntax</title>
<indexterm role="cp"><primary>lexical syntax</primary></indexterm>
<indexterm role="cp"><primary>token</primary></indexterm>

<para>To start the full description of the C language, we explain the
lexical syntax and lexical units of C code.  The lexical units of a
programming language are known as <firstterm>tokens</firstterm>.  This chapter covers
all the tokens of C except for constants, which are covered in a later
chapter (see <link linkend="Constants">Constants</link>).  One vital kind of token is the
<firstterm>identifier</firstterm> (see <link linkend="Identifiers">Identifiers</link>), which is used for names of any
kind.
</para>

<sect1 label="5.1" id="English">
<title>Write Programs in English!</title>

<para>In principle, you can write the function and variable names in a
program, and the comments, in any human language.  C allows any kinds
of characters in comments, and you can put non-ASCII characters into
identifiers with a special prefix.  However, to enable programmers in
all countries to understand and develop the program, it is best given
today&#8217;s circumstances to write identifiers and comments in
English.
</para>
<para>English is the one language that programmers in all countries
generally study.  If a program&#8217;s names are in English, most
programmers in Bangladesh, Belgium, Bolivia, Brazil, and Bulgaria can
understand them.  Most programmers in those countries can speak
English, or at least read it, but they do not read each other&#8217;s
languages at all.  In India, with so many languages, two programmers
may have no common language other than English.
</para>
<para>If you don&#8217;t feel confident in writing English, do the best you can,
and follow each English comment with a version in a language you
write better; add a note asking others to translate that to English.
Someone will eventually do that.
</para>
<para>The program&#8217;s user interface is a different matter.  We don&#8217;t need to
choose one language for that; it is easy to support multiple languages
and let each user choose the language to use.  This requires writing
the program to support localization of its interface.  (The
<literal>gettext</literal> package exists to support this; see section &#8220;The GNU C Library&#8221; in <citetitle>The GNU C Library Reference
Manual</citetitle>.)  Then a community-based translation effort can provide
support for all the languages users want to use.
</para>
</sect1>
<sect1 label="5.2" id="Characters">
<title>Characters</title>
<indexterm role="cp"><primary>character set</primary></indexterm>
<indexterm role="cp"><primary>Unicode</primary></indexterm>

<!-- ??? How to express ¶? -->

<para>GNU C source files are usually written in the
<ulink url="https://en.wikipedia.org/wiki/ASCII">ASCII</ulink> character set, which
was defined in the 1960s for English.  However, they can also include
Unicode characters represented in the
<ulink url="https://en.wikipedia.org/wiki/UTF-8">UTF-8</ulink> multibyte encoding.
This makes it possible to represent accented letters such as &#8216;<literal>á</literal>&#8217;,
as well as other scripts such as Arabic, Chinese, Cyrillic, Hebrew,
Japanese, and Korean.<footnote><para>On some obscure systems, GNU C uses
UTF-EBCDIC instead of UTF-8, but that is not worth describing in this
manual.</para></footnote>
</para>
<para>In C source code, non-ASCII characters are valid in comments, in wide
character constants (see <link linkend="Wide-Character-Constants">Wide Character Constants</link>), and in string
constants (see <link linkend="String-Constants">String Constants</link>).
</para>
<!-- ??? valid in identifiers? -->
<para>Another way to specify non-ASCII characters in constants (character or
string) and identifiers is with an escape sequence starting with
backslash, specifying the intended Unicode character.  (See <link linkend="Unicode-Character-Codes">Unicode
Character Codes</link>.)  This specifies non-ASCII characters without
putting a real non-ASCII character in the source file itself.
</para>
<para>C accepts two-character aliases called <firstterm>digraphs</firstterm> for certain
characters.  See <link linkend="Digraphs">Digraphs</link>.
</para>
</sect1>
<sect1 label="5.3" id="Whitespace">
<title>Whitespace</title>
<indexterm role="cp"><primary>whitespace characters in source files</primary></indexterm>
<indexterm role="cp"><primary>space character in source</primary></indexterm>
<indexterm role="cp"><primary>tab character in source</primary></indexterm>
<indexterm role="cp"><primary>formfeed in source</primary></indexterm>
<indexterm role="cp"><primary>linefeed in source</primary></indexterm>
<indexterm role="cp"><primary>newline in source</primary></indexterm>
<indexterm role="cp"><primary>carriage return in source</primary></indexterm>
<indexterm role="cp"><primary>vertical tab in source</primary></indexterm>

<para>Whitespace means characters that exist in a file but appear blank in a
printed listing of a file (or traditionally did appear blank, several
decades ago).  The C language requires whitespace in order to separate
two consecutive identifiers, or to separate an identifier from a
numeric constant.  Other than that, and a few special situations
described later, whitespace is optional; you can put it in when you
wish, to make the code easier to read.
</para>
<para>Space and tab in C code are treated as whitespace characters.  So are
line breaks.  You can represent a line break with the newline
character (also called <firstterm>linefeed</firstterm> or LF), CR (carriage return), or
the CRLF sequence (two characters: carriage return followed by a
newline character).
</para>
<para>The <firstterm>formfeed</firstterm> character, Control-L, was traditionally used to
divide a file into pages.  It is still used this way in source code,
and the tools that generate nice printouts of source code still start
a new page after each &#8220;formfeed&#8221; character.  Dividing code into
pages separated by formfeed characters is a good way to break it up
into comprehensible pieces and show other programmers where they start
and end.
</para>
<para>The <firstterm>vertical tab</firstterm> character, Control-K, was traditionally used to
make printing advance down to the next section of a page.  We know of
no particular reason to use it in source code, but it is still
accepted as whitespace in C.
</para>
<para>Comments are also syntactically equivalent to whitespace.
</para>
</sect1>
<sect1 label="5.4" id="Comments">
<title>Comments</title>
<indexterm role="cp"><primary>comments</primary></indexterm>

<para>A comment encapsulates text that has no effect on the program&#8217;s
execution or meaning.
</para>
<para>The purpose of comments is to explain the code to people that read it.
Writing good comments for your code is tremendously important&#8212;they
should provide background information that helps programmers
understand the reasons why the code is written the way it is.  You,
returning to the code six months from now, will need the help of these
comments to remember why you wrote it this way.
</para>
<para>Outdated comments that become incorrect are counterproductive, so part
of the software developer&#8217;s responsibility is to update comments as
needed to correspond with changes to the program code.
</para>
<para>C allows two kinds of comment syntax, the traditional style and the
C<literal>++</literal> style.  A traditional C comment starts with &#8216;<literal>/*</literal>&#8217; and ends
with &#8216;<literal>*/</literal>&#8217;.  For instance,
</para>
<screen>/* This is a comment in traditional C syntax. */
</screen>
<para>A traditional comment can contain &#8216;<literal>/*</literal>&#8217;, but these delimiters do
not nest as pairs.  The first &#8216;<literal>*/</literal>&#8217; ends the comment regardless of
whether it contains &#8216;<literal>/*</literal>&#8217; sequences.
</para>
<screen>/* This /* is a comment */ But this is not! */
</screen>
<para>A <firstterm>line comment</firstterm> starts with &#8216;<literal>//</literal>&#8217; and ends at the end of the line.
For instance,
</para>
<screen>// This is a comment in C<literal>++</literal> style.
</screen>
<para>Line comments do nest, in effect, because &#8216;<literal>//</literal>&#8217; inside a line
comment is part of that comment:
</para>
<screen>// this whole line is // one comment
This is code, not comment.
</screen>
<para>It is safe to put line comments inside block comments, or vice versa.
</para>
<screen>/* traditional comment
   // contains line comment
   more traditional comment
 */ text here is not a comment

// line comment /* contains traditional comment */
</screen>
<para>But beware of commenting out one end of a traditional comment with a line
comment.  The delimiter &#8216;<literal>/*</literal>&#8217; doesn&#8217;t start a comment if it occurs
inside an already-started comment.
</para>
<screen> // line comment  /* That would ordinarily begin a block comment.
    Oops! The line comment has ended;
    this isn't a comment any more.  */
</screen>
<para>Comments are not recognized within string constants.  <literal>&quot;/* blah
*/&quot;<!-- /@w --></literal> is the string constant &#8216;<literal>/* blah */<!-- /@w --></literal>&#8217;, not an empty
string.
</para>
<para>In this manual we show the text in comments in a variable-width font,
for readability, but this font distinction does not exist in source
files.
</para>
<para>A comment is syntactically equivalent to whitespace, so it always
separates tokens.  Thus,
</para>
<screen>  int/* comment */foo;
is equivalent to
  int foo;
</screen>
<para>but clean code always uses real whitespace to separate the comment
visually from surrounding code.
</para>
</sect1>
<sect1 label="5.5" id="Identifiers">
<title>Identifiers</title>
<indexterm role="cp"><primary>identifiers</primary></indexterm>

<para>An <firstterm>identifier</firstterm> (name) in C is a sequence of letters and digits,
as well as &#8216;<literal>_</literal>&#8217;, that does not start with a digit.  Most compilers
also allow &#8216;<literal>$</literal>&#8217;.  An identifier can be as long as you like; for
example,
</para>
<screen>int anti_dis_establishment_arian_ism;
</screen>
<indexterm role="cp"><primary>case of letters in identifiers</primary></indexterm>
<para>Letters in identifiers are case-sensitive in C; thus, <literal>a</literal>
and <literal>A</literal> are two different identifiers.
</para>
<indexterm role="cp"><primary>keyword</primary></indexterm>
<indexterm role="cp"><primary>reserved words</primary></indexterm>
<para>Identifiers in C are used as variable names, function names, typedef
names, enumeration constants, type tags, field names, and labels.
Certain identifiers in C are <firstterm>keywords</firstterm>, which means they have
specific syntactic meanings.  Keywords in C are <firstterm>reserved words</firstterm>,
meaning you cannot use them in any other way.  For instance, you can&#8217;t
define a variable or function named <literal>return</literal> or <literal>if</literal>.
</para>
<para>You can also include other characters, even non-ASCII characters, in
identifiers by writing their Unicode character names, which start with
&#8216;<literal>\u</literal>&#8217; or &#8216;<literal>\U</literal>&#8217;, in the identifier name.  See <link linkend="Unicode-Character-Codes">Unicode
Character Codes</link>.  However, it is usually a bad idea to use non-ASCII
characters in identifiers, and when they are written in English, they
never need non-ASCII characters.  See <link linkend="English">English</link>.
</para>
<para>Whitespace is required to separate two consecutive identifiers, or to
separate an identifier from a preceding or following numeric
constant.
</para>
</sect1>
<sect1 label="5.6" id="Operators_002fPunctuation">
<title>Operators and Punctuation</title>
<indexterm role="cp"><primary>operators</primary></indexterm>
<indexterm role="cp"><primary>punctuation</primary></indexterm>

<para>Here we describe the lexical syntax of operators and punctuation in C.
The specific operators of C and their meanings are presented in
subsequent chapters.
</para>
<para>Most operators in C consist of one or two characters that can&#8217;t be
used in identifiers.  The characters used for operators in C are
&#8216;<literal>!~^&amp;|*/%+-=&lt;&gt;,.?:</literal>&#8217;.
</para>
<para>Some operators are a single character.  For instance, &#8216;<literal>-</literal>&#8217; is the
operator for negation (with one operand) and the operator for
subtraction (with two operands).
</para>
<para>Some operators are two characters.  For example, &#8216;<literal>++</literal>&#8217; is the
increment operator.  Recognition of multicharacter operators works by
grouping together as many consecutive characters as can constitute one
operator.
</para>
<para>For instance, the character sequence &#8216;<literal>++</literal>&#8217; is always interpreted
as the increment operator; therefore, if we want to write two
consecutive instances of the operator &#8216;<literal>+</literal>&#8217;, we must separate them
with a space so that they do not combine as one token.  Applying the
same rule, <literal>a+++++b</literal> is always tokenized as <literal>a++ ++ +
b<!-- /@w --></literal>, not as <literal>a++ + ++b<!-- /@w --></literal>, even though the latter could be part
of a valid C program and the former could not (since <literal>a++</literal>
is not an lvalue and thus can&#8217;t be the operand of <literal>++</literal>).
</para>
<para>A few C operators are keywords rather than special characters.  They
include <literal>sizeof</literal> (see <link linkend="Type-Size">Type Size</link>) and <literal>_Alignof</literal>
(see <link linkend="Type-Alignment">Type Alignment</link>).
</para>
<para>The characters &#8216;<literal>;{}[]()</literal>&#8217; are used for punctuation and grouping.
Semicolon (&#8216;<literal>;</literal>&#8217;) ends a statement.  Braces (&#8216;<literal>{</literal>&#8217; and
&#8216;<literal>}</literal>&#8217;) begin and end a block at the statement level
(see <link linkend="Blocks">Blocks</link>), and surround the initializer (see <link linkend="Initializers">Initializers</link>)
for a variable with multiple elements or components (such as arrays or
structures).
</para>
<para>Square brackets (&#8216;<literal>[</literal>&#8217; and &#8216;<literal>]</literal>&#8217;) do array indexing, as in
<literal>array[5]</literal>.
</para>
<para>Parentheses are used in expressions for explicit nesting of
expressions (see <link linkend="Basic-Arithmetic">Basic Arithmetic</link>), around the parameter
declarations in a function declaration or definition, and around the
arguments in a function call, as in <literal>printf (&quot;Foo %d\n&quot;, i)</literal>
(see <link linkend="Function-Calls">Function Calls</link>).  Several kinds of statements also use
parentheses as part of their syntax&#8212;for instance, <literal>if</literal>
statements, <literal>for</literal> statements, <literal>while</literal> statements, and
<literal>switch</literal> statements.  See <link linkend="if-Statement">if Statement</link>, and following
sections.
</para>
<para>Parentheses are also required around the operand of the operator
keywords <literal>sizeof</literal> and <literal>_Alignof</literal> when the operand is a data
type rather than a value.  See <link linkend="Type-Size">Type Size</link>.
</para>
</sect1>
<sect1 label="5.7" id="Line-Continuation">
<title>Line Continuation</title>
<indexterm role="cp"><primary>line continuation</primary></indexterm>
<indexterm role="cp"><primary>continuation of lines</primary></indexterm>

<para>The sequence of a backslash and a newline is ignored absolutely
anywhere in a C program.  This makes it possible to split a single
source line into multiple lines in the source file.  GNU C tolerates
and ignores other whitespace between the backslash and the newline.
In particular, it always ignores a CR (carriage return) character
there, in case some text editor decided to end the line with the CRLF
sequence.
</para>
<para>The main use of line continuation in C is for macro definitions that
would be inconveniently long for a single line (see <link linkend="Macros">Macros</link>).
</para>
<para>It is possible to continue a line comment onto another line with
backslash-newline.  You can put backslash-newline in the middle of an
identifier, even a keyword, or an operator.  You can even split
&#8216;<literal>/*</literal>&#8217;, &#8216;<literal>*/</literal>&#8217;, and &#8216;<literal>//</literal>&#8217; onto multiple lines with
backslash-newline.  Here&#8217;s an ugly example:
</para>
<screen>/\
*
*/ fo\
o +\
= 1\
0;
</screen>
<para>That&#8217;s equivalent to &#8216;<literal>/* */ foo += 10;</literal>&#8217;.
</para>
<para>Don&#8217;t do those things in real programs, since they make code hard to
read.
</para>
<para><emphasis role="bold">Note:</emphasis> For the sake of using certain tools on the source code, it is
wise to end every source file with a newline character which is not
preceded by a backslash, so that it really ends the last line.
</para>
</sect1>
</chapter>
<chapter label="6" id="Arithmetic">
<title>Arithmetic</title>
<indexterm role="cp"><primary>arithmetic operators</primary></indexterm>
<indexterm role="cp"><primary>operators, arithmetic</primary></indexterm>

<!-- ??? Duplication with other sections - get rid of that? -->

<para>Arithmetic operators in C attempt to be as similar as possible to the
abstract arithmetic operations, but it is impossible to do this
perfectly.  Numbers in a computer have a finite range of possible
values, and non-integer values have a limit on their possible
accuracy.  Nonetheless, in most cases you will encounter no surprises
in using &#8216;<literal>+</literal>&#8217; for addition, &#8216;<literal>-</literal>&#8217; for subtraction, and &#8216;<literal>*</literal>&#8217;
for multiplication.
</para>
<para>Each C operator has a <firstterm>precedence</firstterm>, which is its rank in the
grammatical order of the various operators.  The operators with the
highest precedence grab adjoining operands first; these expressions
then become operands for operators of lower precedence.  We give some
information about precedence of operators in this chapter where we
describe the operators; for the full explanation, see <link linkend="Binary-Operator-Grammar">Binary
Operator Grammar</link>.
</para>
<para>The arithmetic operators always <firstterm>promote</firstterm> their operands before
operating on them.  This means converting narrow integer data types to
a wider data type (see <link linkend="Operand-Promotions">Operand Promotions</link>).  If you are just
learning C, don&#8217;t worry about this yet.
</para>
<para>Given two operands that have different types, most arithmetic
operations convert them both to their <firstterm>common type</firstterm>.  For
instance, if one is <literal>int</literal> and the other is <literal>double</literal>, the
common type is <literal>double</literal>.  (That&#8217;s because <literal>double</literal> can
represent all the values that an <literal>int</literal> can hold, but not vice
versa.)  For the full details, see <link linkend="Common-Type">Common Type</link>.
</para>

<sect1 label="6.1" id="Basic-Arithmetic">
<title>Basic Arithmetic</title>
<indexterm role="cp"><primary>addition operator</primary></indexterm>
<indexterm role="cp"><primary>subtraction operator</primary></indexterm>
<indexterm role="cp"><primary>multiplication operator</primary></indexterm>
<indexterm role="cp"><primary>division operator</primary></indexterm>
<indexterm role="cp"><primary>negation operator</primary></indexterm>
<indexterm role="cp"><primary>operator, addition</primary></indexterm>
<indexterm role="cp"><primary>operator, subtraction</primary></indexterm>
<indexterm role="cp"><primary>operator, multiplication</primary></indexterm>
<indexterm role="cp"><primary>operator, division</primary></indexterm>
<indexterm role="cp"><primary>operator, negation</primary></indexterm>

<para>Basic arithmetic in C is done with the usual binary operators of
algebra: addition (&#8216;<literal>+</literal>&#8217;), subtraction (&#8216;<literal>-</literal>&#8217;), multiplication
(&#8216;<literal>*</literal>&#8217;) and division (&#8216;<literal>/</literal>&#8217;).  The unary operator &#8216;<literal>-</literal>&#8217; is
used to change the sign of a number.  The unary <literal>+</literal> operator also
exists; it yields its operand unaltered.
</para>
<para>&#8216;<literal>/</literal>&#8217; is the division operator, but dividing integers may not give
the result you expect.  Its value is an integer, which is not equal to
the mathematical quotient when that is a fraction.  Use &#8216;<literal>%</literal>&#8217; to
get the corresponding integer remainder when necessary.
See <link linkend="Division-and-Remainder">Division and Remainder</link>.  Floating point division yields value
as close as possible to the mathematical quotient.
</para>
<para>These operators use algebraic syntax with the usual algebraic
precedence rule (see <link linkend="Binary-Operator-Grammar">Binary Operator Grammar</link>) that multiplication
and division are done before addition and subtraction, but you can use
parentheses to explicitly specify how the operators nest.  They are
left-associative (see <link linkend="Associativity-and-Ordering">Associativity and Ordering</link>).  Thus,
</para>
<screen>-a + b - c + d * e / f
</screen>
<para>is equivalent to
</para>
<screen>(((-a) + b) - c) + ((d * e) / f)
</screen>
</sect1>
<sect1 label="6.2" id="Integer-Arithmetic">
<title>Integer Arithmetic</title>
<indexterm role="cp"><primary>integer arithmetic</primary></indexterm>

<para>Each of the basic arithmetic operations in C has two variants for
integers: <firstterm>signed</firstterm> and <firstterm>unsigned</firstterm>.  The choice is determined
by the data types of their operands.
</para>
<para>Each integer data type in C is either <firstterm>signed</firstterm> or <firstterm>unsigned</firstterm>.
A signed type can hold a range of positive and negative numbers, with
zero near the middle of the range.  An unsigned type can hold only
nonnegative numbers; its range starts with zero and runs upward.
</para>
<para>The most basic integer types are <literal>int</literal>, which normally can hold
numbers from &#8722;2,147,483,648 to 2,147,483,647, and <literal>unsigned
int</literal>, which normally can hold numbers from 0 to 4,294.967,295.  (This
assumes <literal>int</literal> is 32 bits wide, always true for GNU C on real
computers but not always on embedded controllers.)  See <link linkend="Integer-Types">Integer
Types</link>, for full information about integer types.
</para>
<para>When a basic arithmetic operation is given two signed operands, it
does signed arithmetic.  Given two unsigned operands, it does
unsigned arithmetic.
</para>
<para>If one operand is <literal>unsigned int</literal> and the other is <literal>int</literal>, the
operator treats them both as unsigned.  More generally, the common
type of the operands determines whether the operation is signed or
not.  See <link linkend="Common-Type">Common Type</link>.
</para>
<para>Printing the results of unsigned arithmetic with <literal>printf</literal> using
&#8216;<literal>%d</literal>&#8217; can produce surprising results for values far away from
zero.  Even though the rules above say that the computation was done
with unsigned arithmetic, the printed result may appear to be signed!
</para>
<para>The explanation is that the bit pattern resulting from addition,
subtraction or multiplication is actually the same for signed and
unsigned operations.  The difference is only in the data type of the
result, which affects the <emphasis>interpretation</emphasis> of the result bit pattern,
and whether the arithmetic operation can overflow (see the next section).
</para>
<para>But &#8216;<literal>%d</literal>&#8217; doesn&#8217;t know its argument&#8217;s data type.  It sees only the
value&#8217;s bit pattern, and it is defined to interpret that as
<literal>signed int</literal>.  To print it as unsigned requires using &#8216;<literal>%u</literal>&#8217;
instead of &#8216;<literal>%d</literal>&#8217;.  See section &#8220;The GNU C Library&#8221; in <citetitle>The GNU C Library Reference Manual</citetitle>.
</para>
<para>Arithmetic in C never operates directly on narrow integer types (those
with fewer bits than <literal>int</literal>; <link linkend="Narrow-Integers">Narrow Integers</link>).  Instead it
&#8220;promotes&#8221; them to <literal>int</literal>.  See <link linkend="Operand-Promotions">Operand Promotions</link>.
</para>
</sect1>
<sect1 label="6.3" id="Integer-Overflow">
<title>Integer Overflow</title>
<indexterm role="cp"><primary>integer overflow</primary></indexterm>
<indexterm role="cp"><primary>overflow, integer</primary></indexterm>

<para>When the mathematical value of an arithmetic operation doesn&#8217;t fit in
the range of the data type in use, that&#8217;s called <firstterm>overflow</firstterm>.
When it happens in integer arithmetic, it is <firstterm>integer overflow</firstterm>.
</para>
<para>Integer overflow happens only in arithmetic operations.  Type conversion
operations, by definition, do not cause overflow, not even when the
result can&#8217;t fit in its new type.  See <link linkend="Integer-Conversion">Integer Conversion</link>.
</para>
<para>Signed numbers use two&#8217;s-complement representation, in which the most
negative number lacks a positive counterpart (see <link linkend="Integers-in-Depth">Integers in
Depth</link>).  Thus, the unary &#8216;<literal>-</literal>&#8217; operator on a signed integer can
overflow.
</para>

<sect2 label="6.3.1" id="Unsigned-Overflow">
<title>Overflow with Unsigned Integers</title>

<para>Unsigned arithmetic in C ignores overflow; it produces the true result
modulo the <replaceable>n</replaceable>th power of 2, where <replaceable>n</replaceable> is the number of bits
in the data type.  We say it &#8220;truncates&#8221; the true result to the
lowest <replaceable>n</replaceable> bits.
</para>
<para>A true result that is negative, when taken modulo the <replaceable>n</replaceable>th power
of 2, yields a positive number.  For instance,
</para>
<screen>unsigned int x = 1;
unsigned int y;

y = -x;
</screen>
<para>causes overflow because the negative number &#8722;1 can&#8217;t be stored
in an unsigned type.  The actual result, which is &#8722;1 modulo the
<replaceable>n</replaceable>th power of 2, is one less than the <replaceable>n</replaceable>th power of 2.  That
is the largest value that the unsigned data type can store.  For a
32-bit <literal>unsigned int</literal>, the value is 4,294,967,295.  See <link linkend="Maximum-and-Minimum-Values">Maximum
and Minimum Values</link>.
</para>
<para>Adding that number to itself, as here,
</para>
<screen>unsigned int z;

z = y + y;
</screen>
<para>ought to yield 8,489,934,590; however, that is again too large to fit,
so overflow truncates the value to 4,294,967,294.  If that were a
signed integer, it would mean &#8722;2, which (not by coincidence)
equals &#8722;1 + &#8722;1.
</para>
</sect2>
<sect2 label="6.3.2" id="Signed-Overflow">
<title>Overflow with Signed Integers</title>
<indexterm role="cp"><primary>compiler options for integer overflow</primary></indexterm>
<indexterm role="cp"><primary>integer overflow, compiler options</primary></indexterm>
<indexterm role="cp"><primary>overflow, compiler options</primary></indexterm>

<para>For signed integers, the result of overflow in C is <emphasis>in
principle</emphasis> undefined, meaning that anything whatsoever could happen.
Therefore, C compilers can do optimizations that treat the overflow
case with total unconcern.  (Since the result of overflow is undefined
in principle, one cannot claim that these optimizations are
erroneous.)
</para>
<para><emphasis role="bold">Watch out:</emphasis> These optimizations can do surprising things.  For
instance,
</para>
<screen>int i;
&#8230;
if (i &lt; i + 1)
  x = 5;
</screen>
<para>could be optimized to do the assignment unconditionally, because the
<literal>if</literal>-condition is always true if <literal>i + 1</literal> does not overflow.
</para>
<para>GCC offers compiler options to control handling signed integer
overflow.  These options operate per module; that is, each module
behaves according to the options it was compiled with.
</para>
<para>These two options specify particular ways to handle signed integer
overflow, other than the default way:
</para>
<variablelist><varlistentry><term><option>-fwrapv</option>
</term><listitem><para>Make signed integer operations well-defined, like unsigned integer
operations: they produce the <replaceable>n</replaceable> low-order bits of the true
result.  The highest of those <replaceable>n</replaceable> bits is the sign bit of the
result.  With <option>-fwrapv</option>, these out-of-range operations are not
considered overflow, so (strictly speaking) integer overflow never
happens.
</para>
<para>The option <option>-fwrapv</option> enables some optimizations based on the
defined values of out-of-range results.  In GCC 8, it disables
optimizations that are based on assuming signed integer operations
will not overflow.
</para>
</listitem></varlistentry><varlistentry><term><option>-ftrapv</option>
</term><listitem><para>Generate a signal <literal>SIGFPE</literal> when signed integer overflow occurs.
This terminates the program unless the program handles the signal.
See <link linkend="Signals">Signals</link>.
</para></listitem></varlistentry></variablelist>
<para>One other option is useful for finding where overflow occurs:
</para>

<variablelist><varlistentry><term><option>-fsanitize=signed-integer-overflow</option>
</term><listitem><para>Output a warning message at run time when signed integer overflow
occurs.  This checks the &#8216;<literal>+</literal>&#8217;, &#8216;<literal>*</literal>&#8217;, and &#8216;<literal>-</literal>&#8217; operators.
This takes priority over <option>-ftrapv</option>.
</para></listitem></varlistentry></variablelist>
</sect2>
</sect1>
<sect1 label="6.4" id="Mixed-Mode">
<title>Mixed-Mode Arithmetic</title>

<para>Mixing integers and floating-point numbers in a basic arithmetic
operation converts the integers automatically to floating point.
In most cases, this gives exactly the desired results.
But sometimes it matters precisely where the conversion occurs.
</para>
<para>If <literal>i</literal> and <literal>j</literal> are integers, <literal>(i + j) * 2.0</literal> adds them
as an integer, then converts the sum to floating point for the
multiplication.  If the addition gets an overflow, that is not
equivalent to converting both integers to floating point and then
adding them.  You can get the latter result by explicitly converting
the integers, as in <literal>((double) i + (double) j) * 2.0</literal>.
See <link linkend="Explicit-Type-Conversion">Explicit Type Conversion</link>.
</para>
<!-- Eggert's report -->
<para>Adding or multiplying several values, including some integers and some
floating point, does the operations left to right.  Thus, <literal>3.0 +
i + j</literal> converts <literal>i</literal> to floating point, then adds 3.0, then
converts <literal>j</literal> to floating point and adds that.  You can specify a
different order using parentheses: <literal>3.0 + (i + j)</literal> adds <literal>i</literal>
and <literal>j</literal> first and then adds that result (converting to floating
point) to 3.0.  In this respect, C differs from other languages, such
as Fortran.
</para>
</sect1>
<sect1 label="6.5" id="Division-and-Remainder">
<title>Division and Remainder</title>
<indexterm role="cp"><primary>remainder operator</primary></indexterm>
<indexterm role="cp"><primary>modulus</primary></indexterm>
<indexterm role="cp"><primary>operator, remainder</primary></indexterm>

<para>Division of integers in C rounds the result to an integer.  The result
is always rounded towards zero.
</para>
<screen> 16 / 3  &#8658; 5
-16 / 3  &#8658; -5
 16 / -3 &#8658; -5
-16 / -3 &#8658; 5
</screen>
<para>To get the corresponding remainder, use the &#8216;<literal>%</literal>&#8217; operator:
</para>
<screen> 16 % 3  &#8658; 1
-16 % 3  &#8658; -1
 16 % -3 &#8658; 1
-16 % -3 &#8658; -1
</screen>
<para>&#8216;<literal>%</literal>&#8217; has the same operator precedence as &#8216;<literal>/</literal>&#8217; and &#8216;<literal>*</literal>&#8217;.
</para>
<para>From the rounded quotient and the remainder, you can reconstruct
the dividend, like this:
</para>
<screen>int
original_dividend (int divisor, int quotient, int remainder)
{
  return divisor * quotient + remainder;
}
</screen>
<para>To do unrounded division, use floating point.  If only one operand is
floating point, &#8216;<literal>/</literal>&#8217; converts the other operand to floating
point.
</para>
<screen>16.0 / 3   &#8658; 5.333333333333333
16   / 3.0 &#8658; 5.333333333333333
16.0 / 3.0 &#8658; 5.333333333333333
16   / 3   &#8658; 5
</screen>
<para>The remainder operator &#8216;<literal>%</literal>&#8217; is not allowed for floating-point
operands, because it is not needed.  The concept of remainder makes
sense for integers because the result of division of integers has to
be an integer.  For floating point, the result of division is a
floating-point number, in other words a fraction, which will differ
from the exact result only by a very small amount.
</para>
<para>There are functions in the standard C library to calculate remainders
from integral-values division of floating-point numbers.
See section &#8220;The GNU C Library&#8221; in <citetitle>The GNU C Library
Reference Manual</citetitle>.
</para>
<para>Integer division overflows in one specific case: dividing the smallest
negative value for the data type (see <link linkend="Maximum-and-Minimum-Values">Maximum and Minimum Values</link>)
by &#8722;1.  That&#8217;s because the correct result, which is the
corresponding positive number, does not fit (see <link linkend="Integer-Overflow">Integer Overflow</link>)
in the same number of bits.  On some computers now in use, this always
causes a signal <literal>SIGFPE</literal> (see <link linkend="Signals">Signals</link>), the same behavior
that the option <option>-ftrapv</option> specifies (see <link linkend="Signed-Overflow">Signed Overflow</link>).
</para>
<para>Division by zero leads to unpredictable results&#8212;depending on the
type of computer, it might cause a signal <literal>SIGFPE</literal>, or it might
produce a numeric result.
</para>
<indexterm role="cp"><primary>division by zero</primary></indexterm>
<indexterm role="cp"><primary>zero, division by</primary></indexterm>
<para><emphasis role="bold">Watch out:</emphasis> Make sure the program does not divide by zero.  If
you can&#8217;t prove that the divisor is not zero, test whether it is zero,
and skip the division if so.
</para>
</sect1>
<sect1 label="6.6" id="Numeric-Comparisons">
<title>Numeric Comparisons</title>
<indexterm role="cp"><primary>numeric comparisons</primary></indexterm>
<indexterm role="cp"><primary>comparisons</primary></indexterm>
<indexterm role="cp"><primary>operators, comparison</primary></indexterm>
<indexterm role="cp"><primary>equal operator</primary></indexterm>
<indexterm role="cp"><primary>not-equal operator</primary></indexterm>
<indexterm role="cp"><primary>less-than operator</primary></indexterm>
<indexterm role="cp"><primary>greater-than operator</primary></indexterm>
<indexterm role="cp"><primary>less-or-equal operator</primary></indexterm>
<indexterm role="cp"><primary>greater-or-equal operator</primary></indexterm>
<indexterm role="cp"><primary>operator, equal</primary></indexterm>
<indexterm role="cp"><primary>operator, not-equal</primary></indexterm>
<indexterm role="cp"><primary>operator, less-than</primary></indexterm>
<indexterm role="cp"><primary>operator, greater-than</primary></indexterm>
<indexterm role="cp"><primary>operator, less-or-equal</primary></indexterm>
<indexterm role="cp"><primary>operator, greater-or-equal</primary></indexterm>
<indexterm role="cp"><primary>truth value</primary></indexterm>

<para>There are two kinds of comparison operators: <firstterm>equality</firstterm> and
<firstterm>ordering</firstterm>.  Equality comparisons test whether two expressions
have the same value.  The result is a <firstterm>truth value</firstterm>: a number that
is 1 for &#8220;true&#8221; and 0 for &#8220;false.&#8221;
</para>
<screen>a == b   /* Test for equal.  */
a != b   /* Test for not equal.  */
</screen>
<para>The equality comparison is written <literal>==</literal> because plain <literal>=</literal>
is the assignment operator.
</para>
<para>Ordering comparisons test which operand is greater or less.  Their
results are truth values.  These are the ordering comparisons of C:
</para>
<screen>a &lt; b   /* Test for less-than.  */
a &gt; b   /* Test for greater-than.  */
a &lt;= b  /* Test for less-than-or-equal.  */
a &gt;= b  /* Test for greater-than-or-equal.  */
</screen>
<para>For any integers <literal>a</literal> and <literal>b</literal>, exactly one of the comparisons
<literal>a &lt; b</literal>, <literal>a == b</literal> and <literal>a &gt; b</literal> is true, just as in
mathematics.  However, if <literal>a</literal> and <literal>b</literal> are special floating
point values (not ordinary numbers), all three can be false.
See <link linkend="Special-Float-Values">Special Float Values</link>, and <link linkend="Invalid-Optimizations">Invalid Optimizations</link>.
</para>
</sect1>
<sect1 label="6.7" id="Shift-Operations">
<title>Shift Operations</title>
<indexterm role="cp"><primary>shift operators</primary></indexterm>
<indexterm role="cp"><primary>operators, shift</primary></indexterm>
<indexterm role="cp"><primary>operators, shift</primary></indexterm>
<indexterm role="cp"><primary>shift count</primary></indexterm>

<para><firstterm>Shifting</firstterm> an integer means moving the bit values to the left or
right within the bits of the data type.  Shifting is defined only for
integers.  Here&#8217;s the way to write it:
</para>
<screen>/* Left shift.  */
5 &lt;&lt; 2 &#8658; 20

/* Right shift.  */
5 &gt;&gt; 2 &#8658; 1
</screen>
<para>The left operand is the value to be shifted, and the right operand
says how many bits to shift it (the <firstterm>shift count</firstterm>).  The left
operand is promoted (see <link linkend="Operand-Promotions">Operand Promotions</link>), so shifting never
operates on a narrow integer type; it&#8217;s always either <literal>int</literal> or
wider.  The value of the shift operator has the same type as the
promoted left operand.
</para>

<sect2 label="6.7.1" id="Bits-Shifted-In">
<title>Shifting Makes New Bits</title>

<para>A shift operation shifts towards one end of the number and has to
generate new bits at the other end.
</para>
<para>Shifting left one bit must generate a new least significant bit.  It
always brings in zero there.  It is equivalent to multiplying by the
appropriate power of 2.  For example,
</para>
<screen>5 &lt;&lt; 3     is equivalent to   5 * 2*2*2
-10 &lt;&lt; 4   is equivalent to   -10 * 2*2*2*2
</screen>
<para>The meaning of shifting right depends on whether the data type is
signed or unsigned (see <link linkend="Signed-and-Unsigned-Types">Signed and Unsigned Types</link>).  For a signed
data type, it performs &#8220;arithmetic shift,&#8221; which keeps the number&#8217;s
sign unchanged by duplicating the sign bit.  For an unsigned data
type, it performs &#8220;logical shift,&#8221; which always shifts in zeros at
the most significant bit.
</para>
<para>In both cases, shifting right one bit is division by two, rounding
towards negative infinity.  For example,
</para>
<screen>(unsigned) 19 &gt;&gt; 2 &#8658; 4
(unsigned) 20 &gt;&gt; 2 &#8658; 5
(unsigned) 21 &gt;&gt; 2 &#8658; 5
</screen>
<para>For negative left operand <literal>a</literal>, <literal>a &gt;&gt; 1</literal> is not equivalent to
<literal>a / 2</literal>.  They both divide by 2, but &#8216;<literal>/</literal>&#8217; rounds toward
zero.
</para>
<para>The shift count must be zero or greater.  Shifting by a negative
number of bits gives machine-dependent results.
</para>
</sect2>
<sect2 label="6.7.2" id="Shift-Caveats">
<title>Caveats for Shift Operations</title>

<para><emphasis role="bold">Warning:</emphasis> If the shift count is greater than or equal to the
width in bits of the first operand, the results are machine-dependent.
Logically speaking, the &#8220;correct&#8221; value would be either -1 (for
right shift of a negative number) or 0 (in all other cases), but what
it really generates is whatever the machine&#8217;s shift instruction does in
that case.  So unless you can prove that the second operand is not too
large, write code to check it at run time.
</para>
<para><emphasis role="bold">Warning:</emphasis> Never rely on how the shift operators relate in
precedence to other arithmetic binary operators.  Programmers don&#8217;t
remember these precedences, and won&#8217;t understand the code.  Always use
parentheses to explicitly specify the nesting, like this:
</para>
<screen>a + (b &lt;&lt; 5)   /* Shift first, then add.  */
(a + b) &lt;&lt; 5   /* Add first, then shift.  */
</screen>
<para>Note: according to the C standard, shifting of signed values isn&#8217;t
guaranteed to work properly when the value shifted is negative, or
becomes negative during the operation of shifting left.  However, only
pedants have a reason to be concerned about this; only computers with
strange shift instructions could plausibly do this wrong.  In GNU C,
the operation always works as expected,
</para>
</sect2>
<sect2 label="6.7.3" id="Shift-Hacks">
<title>Shift Hacks</title>

<para>You can use the shift operators for various useful hacks.  For
example, given a date specified by day of the month <literal>d</literal>, month
<literal>m</literal>, and year <literal>y</literal>, you can store the entire date in a single
integer <literal>date</literal>:
</para>
<screen>unsigned int d = 12;
unsigned int m = 6;
unsigned int y = 1983;
unsigned int date = ((y &lt;&lt; 4) + m) &lt;&lt; 5) + d;
</screen>
<para>To extract the original day, month, and year out of
<literal>date</literal>, use a combination of shift and remainder.
</para>
<screen>d = date % 32;
m = (date &gt;&gt; 5) % 16;
y = date &gt;&gt; 9;
</screen>
<para><literal>-1 &lt;&lt; LOWBITS</literal> is a clever way to make an integer whose
<literal>LOWBITS</literal> lowest bits are all 0 and the rest are all 1.
<literal>-(1 &lt;&lt; LOWBITS)</literal> is equivalent to that, due to associativity of
multiplication, since negating a value is equivalent to multiplying it
by &#8722;1.
</para>
</sect2>
</sect1>
<sect1 label="6.8" id="Bitwise-Operations">
<title>Bitwise Operations</title>
<indexterm role="cp"><primary>bitwise operators</primary></indexterm>
<indexterm role="cp"><primary>operators, bitwise</primary></indexterm>
<indexterm role="cp"><primary>negation, bitwise</primary></indexterm>
<indexterm role="cp"><primary>conjunction, bitwise</primary></indexterm>
<indexterm role="cp"><primary>disjunction, bitwise</primary></indexterm>

<para>Bitwise operators operate on integers, treating each bit independently.
They are not allowed for floating-point types.
</para>
<para>The examples in this section use binary constants, starting with
&#8216;<literal>0b</literal>&#8217; (see <link linkend="Integer-Constants">Integer Constants</link>).  They stand for 32-bit integers
of type <literal>int</literal>.
</para>
<variablelist><varlistentry><term><literal>~<literal>a</literal></literal>
</term><listitem><para>Unary operator for bitwise negation; this changes each bit of
<literal>a</literal> from 1 to 0 or from 0 to 1.
</para>
<screen>~0b10101000 &#8658; 0b11111111111111111111111101010111
~0 &#8658; 0b11111111111111111111111111111111
~0b11111111111111111111111111111111 &#8658; 0
~ (-1) &#8658; 0
</screen>
<para>It is useful to remember that <literal>~<replaceable>x</replaceable> + 1</literal> equals
<literal>-<replaceable>x</replaceable></literal>, for integers, and <literal>~<replaceable>x</replaceable></literal> equals
<literal>-<replaceable>x</replaceable> - 1</literal>.  The last example above shows this with &#8722;1
as <replaceable>x</replaceable>.
</para>
</listitem></varlistentry><varlistentry><term><literal><literal>a</literal> &amp; <literal>b</literal></literal>
</term><listitem><para>Binary operator for bitwise &#8220;and&#8221; or &#8220;conjunction.&#8221;  Each bit in
the result is 1 if that bit is 1 in both <literal>a</literal> and <literal>b</literal>.
</para>
<screen>0b10101010 &amp; 0b11001100 &#8658; 0b10001000
</screen>
</listitem></varlistentry><varlistentry><term><literal><literal>a</literal> | <literal>b</literal></literal>
</term><listitem><para>Binary operator for bitwise &#8220;or&#8221; (&#8220;inclusive or&#8221; or
&#8220;disjunction&#8221;).  Each bit in the result is 1 if that bit is 1 in
either <literal>a</literal> or <literal>b</literal>.
</para>
<screen>0b10101010 | 0b11001100 &#8658; 0b11101110
</screen>
</listitem></varlistentry><varlistentry><term><literal><literal>a</literal> ^ <literal>b</literal></literal>
</term><listitem><para>Binary operator for bitwise &#8220;xor&#8221; (&#8220;exclusive or&#8221;).  Each bit in
the result is 1 if that bit is 1 in exactly one of <literal>a</literal> and <literal>b</literal>.
</para>
<screen>0b10101010 ^ 0b11001100 &#8658; 0b01100110
</screen></listitem></varlistentry></variablelist>
<para>To understand the effect of these operators on signed integers, keep
in mind that all modern computers use two&#8217;s-complement representation
(see <link linkend="Integer-Representations">Integer Representations</link>) for negative integers.  This means
that the highest bit of the number indicates the sign; it is 1 for a
negative number and 0 for a positive number.  In a negative number,
the value in the other bits <emphasis>increases</emphasis> as the number gets closer
to zero, so that <literal>0b111&#8230;111</literal> is &#8722;1 and
<literal>0b100&#8230;000</literal> is the most negative possible integer.
</para>
<para><emphasis role="bold">Warning:</emphasis> C defines a precedence ordering for the bitwise
binary operators, but you should never rely on it.   You should
never rely on how bitwise binary operators relate in precedence to the
arithmetic and shift binary operators.  Other programmers don&#8217;t
remember this precedence ordering, so always use parentheses to
explicitly specify the nesting.
</para>
<para>For example, suppose <literal>offset</literal> is an integer that specifies
the offset within shared memory of a table, except that its bottom few
bits (<literal>LOWBITS</literal> says how many) are special flags.  Here&#8217;s
how to get just that offset and add it to the base address.
</para>
<screen>shared_mem_base + (offset &amp; (-1 &lt;&lt; LOWBITS))
</screen>
<para>Thanks to the outer set of parentheses, we don&#8217;t need to know whether
&#8216;<literal>&amp;</literal>&#8217; has higher precedence than &#8216;<literal>+</literal>&#8217;.  Thanks to the inner
set, we don&#8217;t need to know whether &#8216;<literal>&amp;</literal>&#8217; has higher precedence than
&#8216;<literal>&lt;&lt;</literal>&#8217;.  But we can rely on all unary operators to have higher
precedence than any binary operator, so we don&#8217;t need parentheses
around the left operand of &#8216;<literal>&lt;&lt;</literal>&#8217;.
</para>
</sect1>
</chapter>
<chapter label="7" id="Assignment-Expressions">
<title>Assignment Expressions</title>
<indexterm role="cp"><primary>assignment expressions</primary></indexterm>
<indexterm role="cp"><primary>operators, assignment</primary></indexterm>

<para>As a general concept in programming, an <firstterm>assignment</firstterm> is a
construct that stores a new value into a place where values can be
stored&#8212;for instance, in a variable.  Such places are called
<firstterm>lvalues</firstterm> (see <link linkend="Lvalues">Lvalues</link>) because they are locations that hold a value.
</para>
<para>An assignment in C is an expression because it has a value; we call
it an <firstterm>assignment expression</firstterm>.  A simple assignment looks like
</para>
<screen><replaceable>lvalue</replaceable> = <replaceable>value-to-store</replaceable>
</screen>
<para>We say it assigns the value of the expression <replaceable>value-to-store</replaceable> to
the location <replaceable>lvalue</replaceable>, or that it stores <replaceable>value-to-store</replaceable>
there.  You can think of the &#8220;l&#8221; in &#8220;lvalue&#8221; as standing for
&#8220;left,&#8221; since that&#8217;s what you put on the left side of the assignment
operator.
</para>
<para>However, that&#8217;s not the only way to use an lvalue, and not all lvalues
can be assigned to.  To use the lvalue in the left side of an
assignment, it has to be <firstterm>modifiable</firstterm>.  In C, that means it was
not declared with the type qualifier <literal>const</literal> (see <link linkend="const">const</link>).
</para>
<para>The value of the assignment expression is that of <replaceable>lvalue</replaceable> after
the new value is stored in it.  This means you can use an assignment
inside other expressions.  Assignment operators are right-associative
so that
</para>
<screen>x = y = z = 0;
</screen>
<para>is equivalent to
</para>
<screen>x = (y = (z = 0));
</screen>
<para>This is the only useful way for them to associate;
the other way,
</para>
<screen>((x = y) = z) = 0;
</screen>
<para>would be invalid since an assignment expression such as <literal>x = y</literal>
is not valid as an lvalue.
</para>
<para><emphasis role="bold">Warning:</emphasis> Write parentheses around an assignment if you nest
it inside another expression, unless that is a conditional expression,
or comma-separated series, or another assignment.
</para>

<sect1 label="7.1" id="Simple-Assignment">
<title>Simple Assignment</title>
<indexterm role="cp"><primary>simple assignment</primary></indexterm>
<indexterm role="cp"><primary>assignment, simple</primary></indexterm>

<para>A <firstterm>simple assignment expression</firstterm> computes the value of the right
operand and stores it into the lvalue on the left.  Here is a simple
assignment expression that stores 5 in <literal>i</literal>:
</para>
<screen>i = 5
</screen>
<para>We say that this is an <firstterm>assignment to</firstterm> the variable <literal>i</literal> and
that it <firstterm>assigns</firstterm> <literal>i</literal> the value 5.  It has no semicolon
because it is an expression (so it has a value).  Adding a semicolon
at the end would make it a statement (see <link linkend="Expression-Statement">Expression Statement</link>).
</para>
<para>Here is another example of a simple assignment expression.  Its
operands are not simple, but the kind of assignment done here is
simple assignment.
</para>
<screen>x[foo ()] = y + 6
</screen>
<para>A simple assignment with two different numeric data types converts the
right operand value to the lvalue&#8217;s type, if possible.  It can convert
any numeric type to any other numeric type.
</para>
<para>Simple assignment is also allowed on some non-numeric types: pointers
(see <link linkend="Pointers">Pointers</link>), structures (see <link linkend="Structure-Assignment">Structure Assignment</link>), and
unions (see <link linkend="Unions">Unions</link>).
</para>
<para><emphasis role="bold">Warning:</emphasis> Assignment is not allowed on arrays because
there are no array values in C; C variables can be arrays, but these
arrays cannot be manipulated as wholes.  See <link linkend="Limitations-of-C-Arrays">Limitations of C
Arrays</link>.
</para>
<para>See <link linkend="Assignment-Type-Conversions">Assignment Type Conversions</link>, for the complete rules about data
types used in assignments.
</para>
</sect1>
<sect1 label="7.2" id="Lvalues">
<title>Lvalues</title>
<indexterm role="cp"><primary>lvalues</primary></indexterm>

<para>An expression that identifies a memory space that holds a value is
called an <firstterm>lvalue</firstterm>, because it is a location that can hold a value.
</para>
<para>The standard kinds of lvalues are:
</para>
<itemizedlist><listitem><para>A variable.
</para>
</listitem><listitem><para>A pointer-dereference expression (see <link linkend="Pointer-Dereference">Pointer Dereference</link>) using
unary &#8216;<literal>*</literal>&#8217;.
</para>
</listitem><listitem><para>A structure field reference (see <link linkend="Structures">Structures</link>) using &#8216;<literal>.</literal>&#8217;, if
the structure value is an lvalue.
</para>
</listitem><listitem><para>A structure field reference using &#8216;<literal>-&gt;</literal>&#8217;.  This is always an lvalue
since &#8216;<literal>-&gt;</literal>&#8217; implies pointer dereference.
</para>
</listitem><listitem><para>A union alternative reference (see <link linkend="Unions">Unions</link>), on the same conditions
as for structure fields.
</para>
</listitem><listitem><para>An array-element reference using &#8216;<literal>[&#8230;]</literal>&#8217;, if the array
is an lvalue.
</para></listitem></itemizedlist>
<para>If an expression&#8217;s outermost operation is any other operator, that
expression is not an lvalue.  Thus, the variable <literal>x</literal> is an
lvalue, but <literal>x + 0</literal> is not, even though these two expressions
compute the same value (assuming <literal>x</literal> is a number).
</para>
<para>An array can be an lvalue (the rules above determine whether it is
one), but using the array in an expression converts it automatically
to a pointer to the first element.  The result of this conversion is
not an lvalue.  Thus, if the variable <literal>a</literal> is an array, you can&#8217;t
use <literal>a</literal> by itself as the left operand of an assignment.  But you
can assign to an element of <literal>a</literal>, such as <literal>a[0]</literal>.  That is an
lvalue since <literal>a</literal> is an lvalue.
</para>
</sect1>
<sect1 label="7.3" id="Modifying-Assignment">
<title>Modifying Assignment</title>
<indexterm role="cp"><primary>modifying assignment</primary></indexterm>
<indexterm role="cp"><primary>assignment, modifying</primary></indexterm>

<para>You can abbreviate the common construct
</para>
<screen><replaceable>lvalue</replaceable> = <replaceable>lvalue</replaceable> + <replaceable>expression</replaceable>
</screen>
<para>as
</para>
<screen><replaceable>lvalue</replaceable> += <replaceable>expression</replaceable>
</screen>
<para>This is known as a <firstterm>modifying assignment</firstterm>.  For instance,
</para>
<screen>i = i + 5;
i += 5;
</screen>
<para>shows two statements that are equivalent.  The first uses
simple assignment; the second uses modifying assignment.
</para>
<para>Modifying assignment works with any binary arithmetic operator.  For
instance, you can subtract something from an lvalue like this,
</para>
<screen><replaceable>lvalue</replaceable> -= <replaceable>expression</replaceable>
</screen>
<para>or multiply it by a certain amount like this,
</para>
<screen><replaceable>lvalue</replaceable> *= <replaceable>expression</replaceable>
</screen>
<para>or shift it by a certain amount like this.
</para>
<screen><replaceable>lvalue</replaceable> &lt;&lt;= <replaceable>expression</replaceable>
<replaceable>lvalue</replaceable> &gt;&gt;= <replaceable>expression</replaceable>
</screen>
<para>In most cases, this feature adds no power to the language, but it
provides substantial convenience.  Also, when <replaceable>lvalue</replaceable> contains
code that has side effects, the simple assignment performs those side
effects twice, while the modifying assignment performs them once.  For
instance,
</para>
<screen>x[foo ()] = x[foo ()] + 5;
</screen>
<para>calls <literal>foo</literal> twice, and it could return different values each
time.  If <literal>foo ()</literal> returns 1 the first time and 3 the second
time, then the effect could be to add <literal>x[3]</literal> and 5 and store the
result in <literal>x[1]</literal>, or to add <literal>x[1]</literal> and 5 and store the
result in <literal>x[3]</literal>.  We don&#8217;t know which of the two it will do,
because C does not specify which call to <literal>foo</literal> is computed first.
</para>
<para>Such a statement is not well defined, and shouldn&#8217;t be used.
</para>
<para>By contrast,
</para>
<screen>x[foo ()] += 5;
</screen>
<para>is well defined: it calls <literal>foo</literal> only once to determine which
element of <literal>x</literal> to adjust, and it adjusts that element by adding 5
to it.
</para>
</sect1>
<sect1 label="7.4" id="Increment_002fDecrement">
<title>Increment and Decrement Operators</title>
<indexterm role="cp"><primary>increment operator</primary></indexterm>
<indexterm role="cp"><primary>decrement operator</primary></indexterm>
<indexterm role="cp"><primary>operator, increment</primary></indexterm>
<indexterm role="cp"><primary>operator, decrement</primary></indexterm>
<indexterm role="cp"><primary>preincrement expression</primary></indexterm>
<indexterm role="cp"><primary>predecrement expression</primary></indexterm>

<para>The operators &#8216;<literal>++</literal>&#8217; and &#8216;<literal>--</literal>&#8217; are the <firstterm>increment</firstterm> and
<firstterm>decrement</firstterm> operators.  When used on a numeric value, they add or
subtract 1.  We don&#8217;t consider them assignments, but they are
equivalent to assignments.
</para>
<para>Using &#8216;<literal>++</literal>&#8217; or &#8216;<literal>--</literal>&#8217; as a prefix, before an lvalue, is called
<firstterm>preincrement</firstterm> or <firstterm>predecrement</firstterm>.  This adds or subtracts 1
and the result becomes the expression&#8217;s value.  For instance,
</para>
<screen>#include &lt;stdio.h&gt;   /* Declares <literal>printf</literal>. */

int
main (void)
{
  int i = 5;
  printf (&quot;%d\n&quot;, i);
  printf (&quot;%d\n&quot;, ++i);
  printf (&quot;%d\n&quot;, i);
  return 0;
}
</screen>
<para>prints lines containing 5, 6, and 6 again.  The expression <literal>++i</literal>
increments <literal>i</literal> from 5 to 6, and has the value 6, so the output
from <literal>printf</literal> on that line says &#8216;<literal>6</literal>&#8217;.
</para>
<para>Using &#8216;<literal>--</literal>&#8217; instead, for predecrement,
</para>
<screen>#include &lt;stdio.h&gt;   /* Declares <literal>printf</literal>. */

int
main (void)
{
  int i = 5;
  printf (&quot;%d\n&quot;, i);
  printf (&quot;%d\n&quot;, --i);
  printf (&quot;%d\n&quot;, i);
  return 0;
}
</screen>
<para>prints three lines that contain (respectively) &#8216;<literal>5</literal>&#8217;, &#8216;<literal>4</literal>&#8217;, and
again &#8216;<literal>4</literal>&#8217;.
</para>
</sect1>
<sect1 label="7.5" id="Postincrement_002fPostdecrement">
<title>Postincrement and Postdecrement</title>
<indexterm role="cp"><primary>postincrement expression</primary></indexterm>
<indexterm role="cp"><primary>postdecrement expression</primary></indexterm>
<indexterm role="cp"><primary>operator, postincrement</primary></indexterm>
<indexterm role="cp"><primary>operator, postdecrement</primary></indexterm>

<para>Using &#8216;<literal>++</literal>&#8217; or &#8216;<literal>--</literal>&#8217; <emphasis>after</emphasis> an lvalue does something
peculiar: it gets the value directly out of the lvalue and <emphasis>then</emphasis>
increments or decrement it.  Thus, the value of <literal>i++</literal> is the same
as the value of <literal>i</literal>, but <literal>i++</literal> also increments <literal>i</literal> &#8220;a
little later.&#8221;  This is called <firstterm>postincrement</firstterm> or
<firstterm>postdecrement</firstterm>.
</para>
<para>For example,
</para>
<screen>#include &lt;stdio.h&gt;   /* Declares <literal>printf</literal>. */

int
main (void)
{
  int i = 5;
  printf (&quot;%d\n&quot;, i);
  printf (&quot;%d\n&quot;, i++);
  printf (&quot;%d\n&quot;, i);
  return 0;
}
</screen>
<para>prints lines containing 5, again 5, and 6.  The expression <literal>i++</literal>
has the value 5, which is the value of <literal>i</literal> at the time,
but it increments <literal>i</literal> from 5 to 6 just a little later.
</para>
<para>How much later is &#8220;just a little later&#8221;?  That is flexible.  The
increment has to happen by the next <firstterm>sequence point</firstterm>.  In simple cases,
that means by the end of the statement.  See <link linkend="Sequence-Points">Sequence Points</link>.
</para>
<para>If a unary operator precedes a postincrement or postincrement expression,
the increment nests inside:
</para>
<screen>-a++   is equivalent to   -(a++)
</screen>
<para>That&#8217;s the only order that makes sense; <literal>-a</literal> is not an lvalue, so
it can&#8217;t be incremented.
</para>
</sect1>
<sect1 label="7.6" id="Assignment-in-Subexpressions">
<title>Pitfall: Assignment in Subexpressions</title>
<indexterm role="cp"><primary>assignment in subexpressions</primary></indexterm>
<indexterm role="cp"><primary>subexpressions, assignment in</primary></indexterm>

<para>In C, the order of computing parts of an expression is not fixed.
Aside from a few special cases, the operations can be computed in any
order.  If one part of the expression has an assignment to <literal>x</literal>
and another part of the expression uses <literal>x</literal>, the result is
unpredictable because that use might be computed before or after the
assignment.
</para>
<para>Here&#8217;s an example of ambiguous code:
</para>
<screen>x = 20;
printf (&quot;%d %d\n&quot;, x, x = 4);
</screen>
<para>If the second argument, <literal>x</literal>, is computed before the third argument,
<literal>x = 4</literal>, the second argument&#8217;s value will be 20.  If they are
computed in the other order, the second argument&#8217;s value will be 4.
</para>
<para>Here&#8217;s one way to make that code unambiguous:
</para>
<screen>y = 20;
printf (&quot;%d %d\n&quot;, y, x = 4);
</screen>
<para>Here&#8217;s another way, with the other meaning:
</para>
<screen>x = 4;
printf (&quot;%d %d\n&quot;, x, x);
</screen>
<para>This issue applies to all kinds of assignments, and to the increment
and decrement operators, which are equivalent to assignments.
See <link linkend="Order-of-Execution">Order of Execution</link>, for more information about this.
</para>
<para>However, it can be useful to write assignments inside an
<literal>if</literal>-condition or <literal>while</literal>-test along with logical operators.
See <link linkend="Logicals-and-Assignments">Logicals and Assignments</link>.
</para>
</sect1>
<sect1 label="7.7" id="Write-Assignments-Separately">
<title>Write Assignments in Separate Statements</title>

<para>It is often convenient to write an assignment inside an
<literal>if</literal>-condition, but that can reduce the readability of the
program.  Here&#8217;s an example of what to avoid:
</para>
<screen>if (x = advance (x))
  &#8230;
</screen>
<para>The idea here is to advance <literal>x</literal> and test if the value is nonzero.
However, readers might miss the fact that it uses &#8216;<literal>=</literal>&#8217; and not
&#8216;<literal>==</literal>&#8217;.  In fact, writing &#8216;<literal>=</literal>&#8217; where &#8216;<literal>==</literal>&#8217; was intended
inside a condition is a common error, so GNU C can give warnings when
&#8216;<literal>=</literal>&#8217; appears in a way that suggests it&#8217;s an error.
</para>
<para>It is much clearer to write the assignment as a separate statement, like this:
</para>
<screen>x = advance (x);
if (x != 0)
  &#8230;
</screen>
<para>This makes it unmistakably clear that <literal>x</literal> is assigned a new value.
</para>
<para>Another method is to use the comma operator (see <link linkend="Comma-Operator">Comma Operator</link>),
like this:
</para>
<screen>if (x = advance (x), x != 0)
  &#8230;
</screen>
<para>However, putting the assignment in a separate statement is usually clearer
unless the assignment is very short, because it reduces nesting.
</para>
</sect1>
</chapter>
<chapter label="8" id="Execution-Control-Expressions">
<title>Execution Control Expressions</title>
<indexterm role="cp"><primary>execution control expressions</primary></indexterm>
<indexterm role="cp"><primary>expressions, execution control</primary></indexterm>

<para>This chapter describes the C operators that combine expressions to
control which of those expressions execute, or in which order.
</para>

<sect1 label="8.1" id="Logical-Operators">
<title>Logical Operators</title>
<indexterm role="cp"><primary>logical operators</primary></indexterm>
<indexterm role="cp"><primary>operators, logical</primary></indexterm>
<indexterm role="cp"><primary>conjunction operator</primary></indexterm>
<indexterm role="cp"><primary>disjunction operator</primary></indexterm>
<indexterm role="cp"><primary>negation operator, logical</primary></indexterm>

<para>The <firstterm>logical operators</firstterm> combine truth values, which are normally
represented in C as numbers.  Any expression with a numeric value is a
valid truth value: zero means false, and any other value means true.
A pointer type is also meaningful as a truth value; a null pointer
(which is zero) means false, and a non-null pointer means true
(see <link linkend="Pointer-Types">Pointer Types</link>).  The value of a logical operator is always 1
or 0 and has type <literal>int</literal> (see <link linkend="Integer-Types">Integer Types</link>).
</para>
<para>The logical operators are used mainly in the condition of an <literal>if</literal>
statement, or in the end test in a <literal>for</literal> statement or
<literal>while</literal> statement (see <link linkend="Statements">Statements</link>).  However, they are valid
in any context where an integer-valued expression is allowed.
</para>
<variablelist><varlistentry><term>&#8216;<literal>! <replaceable>exp</replaceable></literal>&#8217;
</term><listitem><para>Unary operator for logical &#8220;not.&#8221;  The value is 1 (true) if
<replaceable>exp</replaceable> is 0 (false), and 0 (false) if <replaceable>exp</replaceable> is nonzero (true).
</para>
<para><emphasis role="bold">Warning:</emphasis> if <literal>exp</literal> is anything but an lvalue or a
function call, you should write parentheses around it.
</para>
</listitem></varlistentry><varlistentry><term>&#8216;<literal><replaceable>left</replaceable> &amp;&amp; <replaceable>right</replaceable></literal>&#8217;
</term><listitem><para>The logical &#8220;and&#8221; binary operator computes <replaceable>left</replaceable> and, if necessary,
<replaceable>right</replaceable>.  If both of the operands are true, the &#8216;<literal>&amp;&amp;</literal>&#8217; expression
gives the value 1 (which is true).  Otherwise, the &#8216;<literal>&amp;&amp;</literal>&#8217; expression
gives the value 0 (false).  If <replaceable>left</replaceable> yields a false value,
that determines the overall result, so <replaceable>right</replaceable> is not computed.
</para>
</listitem></varlistentry><varlistentry><term>&#8216;<literal><replaceable>left</replaceable> || <replaceable>right</replaceable></literal>&#8217;
</term><listitem><para>The logical &#8220;or&#8221; binary operator computes <replaceable>left</replaceable> and, if necessary,
<replaceable>right</replaceable>.  If at least one of the operands is true, the &#8216;<literal>||</literal>&#8217; expression
gives the value 1 (which is true).  Otherwise, the &#8216;<literal>||</literal>&#8217; expression
gives the value 0 (false).  If <replaceable>left</replaceable> yields a true value,
that determines the overall result, so <replaceable>right</replaceable> is not computed.
</para></listitem></varlistentry></variablelist>
<para><emphasis role="bold">Warning:</emphasis> never rely on the relative precedence of &#8216;<literal>&amp;&amp;</literal>&#8217;
and &#8216;<literal>||</literal>&#8217;.  When you use them together, always use parentheses to
specify explicitly how they nest, as shown here:
</para>
<screen>if ((r != 0 &amp;&amp; x % r == 0)
    ||
    (s != 0 &amp;&amp; x % s == 0))
</screen>
</sect1>
<sect1 label="8.2" id="Logicals-and-Comparison">
<title>Logical Operators and Comparisons</title>

<para>The most common thing to use inside the logical operators is a
comparison.  Conveniently, &#8216;<literal>&amp;&amp;</literal>&#8217; and &#8216;<literal>||</literal>&#8217; have lower
precedence than comparison operators and arithmetic operators, so we
can write expressions like this without parentheses and get the
nesting that is natural: two comparison operations that must both be
true.
</para>
<screen>if (r != 0 &amp;&amp; x % r == 0)
</screen>
<para>This example also shows how it is useful that &#8216;<literal>&amp;&amp;</literal>&#8217; guarantees to
skip the right operand if the left one turns out false.  Because of
that, this code never tries to divide by zero.
</para>
<para>This is equivalent:
</para>
<screen>if (r &amp;&amp; x % r == 0)
</screen>
<para>A truth value is simply a number, so <literal>r</literal>
as a truth value tests whether it is nonzero.
But <literal>r</literal>&#8217;s meaning is not a truth value&#8212;it is a number to divide by.
So it is better style to write the explicit <literal>!= 0</literal>.
</para>
<para>Here&#8217;s another equivalent way to write it:
</para>
<screen>if (!(r == 0) &amp;&amp; x % r == 0)
</screen>
<para>This illustrates the unary &#8216;<literal>!</literal>&#8217; operator, and the need to
write parentheses around its operand.
</para>
</sect1>
<sect1 label="8.3" id="Logicals-and-Assignments">
<title>Logical Operators and Assignments</title>

<para>There are cases where assignments nested inside the condition can
actually make a program <emphasis>easier</emphasis> to read.  Here is an example
using a hypothetical type <literal>list</literal> which represents a list; it
tests whether the list has at least two links, using hypothetical
functions, <literal>nonempty</literal> which is true of the argument is a nonempty
list, and <literal>list_next</literal> which advances from one list link to the
next.  We assume that a list is never a null pointer, so that the
assignment expressions are always &#8220;true.&#8221;
</para>
<screen>if (nonempty (list)
    &amp;&amp; (temp1 = list_next (list))
    &amp;&amp; nonempty (temp1)
    &amp;&amp; (temp2 = list_next (temp1)))
  &#8230;  /* use <literal>temp1</literal> and <literal>temp2</literal> */
</screen>
<para>Here we get the benefit of the &#8216;<literal>&amp;&amp;</literal>&#8217; operator, to avoid executing
the rest of the code if a call to <literal>nonempty</literal> says &#8220;false.&#8221;  The
only natural place to put the assignments is among those calls.
</para>
<para>It would be possible to rewrite this as several statements, but that
could make it much more cumbersome.  On the other hand, when the test
is even more complex than this one, splitting it into multiple
statements might be necessary for clarity.
</para>
<para>If an empty list is a null pointer, we can dispense with calling
<literal>nonempty</literal>:
</para>
<screen>if ((temp1 = list_next (list))
    &amp;&amp; (temp2 = list_next (temp1)))
 &#8230;
</screen>
</sect1>
<sect1 label="8.4" id="Conditional-Expression">
<title>Conditional Expression</title>
<indexterm role="cp"><primary>conditional expression</primary></indexterm>
<indexterm role="cp"><primary>expression, conditional</primary></indexterm>

<para>C has a conditional expression that selects one of two expressions
to compute and get the value from.  It looks like this:
</para>
<screen><replaceable>condition</replaceable> ? <replaceable>iftrue</replaceable> : <replaceable>iffalse</replaceable>
</screen>

<sect2 label="8.4.1" id="Conditional-Rules">
<title>Rules for Conditional Operator</title>

<para>The first operand, <replaceable>condition</replaceable>, should be a value that can be
compared with zero&#8212;a number or a pointer.  If it is true (nonzero),
then the conditional expression computes <replaceable>iftrue</replaceable> and its value
becomes the value of the conditional expression.  Otherwise the
conditional expression computes <replaceable>iffalse</replaceable> and its value becomes
the value of the conditional expression.  The conditional expression
always computes just one of <replaceable>iftrue</replaceable> and <replaceable>iffalse</replaceable>, never both
of them.
</para>
<para>Here&#8217;s an example: the absolute value of a number <literal>x</literal>
can be written as <literal>(x &gt;= 0 ? x : -x)</literal>.
</para>
<para><emphasis role="bold">Warning:</emphasis> The conditional expression operators have rather low
syntactic precedence.  Except when the conditional expression is used
as an argument in a function call, write parentheses around it.  For
clarity, always write parentheses around it if it extends across more
than one line.
</para>
<para>Assignment operators and the comma operator (see <link linkend="Comma-Operator">Comma Operator</link>)
have lower precedence than conditional expression operators, so write
parentheses around those when they appear inside a conditional
expression.  See <link linkend="Order-of-Execution">Order of Execution</link>.
</para>
</sect2>
<sect2 label="8.4.2" id="Conditional-Branches">
<title>Conditional Operator Branches</title>
<indexterm role="cp"><primary>branches of conditional expression</primary></indexterm>

<para>We call <replaceable>iftrue</replaceable> and <replaceable>iffalse</replaceable> the <firstterm>branches</firstterm> of the
conditional.
</para>
<para>The two branches should normally have the same type, but a few
exceptions are allowed.  If they are both numeric types, the
conditional converts both to their common type (see <link linkend="Common-Type">Common Type</link>).
</para>
<para>With pointers (see <link linkend="Pointers">Pointers</link>), the two values can be pointers to
nearly compatible types (see <link linkend="Compatible-Types">Compatible Types</link>).  In this case, the
result type is a similar pointer whose target type combines all the
type qualifiers (see <link linkend="Type-Qualifiers">Type Qualifiers</link>) of both branches.
</para>
<para>If one branch has type <literal>void *</literal> and the other is a pointer to an
object (not to a function), the conditional converts the <literal>void *</literal>
branch to the type of the other.
</para>
<para>If one branch is an integer constant with value zero and the other is
a pointer, the conditional converts zero to the pointer&#8217;s type.
</para>
<para>In GNU C, you can omit <replaceable>iftrue</replaceable> in a conditional expression.  In
that case, if <replaceable>condition</replaceable> is nonzero, its value becomes the value of
the conditional expression, after conversion to the common type.
Thus,
</para>
<screen>x ? : y
</screen>
<para>has the value of <literal>x</literal> if that is nonzero; otherwise, the value of
<literal>y</literal>.
</para>
<indexterm role="cp"><primary>side effect in ?:</primary></indexterm>
<indexterm role="cp"><primary>?: side effect</primary></indexterm>
<para>Omitting <replaceable>iftrue</replaceable> is useful when <replaceable>condition</replaceable> has side effects.
In that case, writing that expression twice would carry out the side
effects twice, but writing it once does them just once.  For example,
if we suppose that the function <literal>next_element</literal> advances a pointer
variable to point to the next element in a list and returns the new
pointer,
</para>
<screen>next_element () ? : default_pointer
</screen>
<para>is a way to advance the pointer and use its new value if it isn&#8217;t
null, but use <literal>default_pointer</literal> if that is null.  We must not do
it this way,
</para>
<screen>next_element () ? next_element () : default_pointer
</screen>
<para>because it would advance the pointer a second time.
</para>
</sect2>
</sect1>
<sect1 label="8.5" id="Comma-Operator">
<title>Comma Operator</title>
<indexterm role="cp"><primary>comma operator</primary></indexterm>
<indexterm role="cp"><primary>operator, comma</primary></indexterm>

<para>The comma operator stands for sequential execution of expressions.
The value of the comma expression comes from the last expression in
the sequence; the previous expressions are computed only for their
side effects.  It looks like this:
</para>
<screen><replaceable>exp1</replaceable>, <replaceable>exp2</replaceable> &#8230;
</screen>
<para>You can bundle any number of expressions together this way, by putting
commas between them.
</para>

<sect2 label="8.5.1" id="Uses-of-Comma">
<title>The Uses of the Comma Operator</title>

<para>With commas, you can put several expressions into a place that
requires just one expression&#8212;for example, in the header of a
<literal>for</literal> statement.  This statement
</para>
<screen>for (i = 0, j = 10, k = 20; i &lt; n; i++)
</screen>
<para>contains three assignment expressions, to initialize <literal>i</literal>, <literal>j</literal>
and <literal>k</literal>.  The syntax of <literal>for</literal> requires just one expression
for initialization; to include three assignments, we use commas to
bundle them into a single larger expression, <literal>i = 0, j = 10, k =
20</literal>.  This technique is also useful in the loop-advance expression,
the last of the three inside the <literal>for</literal> parentheses.
</para>
<para>In the <literal>for</literal> statement and the <literal>while</literal> statement
(see <link linkend="Loop-Statements">Loop Statements</link>), a comma provides a way to perform some side
effect before the loop-exit test.  For example,
</para>
<screen>while (printf (&quot;At the test, x = %d\n&quot;, x), x != 0)
</screen>
</sect2>
<sect2 label="8.5.2" id="Clean-Comma">
<title>Clean Use of the Comma Operator</title>

<para>Always write parentheses around a series of comma operators, except
when it is at top level in an expression statement, or within the
parentheses of an <literal>if</literal>, <literal>for</literal>, <literal>while</literal>, or <literal>switch</literal>
statement (see <link linkend="Statements">Statements</link>).  For instance, in
</para>
<screen>for (i = 0, j = 10, k = 20; i &lt; n; i++)
</screen>
<para>the commas between the assignments are clear because they are between
a parenthesis and a semicolon.
</para>
<para>The arguments in a function call are also separated by commas, but that is
not an instance of the comma operator.  Note the difference between
</para>
<screen>foo (4, 5, 6)
</screen>
<para>which passes three arguments to <literal>foo</literal> and
</para>
<screen>foo ((4, 5, 6))
</screen>
<para>which uses the comma operator and passes just one argument
(with value 6).
</para>
<para><emphasis role="bold">Warning:</emphasis> don&#8217;t use the comma operator around an argument
of a function unless it helps understand the code.  When you do so,
don&#8217;t put part of another argument on the same line.  Instead, add a
line break to make the parentheses around the comma operator easier to
see, like this.
</para>
<screen>foo ((mumble (x, y), frob (z)),
     *p)
</screen>
</sect2>
<sect2 label="8.5.3" id="Avoid-Comma">
<title>When Not to Use the Comma Operator</title>

<para>You can use a comma in any subexpression, but in most cases it only
makes the code confusing, and it is clearer to raise all but the last
of the comma-separated expressions to a higher level.  Thus, instead
of this:
</para>
<screen>x = (y += 4, 8);
</screen>
<para>it is much clearer to write this:
</para>
<screen>y += 4, x = 8;
</screen>
<para>or this:
</para>
<screen>y += 4;
x = 8;
</screen>
<para>Use commas only in the cases where there is no clearer alternative
involving multiple statements.
</para>
<para>By contrast, don&#8217;t hesitate to use commas in the expansion in a macro
definition.  The trade-offs of code clarity are different in that
case, because the <emphasis>use</emphasis> of the macro may improve overall clarity
so much that the ugliness of the macro&#8217;s <emphasis>definition</emphasis> is a small
price to pay.  See <link linkend="Macros">Macros</link>.
</para>
</sect2>
</sect1>
</chapter>
<chapter label="9" id="Binary-Operator-Grammar">
<title>Binary Operator Grammar</title>
<indexterm role="cp"><primary>binary operator grammar</primary></indexterm>
<indexterm role="cp"><primary>grammar, binary operator</primary></indexterm>
<indexterm role="cp"><primary>operator precedence</primary></indexterm>
<indexterm role="cp"><primary>precedence, operator</primary></indexterm>
<indexterm role="cp"><primary>left-associative</primary></indexterm>

<para><firstterm>Binary operators</firstterm> are those that take two operands, one
on the left and one on the right.
</para>
<para>All the binary operators in C are syntactically left-associative.
This means that <literal>a <replaceable>op</replaceable> b <replaceable>op</replaceable> c</literal><!-- /@w --> means <literal>(a
<replaceable>op</replaceable> b) <replaceable>op</replaceable> c</literal><!-- /@w -->.  However, you should only write repeated
operators without parentheses using &#8216;<literal>+</literal>&#8217;, &#8216;<literal>-</literal>&#8217;, &#8216;<literal>*</literal>&#8217; and
&#8216;<literal>/</literal>&#8217;, because those cases are clear from algebra.  So it is ok to
write <literal>a + b + c</literal> or <literal>a - b - c</literal>, but never <literal>a == b ==
c</literal> or <literal>a % b % c</literal>.
</para>
<para>Each C operator has a <firstterm>precedence</firstterm>, which is its rank in the
grammatical order of the various operators.  The operators with the
highest precedence grab adjoining operands first; these expressions
then become operands for operators of lower precedence.
</para>
<para>The precedence order of operators in C is fully specified, so any
combination of operations leads to a well-defined nesting.  We state
only part of the full precedence ordering here because it is bad
practice for C code to depend on the other cases.  For cases not
specified in this chapter, always use parentheses to make the nesting
explicit.<footnote><para>Personal note from Richard Stallman: I wrote GCC without
remembering anything about the C precedence order beyond what&#8217;s stated
here.  I studied the full precedence table to write the parser, and
promptly forgot it again.  If you need to look up the full precedence order
to understand some C code, fix the code with parentheses so nobody else
needs to do that.</para></footnote>
</para>
<para>You can depend on this subsequence of the precedence ordering
(stated from highest precedence to lowest):
</para>
<orderedlist numeration="arabic"><listitem><para>Component access (&#8216;<literal>.</literal>&#8217; and &#8216;<literal>-&gt;</literal>&#8217;).
</para>
</listitem><listitem><para>Unary prefix operators.
</para>
</listitem><listitem><para>Unary postfix operators.
</para>
</listitem><listitem><para>Multiplication, division, and remainder (they have the same precedence).
</para>
</listitem><listitem><para>Addition and subtraction (they have the same precedence).
</para>
</listitem><listitem><para>Comparisons&#8212;but watch out!
</para>
</listitem><listitem><para>Logical operators &#8216;<literal>&amp;&amp;</literal>&#8217; and &#8216;<literal>||</literal>&#8217;&#8212;but watch out!
</para>
</listitem><listitem><para>Conditional expression with &#8216;<literal>?</literal>&#8217; and &#8216;<literal>:</literal>&#8217;.
</para>
</listitem><listitem><para>Assignments.
</para>
</listitem><listitem><para>Sequential execution (the comma operator, &#8216;<literal>,</literal>&#8217;).
</para></listitem></orderedlist>
<para>Two of the lines in the above list say &#8220;but watch out!&#8221;  That means
that the line covers operators with subtly different precedence.
Never depend on the grammar of C to decide how two comparisons nest;
instead, always use parentheses to specify their nesting.
</para>
<para>You can let several &#8216;<literal>&amp;&amp;</literal>&#8217; operators associate, or several
&#8216;<literal>||</literal>&#8217; operators, but always use parentheses to show how &#8216;<literal>&amp;&amp;</literal>&#8217;
and &#8216;<literal>||</literal>&#8217; nest with each other.  See <link linkend="Logical-Operators">Logical Operators</link>.
</para>
<para>There is one other precedence ordering that code can depend on:
</para>
<orderedlist numeration="arabic"><listitem><para>Unary postfix operators.
</para>
</listitem><listitem><para>Bitwise and shift operators&#8212;but watch out!
</para>
</listitem><listitem><para>Conditional expression with &#8216;<literal>?</literal>&#8217; and &#8216;<literal>:</literal>&#8217;.
</para></listitem></orderedlist>
<para>The caveat for bitwise and shift operators is like that for logical
operators: you can let multiple uses of one bitwise operator
associate, but always use parentheses to control nesting of dissimilar
operators.
</para>
<para>These lists do not specify any precedence ordering between the bitwise
and shift operators of the second list and the binary operators above
conditional expressions in the first list.  When they come together,
parenthesize them.  See <link linkend="Bitwise-Operations">Bitwise Operations</link>.
</para>
</chapter>
<chapter label="10" id="Order-of-Execution">
<title>Order of Execution</title>
<indexterm role="cp"><primary>order of execution</primary></indexterm>

<para>The order of execution of a C program is not always obvious, and not
necessarily predictable.  This chapter describes what you can count on.
</para>

<sect1 label="10.1" id="Reordering-of-Operands">
<title>Reordering of Operands</title>
<indexterm role="cp"><primary>ordering of operands</primary></indexterm>
<indexterm role="cp"><primary>reordering of operands</primary></indexterm>
<indexterm role="cp"><primary>operand execution ordering</primary></indexterm>

<para>The C language does not necessarily carry out operations within an
expression in the order they appear in the code.  For instance, in
this expression,
</para>
<screen>foo () + bar ()
</screen>
<para><literal>foo</literal> might be called first or <literal>bar</literal> might be called first.
If <literal>foo</literal> updates a datum and <literal>bar</literal> uses that datum, the
results can be unpredictable.
</para>
<para>The unpredictable order of computation of subexpressions also makes a
difference when one of them contains an assignment.  We already saw
this example of bad code,
</para>
<screen>x = 20;
printf (&quot;%d %d\n&quot;, x, x = 4);
</screen>
<para>in which the second argument, <literal>x</literal>, has a different value
depending on whether it is computed before or after the assignment in
the third argument.
</para>
</sect1>
<sect1 label="10.2" id="Associativity-and-Ordering">
<title>Associativity and Ordering</title>
<indexterm role="cp"><primary>associativity and ordering</primary></indexterm>

<para>An associative binary operator, such as <literal>+</literal>, when used repeatedly
can combine any number of operands.  The operands&#8217; values may be
computed in any order.
</para>
<para>If the values are integers and overflow can be ignored, they may be
combined in any order.  Thus, given four functions that return
<literal>unsigned int</literal>, calling them and adding their results as here
</para>
<screen>(foo () + bar ()) + (baz () + quux ())
</screen>
<para>may add up the results in any order.
</para>
<para>By contrast, arithmetic on signed integers, with overflow significant,
is not really associative (see <link linkend="Integer-Overflow">Integer Overflow</link>).  Thus, the
additions must be done in the order specified, obeying parentheses and
left-association.  That means computing <literal>(foo () + bar ())</literal> and
<literal>(baz () + quux ())</literal> first (in either order), then adding the
two.
</para>
<para>The same applies to arithmetic on floating-point values, since that
too is not really associative.  However, the GCC option
<option>-funsafe-math-optimizations</option> allows the compiler to change the
order of calculation when an associative operation (associative in
exact mathematics) combines several operands.  The option takes effect
when compiling a module (see <link linkend="Compilation">Compilation</link>).  Changing the order
of association can enable the program to pipeline the floating point
operations.
</para>
<para>In all these cases, the four function calls can be done in any order.
There is no right or wrong about that.
</para>
</sect1>
<sect1 label="10.3" id="Sequence-Points">
<title>Sequence Points</title>
<indexterm role="cp"><primary>sequence points</primary></indexterm>
<indexterm role="cp"><primary>full expression</primary></indexterm>

<para>There are some points in the code where C makes limited guarantees
about the order of operations.  These are called <firstterm>sequence
points</firstterm>.  Here is where they occur:
</para>
<itemizedlist><listitem><para>At the end of a <firstterm>full expression</firstterm>; that is to say, an expression
that is not part of a larger expression.  All side effects specified
by that expression are carried out before execution moves
on to subsequent code.
</para>
</listitem><listitem><para>At the end of the first operand of certain operators: &#8216;<literal>,</literal>&#8217;,
&#8216;<literal>&amp;&amp;</literal>&#8217;, &#8216;<literal>||</literal>&#8217;, and &#8216;<literal>?:</literal>&#8217;.  All side effects specified by
that expression are carried out before any execution of the
next operand.
</para>
<para>The commas that separate arguments in a function call are <emphasis>not</emphasis>
comma operators, and they do not create sequence points.  The rule
for function arguments and the rule for operands are different
(see <link linkend="Ordering-of-Operands">Ordering of Operands</link>).
</para>
</listitem><listitem><para>Just before calling a function.  All side effects specified by the
argument expressions are carried out before calling the function.
</para>
<para>If the function to be called is not constant&#8212;that is, if it is
computed by an expression&#8212;all side effects in that expression are
carried out before calling the function.
</para></listitem></itemizedlist>
<para>The ordering imposed by a sequence point applies locally to a limited
range of code, as stated above in each case.  For instance, the
ordering imposed by the comma operator does not apply to code outside
that comma operator.  Thus, in this code,
</para>
<screen>(x = 5, foo (x)) + x * x
</screen>
<para>the sequence point of the comma operator orders <literal>x = 5</literal> before
<literal>foo (x)</literal>, but <literal>x * x</literal> could be computed before or after
them.
</para>
</sect1>
<sect1 label="10.4" id="Postincrement-and-Ordering">
<title>Postincrement and Ordering</title>
<indexterm role="cp"><primary>postincrement and ordering</primary></indexterm>
<indexterm role="cp"><primary>ordering and postincrement</primary></indexterm>

<para>Ordering requirements are loose with the postincrement and
postdecrement operations (see <link linkend="Postincrement_002fPostdecrement">Postincrement/Postdecrement</link>), which
specify side effects to happen &#8220;a little later.&#8221;  They must happen
before the next sequence point, but that still leaves room for various
meanings.  In this expression,
</para>
<screen>z = x++ - foo ()
</screen>
<para>it&#8217;s unpredictable whether <literal>x</literal> gets incremented before or after
calling the function <literal>foo</literal>.  If <literal>foo</literal> refers to <literal>x</literal>,
it might see the old value or it might see the incremented value.
</para>
<para>In this perverse expression,
</para>
<screen>x = x++
</screen>
<para><literal>x</literal> will certainly be incremented but the incremented value may
not stick.  If the incrementation of <literal>x</literal> happens after the
assignment to <literal>x</literal>, the incremented value will remain in place.
But if the incrementation happens first, the assignment will overwrite
that with the not-yet-incremented value, so the expression as a whole
will leave <literal>x</literal> unchanged.
</para>
</sect1>
<sect1 label="10.5" id="Ordering-of-Operands">
<title>Ordering of Operands</title>
<indexterm role="cp"><primary>ordering of operands</primary></indexterm>
<indexterm role="cp"><primary>operand ordering</primary></indexterm>

<para>Operands and arguments can be computed in any order, but there are limits to
this intermixing in GNU C:
</para>
<itemizedlist><listitem><para>The operands of a binary arithmetic operator can be computed in either
order, but they can&#8217;t be intermixed: one of them has to come first,
followed by the other.  Any side effects in the operand that&#8217;s computed
first are executed before the other operand is computed.
</para>
</listitem><listitem><para>That applies to assignment operators too, except that in simple assignment
the previous value of the left operand is unused.
</para>
</listitem><listitem><para>The arguments in a function call can be computed in any order, but
they can&#8217;t be intermixed.  Thus, one argument is fully computed, then
another, and so on until they are all done.  Any side effects in one argument
are executed before computation of another argument begins.
</para></listitem></itemizedlist>
<para>These rules don&#8217;t cover side effects caused by postincrement and
postdecrement operators&#8212;those can be deferred up to the next
sequence point.
</para>
<para>If you want to get pedantic, the fact is that GCC can reorder the
computations in many other ways provided that doesn&#8217;t alter the result
of running the program.  However, because they don&#8217;t alter the result
of running the program, they are negligible, unless you are concerned
with the values in certain variables at various times as seen by other
processes.  In those cases, you can use <literal>volatile</literal> to prevent
optimizations that would make them behave strangely.  See <link linkend="volatile">volatile</link>.
</para>
</sect1>
<sect1 label="10.6" id="Optimization-and-Ordering">
<title>Optimization and Ordering</title>
<indexterm role="cp"><primary>optimization and ordering</primary></indexterm>
<indexterm role="cp"><primary>ordering and optimization</primary></indexterm>

<para>Sequence points limit the compiler&#8217;s freedom to reorder operations
arbitrarily, but optimizations can still reorder them if the compiler
concludes that this won&#8217;t alter the results.  Thus, in this code,
</para>
<screen>x++;
y = z;
x++;
</screen>
<para>there is a sequence point after each statement, so the code is
supposed to increment <literal>x</literal> once before the assignment to <literal>y</literal>
and once after.  However, incrementing <literal>x</literal> has no effect on
<literal>y</literal> or <literal>z</literal>, and setting <literal>y</literal> can&#8217;t affect <literal>x</literal>, so
the code could be optimized into this:
</para>
<screen>y = z;
x += 2;
</screen>
<para>Normally that has no effect except to make the program faster.  But
there are special situations where it can cause trouble due to things
that the compiler cannot know about, such as shared memory.  To limit
optimization in those places, use the <literal>volatile</literal> type qualifier
(see <link linkend="volatile">volatile</link>).
</para>
</sect1>
</chapter>
<chapter label="11" id="Primitive-Types">
<title>Primitive Data Types</title>
<indexterm role="cp"><primary>primitive types</primary></indexterm>
<indexterm role="cp"><primary>types, primitive</primary></indexterm>

<para>This chapter describes all the primitive data types of C&#8212;that is,
all the data types that aren&#8217;t built up from other types.  They
include the types <literal>int</literal> and <literal>double</literal> that we&#8217;ve already covered.
</para>

<para>These types are all made up of bytes (see <link linkend="Storage">Storage</link>).
</para>
<sect1 label="11.1" id="Integer-Types">
<title>Integer Data Types</title>
<indexterm role="cp"><primary>integer types</primary></indexterm>
<indexterm role="cp"><primary>types, integer</primary></indexterm>

<para>Here we describe all the integer types and their basic
characteristics.  See <link linkend="Integers-in-Depth">Integers in Depth</link>, for more information about
the bit-level integer data representations and arithmetic.
</para>

<sect2 label="11.1.1" id="Basic-Integers">
<title>Basic Integers</title>

<indexterm role="fn"><primary>char</primary></indexterm>
<indexterm role="fn"><primary>int</primary></indexterm>
<indexterm role="fn"><primary>short int</primary></indexterm>
<indexterm role="fn"><primary>long int</primary></indexterm>
<indexterm role="fn"><primary>long long int</primary></indexterm>

<para>Integer data types in C can be signed or unsigned.  An unsigned type
can represent only positive numbers and zero.  A signed type can
represent both positive and negative numbers, in a range spread almost
equally on both sides of zero.
</para>
<para>Aside from signedness, the integer data types vary in size: how many
bytes long they are.  The size determines how many different integer
values the type can hold.
</para>
<para>Here&#8217;s a list of the signed integer data types, with the sizes they
have on most computers.  Each has a corresponding unsigned type; see
<link linkend="Signed-and-Unsigned-Types">Signed and Unsigned Types</link>.
</para>
<variablelist><varlistentry><term><literal>signed char</literal>
</term><listitem><para>One byte (8 bits).  This integer type is used mainly for integers that
represent characters, as part of arrays or other data structures.
</para>
</listitem></varlistentry><varlistentry><term><literal>short</literal>
</term><term><literal>short int</literal>
</term><listitem><para>Two bytes (16 bits).
</para>
</listitem></varlistentry><varlistentry><term><literal>int</literal>
</term><listitem><para>Four bytes (32 bits).
</para>
</listitem></varlistentry><varlistentry><term><literal>long</literal>
</term><term><literal>long int</literal>
</term><listitem><para>Four bytes (32 bits) or eight bytes (64 bits), depending on the
platform.  Typically it is 32 bits on 32-bit computers
and 64 bits on 64-bit computers, but there are exceptions.
</para>
</listitem></varlistentry><varlistentry><term><literal>long long</literal>
</term><term><literal>long long int</literal>
</term><listitem><para>Eight bytes (64 bits).  Supported in GNU C in the 1980s, and
incorporated into standard C as of ISO C99.
</para></listitem></varlistentry></variablelist>
<para>You can omit <literal>int</literal> when you use <literal>long</literal> or <literal>short</literal>.
This is harmless and customary.
</para>
</sect2>
<sect2 label="11.1.2" id="Signed-and-Unsigned-Types">
<title>Signed and Unsigned Types</title>
<indexterm role="cp"><primary>signed types</primary></indexterm>
<indexterm role="cp"><primary>unsigned types</primary></indexterm>
<indexterm role="cp"><primary>types, signed</primary></indexterm>
<indexterm role="cp"><primary>types, unsigned</primary></indexterm>
<indexterm role="fn"><primary>signed</primary></indexterm>
<indexterm role="fn"><primary>unsigned</primary></indexterm>

<para>An unsigned integer type can represent only positive numbers and zero.
A signed type can represent both positive and negative number, in a
range spread almost equally on both sides of zero.  For instance,
<literal>unsigned char</literal> holds numbers from 0 to 255 (on most computers),
while <literal>signed char</literal> holds numbers from &#8722;128 to 127.  Each of
these types holds 256 different possible values, since they are both 8
bits wide.
</para>
<para>Write <literal>signed</literal> or <literal>unsigned</literal> before the type keyword to
specify a signed or an unsigned type.  However, the integer types
other than <literal>char</literal> are signed by default; with them, <literal>signed</literal>
is a no-op.
</para>
<para>Plain <literal>char</literal> may be signed or unsigned; this depends on the
compiler, the machine in use, and its operating system.
</para>
<para>In many programs, it makes no difference whether <literal>char</literal> is
signed.  When it does matter, don&#8217;t leave it to chance; write
<literal>signed char</literal> or <literal>unsigned char</literal>.<footnote><para>Personal note from
Richard Stallman: Eating with hackers at a fish restaurant, I ordered
Arctic Char.  When my meal arrived, I noted that the chef had not
signed it.  So I complained, &#8220;This char is unsigned&#8212;I wanted a
signed char!&#8221;  Or rather, I would have said this if I had thought of
it fast enough.</para></footnote>
</para>
</sect2>
<sect2 label="11.1.3" id="Narrow-Integers">
<title>Narrow Integers</title>

<para>The types that are narrower than <literal>int</literal> are rarely used for
ordinary variables&#8212;we declare them <literal>int</literal> instead.  This is
because C converts those narrower types to <literal>int</literal> for any
arithmetic.  There is literally no reason to declare a local variable
<literal>char</literal>, for instance.
</para>
<para>In particular, if the value is really a character, you should declare
the variable <literal>int</literal>.  Not <literal>char</literal>!  Using that narrow type can
force the compiler to truncate values for conversion, which is a
waste.  Furthermore, some functions return either a character value,
or &#8722;1 for &#8220;no character.&#8221;  Using <literal>int</literal> keeps those
values distinct.
</para>
<para>The narrow integer types are useful as parts of other objects, such as
arrays and structures.  Compare these array declarations, whose sizes
on 32-bit processors are shown:
</para>
<screen>signed char ac[1000];   /* 1000 bytes */
short as[1000];         /* 2000 bytes */
int ai[1000];           /* 4000 bytes */
long long all[1000];    /* 8000 bytes */
</screen>
<para>In addition, character strings must be made up of <literal>char</literal>s,
because that&#8217;s what all the standard library string functions expect.
Thus, array <literal>ac</literal> could be used as a character string, but the
others could not be.
</para>
</sect2>
<sect2 label="11.1.4" id="Integer-Conversion">
<title>Conversion among Integer Types</title>

<para>C converts between integer types implicitly in many situations.  It
converts the narrow integer types, <literal>char</literal> and <literal>short</literal>, to
<literal>int</literal> whenever they are used in arithmetic.  Assigning a new
value to an integer variable (or other lvalue) converts the value to
the variable&#8217;s type.
</para>
<para>You can also convert one integer type to another explicitly with a
<firstterm>cast</firstterm> operator.  See <link linkend="Explicit-Type-Conversion">Explicit Type Conversion</link>.
</para>
<para>The process of conversion to a wider type is straightforward: the
value is unchanged.  The only exception is when converting a negative
value (in a signed type, obviously) to a wider unsigned type.  In that
case, the result is a positive value with the same bits
(see <link linkend="Integers-in-Depth">Integers in Depth</link>).
</para>
<indexterm role="cp"><primary>truncation</primary></indexterm>
<para>Converting to a narrower type, also called <firstterm>truncation</firstterm>, involves
discarding some of the value&#8217;s bits.  This is not considered overflow
(see <link linkend="Integer-Overflow">Integer Overflow</link>) because loss of significant bits is a
normal consequence of truncation.  Likewise for conversion between
signed and unsigned types of the same width.
</para>
<para>More information about conversion for assignment is in
<link linkend="Assignment-Type-Conversions">Assignment Type Conversions</link>.  For conversion for arithmetic,
see <link linkend="Argument-Promotions">Argument Promotions</link>.
</para>
</sect2>
<sect2 label="11.1.5" id="Boolean-Type">
<title>Boolean Type</title>
<indexterm role="cp"><primary>boolean type</primary></indexterm>
<indexterm role="cp"><primary>type, boolean</primary></indexterm>
<indexterm role="fn"><primary>bool</primary></indexterm>

<para>The unsigned integer type <literal>bool</literal> holds truth values: its possible
values are 0 and 1.  Converting any nonzero value to <literal>bool</literal>
results in 1.  For example:
</para>
<screen>bool a = 0;
bool b = 1;
bool c = 4; /* Stores the value 1 in <literal>c</literal>.  */
</screen>
<para>Unlike <literal>int</literal>, <literal>bool</literal> is not a keyword.  It is defined in
the header file <filename>stdbool.h</filename>.
</para>
</sect2>
<sect2 label="11.1.6" id="Integer-Variations">
<title>Integer Variations</title>

<para>The integer types of C have standard <emphasis>names</emphasis>, but what they
<emphasis>mean</emphasis> varies depending on the kind of platform in use:
which kind of computer, which operating system, and which compiler.
It may even depend on the compiler options used.
</para>
<para>Plain <literal>char</literal> may be signed or unsigned; this depends on the
platform, too.  Even for GNU C, there is no general rule.
</para>
<para>In theory, all of the integer types&#8217; sizes can vary.  <literal>char</literal> is
always considered one &#8220;byte&#8221; for C, but it is not necessarily an
8-bit byte; on some platforms it may be more than 8 bits.  ISO C
specifies only that none of these types is narrower than the ones
above it in the list in <link linkend="Basic-Integers">Basic Integers</link>, and that <literal>short</literal>
has at least 16 bits.
</para>
<para>It is possible that in the future GNU C will support platforms where
<literal>int</literal> is 64 bits long.  In practice, however, on today&#8217;s real
computers, there is little variation; you can rely on the table
given previously (see <link linkend="Basic-Integers">Basic Integers</link>).
</para>
<para>To be completely sure of the size of an integer type,
use the types <literal>int16_t</literal>, <literal>int32_t</literal> and <literal>int64_t</literal>.
Their corresponding unsigned types add &#8216;<literal>u</literal>&#8217; at the front.
To define these, include the header file <filename>stdint.h</filename>.
</para>
<para>The GNU C Compiler compiles for some embedded controllers that use two
bytes for <literal>int</literal>.  On some, <literal>int</literal> is just one &#8220;byte,&#8221; and
so is <literal>short int</literal>&#8212;but that &#8220;byte&#8221; may contain 16 bits or even
32 bits.  These processors can&#8217;t support an ordinary operating system
(they may have their own specialized operating systems), and most C
programs do not try to support them.
</para>
</sect2>
</sect1>
<sect1 label="11.2" id="Floating_002dPoint-Data-Types">
<title>Floating-Point Data Types</title>
<indexterm role="cp"><primary>floating-point types</primary></indexterm>
<indexterm role="cp"><primary>types, floating-point</primary></indexterm>
<indexterm role="fn"><primary>double</primary></indexterm>
<indexterm role="fn"><primary>float</primary></indexterm>
<indexterm role="fn"><primary>long double</primary></indexterm>

<para><firstterm>Floating point</firstterm> is the binary analogue of scientific notation:
internally it represents a number as a fraction and a binary exponent; the
value is that fraction multiplied by the specified power of 2.
</para>
<para>For instance, to represent 6, the fraction would be 0.75 and the
exponent would be 3; together they stand for the value <inlineequation><mathphrase>0.75 * 2<superscript>3</superscript></mathphrase></inlineequation>,
meaning 0.75 * 8.  The value 1.5 would use 0.75 as the fraction and 1
as the exponent.  The value 0.75 would use 0.75 as the fraction and 0
as the exponent.  The value 0.375 would use 0.75 as the fraction and
-1 as the exponent.
</para>
<para>These binary exponents are used by machine instructions.  You can
write a floating-point constant this way if you wish, using
hexadecimal; but normally we write floating-point numbers in decimal.
See <link linkend="Floating-Constants">Floating Constants</link>.
</para>
<para>C has three floating-point data types:
</para>
<variablelist><varlistentry><term><literal>double</literal>
</term><listitem><para>&#8220;Double-precision&#8221; floating point, which uses 64 bits.  This is the
normal floating-point type, and modern computers normally do
their floating-point computations in this type, or some wider type.
Except when there is a special reason to do otherwise, this is the 
type to use for floating-point values.
</para>
</listitem></varlistentry><varlistentry><term><literal>float</literal>
</term><listitem><para>&#8220;Single-precision&#8221; floating point, which uses 32 bits.  It is useful
for floating-point values stored in structures and arrays, to save
space when the full precision of <literal>double</literal> is not needed.  In
addition, single-precision arithmetic is faster on some computers, and
occasionally that is useful.  But not often&#8212;most programs don&#8217;t use
the type <literal>float</literal>.
</para>
<para>C would be cleaner if <literal>float</literal> were the name of the type we 
use for most floating-point values; however, for historical reasons,
that&#8217;s not so.
</para>
</listitem></varlistentry><varlistentry><term><literal>long double</literal>
</term><listitem><para>&#8220;Extended-precision&#8221; floating point is either 80-bit or 128-bit
precision, depending on the machine in use.  On some machines, which
have no floating-point format wider than <literal>double</literal>, this is
equivalent to <literal>double</literal>.
</para></listitem></varlistentry></variablelist>
<para>Floating-point arithmetic raises many subtle issues.  See <link linkend="Floating-Point-in-Depth">Floating
Point in Depth</link>, for more information.
</para>
</sect1>
<sect1 label="11.3" id="Complex-Data-Types">
<title>Complex Data Types</title>
<indexterm role="cp"><primary>complex numbers</primary></indexterm>
<indexterm role="cp"><primary>types, complex</primary></indexterm>
<indexterm role="cp"><primary><literal>_Complex</literal> keyword</primary></indexterm>
<indexterm role="cp"><primary><literal>__complex__</literal> keyword</primary></indexterm>
<indexterm role="fn"><primary>_Complex</primary></indexterm>
<indexterm role="fn"><primary>__complex__</primary></indexterm>

<para>Complex numbers can include both a real part and an imaginary part.
The numeric constants covered above have real-numbered values.  An
imaginary-valued constant is an ordinary real-valued constant followed
by &#8216;<literal>i</literal>&#8217;.
</para>
<para>To declare numeric variables as complex, use the <literal>_Complex</literal>
keyword.<footnote><para>For compatibility with older versions of GNU C, the
keyword <literal>__complex__</literal> is also allowed.  Going forward, however,
use the new <literal>_Complex</literal> keyword as defined in ISO C11.</para></footnote>  The
standard C complex data types are floating point,
</para>
<screen>_Complex float foo;
_Complex double bar;
_Complex long double quux;
</screen>
<para>but GNU C supports integer complex types as well.
</para>
<para>Since <literal>_Complex</literal> is a keyword just like <literal>float</literal> and
<literal>double</literal> and <literal>long</literal>, the keywords can appear in any order,
but the order shown above seems most logical.
</para>
<para>GNU C supports constants for complex values; for instance, <literal>4.0 +
3.0i</literal> has the value 4 + 3i as type <literal>_Complex double</literal>.
See <link linkend="Imaginary-Constants">Imaginary Constants</link>.
</para>
<para>To pull the real and imaginary parts of the number back out, GNU C
provides the keywords <literal>__real__</literal> and <literal>__imag__</literal>:
</para>
<screen>_Complex double foo = 4.0 + 3.0i;

double a = __real__ foo; /* <literal>a</literal> is now 4.0. */
double b = __imag__ foo; /* <literal>b</literal> is now 3.0. */
</screen>
<para>Standard C does not include these keywords, and instead relies on
functions defined in <literal>complex.h</literal> for accessing the real and
imaginary parts of a complex number: <literal>crealf</literal>, <literal>creal</literal>, and
<literal>creall</literal> extract the real part of a float, double, or long double
complex number, respectively; <literal>cimagf</literal>, <literal>cimag</literal>, and
<literal>cimagl</literal> extract the imaginary part.
</para>
<indexterm role="cp"><primary>complex conjugation</primary></indexterm>
<para>GNU C also defines &#8216;<literal>~</literal>&#8217; as an operator for complex conjugation,
which means negating the imaginary part of a complex number:
</para>
<screen>_Complex double foo = 4.0 + 3.0i;
_Complex double bar = ~foo; /* <literal>bar</literal> is now 4 &#8722; 3i. */
</screen>
<para>For standard C compatibility, you can use the appropriate library
function: <literal>conjf</literal>, <literal>conj</literal>, or <literal>confl</literal>.
</para>
</sect1>
<sect1 label="11.4" id="The-Void-Type">
<title>The Void Type</title>
<indexterm role="cp"><primary>void type</primary></indexterm>
<indexterm role="cp"><primary>type, void</primary></indexterm>
<indexterm role="fn"><primary>void</primary></indexterm>

<para>The data type <literal>void</literal> is a dummy&#8212;it allows no operations.  It
really means &#8220;no value at all.&#8221;  When a function is meant to return
no value, we write <literal>void</literal> for its return type.  Then
<literal>return</literal> statements in that function should not specify a value
(see <link linkend="return-Statement">return Statement</link>).  Here&#8217;s an example:
</para>
<screen>void
print_if_positive (double x, double y)
{
  if (x &lt;= 0)
    return;
  if (y &lt;= 0)
    return;
  printf (&quot;Next point is (%f,%f)\n&quot;, x, y);
}
</screen>
<para>A <literal>void</literal>-returning function is comparable to what some other languages
call a &#8220;procedure&#8221; instead of a &#8220;function.&#8221;
</para>
<!-- ??? Already presented -->
<!-- @samp{%f} in an output template specifies to format a @code{double} value -->
<!-- as a decimal number, using a decimal point if needed. -->

</sect1>
<sect1 label="11.5" id="Other-Data-Types">
<title>Other Data Types</title>

<para>Beyond the primitive types, C provides several ways to construct new
data types.  For instance, you can define <firstterm>pointers</firstterm>, values that
represent the addresses of other data (see <link linkend="Pointers">Pointers</link>).  You can
define <firstterm>structures</firstterm>, as in many other languages
(see <link linkend="Structures">Structures</link>), and <firstterm>unions</firstterm>, which specify multiple ways
to look at the same memory space (see <link linkend="Unions">Unions</link>).  <firstterm>Enumerations</firstterm>
are collections of named integer codes (see <link linkend="Enumeration-Types">Enumeration Types</link>).
</para>
<para><firstterm>Array types</firstterm> in C are used for allocating space for objects,
but C does not permit operating on an array value as a whole.  See <link linkend="Arrays">Arrays</link>.
</para>
</sect1>
<sect1 label="11.6" id="Type-Designators">
<title>Type Designators</title>
<indexterm role="cp"><primary>type designator</primary></indexterm>

<para>Some C constructs require a way to designate a specific data type
independent of any particular variable or expression which has that
type.  The way to do this is with a <firstterm>type designator</firstterm>.  The
constucts that need one include casts (see <link linkend="Explicit-Type-Conversion">Explicit Type
Conversion</link>) and <literal>sizeof</literal> (see <link linkend="Type-Size">Type Size</link>).
</para>
<para>We also use type designators to talk about the type of a value in C,
so you will see many type designators in this manual.  When we say,
&#8220;The value has type <literal>int</literal>,&#8221; <literal>int</literal> is a type designator.
</para>
<para>To make the designator for any type, imagine a variable declaration
for a variable of that type and delete the variable name and the final
semicolon.
</para>
<para>For example, to designate the type of full-word integers, we start
with the declaration for a variable <literal>foo</literal> with that type,
which is this:
</para>
<screen>int foo;
</screen>
<para>Then we delete the variable name <literal>foo</literal> and the semicolon, leaving
<literal>int</literal>&#8212;exactly the keyword used in such a declaration.
Therefore, the type designator for this type is <literal>int</literal>.
</para>
<para>What about long unsigned integers?  From the declaration
</para>
<screen>unsigned long int foo;
</screen>
<para>we determine that the designator is <literal>unsigned long int</literal>.
</para>
<para>Following this procedure, the designator for any primitive type is
simply the set of keywords which specifies that type in a declaration.
The same is true for compound types such as structures, unions, and
enumerations.
</para>
<para>Designators for pointer types do follow the rule of deleting the
variable name and semicolon, but the result is not so simple.
See <link linkend="Pointer-Type-Designators">Pointer Type Designators</link>, as part of the chapter about
pointers.  See <link linkend="Array-Type-Designators">Array Type Designators</link>), for designators for array
types.
</para>
<para>To understand what type a designator stands for, imagine a variable
name inserted into the right place in the designator to make a valid
declaration.  What type would that variable be declared as?  That is the
type the designator designates.
</para>
</sect1>
</chapter>
<chapter label="12" id="Constants">
<title>Constants</title>
<indexterm role="cp"><primary>constants</primary></indexterm>

<para>A <firstterm>constant</firstterm> is an expression that stands for a specific value by
explicitly representing the desired value.  C allows constants for
numbers, characters, and strings.  We have already seen numeric and
string constants in the examples.
</para>

<sect1 label="12.1" id="Integer-Constants">
<title>Integer Constants</title>
<indexterm role="cp"><primary>integer constants</primary></indexterm>
<indexterm role="cp"><primary>constants, integer</primary></indexterm>

<para>An integer constant consists of a number to specify the value,
followed optionally by suffix letters to specify the data type.
</para>
<para>The simplest integer constants are numbers written in base 10
(decimal), such as <literal>5</literal>, <literal>77</literal>, and <literal>403</literal>.  A decimal
constant cannot start with the character &#8216;<literal>0</literal>&#8217; (zero) because
that makes the constant octal.
</para>
<para>You can get the effect of a negative integer constant by putting a
minus sign at the beginning.  Grammatically speaking, that is an
arithmetic expression rather than a constant, but it behaves just like
a true constant.
</para>
<para>Integer constants can also be written in octal (base 8), hexadecimal
(base 16), or binary (base 2).  An octal constant starts with the
character &#8216;<literal>0</literal>&#8217; (zero), followed by any number of octal digits
(&#8216;<literal>0</literal>&#8217; to &#8216;<literal>7</literal>&#8217;):
</para>
<screen>0      // zero
077    // 63
0403   // 259
</screen>
<para>Pedantically speaking, the constant <literal>0</literal> is an octal constant, but
we can think of it as decimal; it has the same value either way.
</para>
<para>A hexadecimal constant starts with &#8216;<literal>0x</literal>&#8217; (upper or lower case)
followed by hex digits (&#8216;<literal>0</literal>&#8217; to &#8216;<literal>9</literal>&#8217;, as well as &#8216;<literal>a</literal>&#8217;
through &#8216;<literal>f</literal>&#8217; in upper or lower case):
</para>
<screen>0xff   // 255
0XA0   // 160
0xffFF // 65535
</screen>
<indexterm role="cp"><primary>binary integer constants</primary></indexterm>
<para>A binary constant starts with &#8216;<literal>0b</literal>&#8217; (upper or lower case) followed
by bits (each represented by the characters &#8216;<literal>0</literal>&#8217; or &#8216;<literal>1</literal>&#8217;):
</para>
<screen>0b101  // 5
</screen>
<para>Binary constants are a GNU C extension, not part of the C standard.
</para>
<para>Sometimes a space is needed after an integer constant to avoid
lexical confusion with the following tokens.  See <link linkend="Invalid-Numbers">Invalid Numbers</link>.
</para>
</sect1>
<sect1 label="12.2" id="Integer-Const-Type">
<title>Integer Constant Data Types</title>
<indexterm role="cp"><primary>integer constant data types</primary></indexterm>
<indexterm role="cp"><primary>constant data types, integer</primary></indexterm>
<indexterm role="cp"><primary>types of integer constants</primary></indexterm>

<para>The type of an integer constant is normally <literal>int</literal>, if the value
fits in that type, but here are the complete rules.  The type
of an integer constant is the first one in this sequence that can
properly represent the value,
</para>
<orderedlist numeration="arabic"><listitem><para><literal>int</literal>
</para></listitem><listitem><para><literal>unsigned int</literal>
</para></listitem><listitem><para><literal>long int</literal>
</para></listitem><listitem><para><literal>unsigned long int</literal>
</para></listitem><listitem><para><literal>long long int</literal>
</para></listitem><listitem><para><literal>unsigned long long int</literal>
</para></listitem></orderedlist>
<para>and that isn&#8217;t excluded by the following rules.
</para>
<para>If the constant has &#8216;<literal>l</literal>&#8217; or &#8216;<literal>L</literal>&#8217; as a suffix, that excludes the
first two types (non-<literal>long</literal>).
</para>
<para>If the constant has &#8216;<literal>ll</literal>&#8217; or &#8216;<literal>LL</literal>&#8217; as a suffix, that excludes
first four types (non-<literal>long long</literal>).
</para>
<para>If the constant has &#8216;<literal>u</literal>&#8217; or &#8216;<literal>U</literal>&#8217; as a suffix, that excludes
the signed types.
</para>
<para>Otherwise, if the constant is decimal, that excludes the unsigned
types.
<!-- ### This said @code{unsigned int} is excluded. -->
<!-- ### See 17 April 2016 -->
</para>
<para>Here are some examples of the suffixes.
</para>
<screen>3000000000u      // three billion as <literal>unsigned int</literal>.
0LL              // zero as a <literal>long long int</literal>.
0403l            // 259 as a <literal>long int</literal>.
</screen>
<para>Suffixes in integer constants are rarely used.  When the precise type
is important, it is cleaner to convert explicitly (see <link linkend="Explicit-Type-Conversion">Explicit
Type Conversion</link>).
</para>
<para>See <link linkend="Integer-Types">Integer Types</link>.
</para>
</sect1>
<sect1 label="12.3" id="Floating-Constants">
<title>Floating-Point Constants</title>
<indexterm role="cp"><primary>floating-point constants</primary></indexterm>
<indexterm role="cp"><primary>constants, floating-point</primary></indexterm>

<para>A floating-point constant must have either a decimal point, an
exponent-of-ten, or both; they distinguish it from an integer
constant.
</para>
<para>To indicate an exponent, write &#8216;<literal>e</literal>&#8217; or &#8216;<literal>E</literal>&#8217;.  The exponent
value follows.  It is always written as a decimal number; it can
optionally start with a sign.  The exponent <replaceable>n</replaceable> means to multiply
the constant&#8217;s value by ten to the <replaceable>n</replaceable>th power.
</para>
<para>Thus, &#8216;<literal>1500.0</literal>&#8217;, &#8216;<literal>15e2</literal>&#8217;, &#8216;<literal>15e+2</literal>&#8217;, &#8216;<literal>15.0e2</literal>&#8217;,
&#8216;<literal>1.5e+3</literal>&#8217;, &#8216;<literal>.15e4</literal>&#8217;, and &#8216;<literal>15000e-1</literal>&#8217; are six ways of
writing a floating-point number whose value is 1500.  They are all
equivalent.
</para>
<para>Here are more examples with decimal points:
</para>
<screen>1.0
1000.
3.14159
.05
.0005
</screen>
<para>For each of them, here are some equivalent constants written with
exponents:
</para>
<screen>1e0, 1.0000e0
100e1, 100e+1, 100E+1, 1e3, 10000e-1
3.14159e0
5e-2, .0005e+2, 5E-2, .0005E2
.05e-2
</screen>
<para>A floating-point constant normally has type <literal>double</literal>.  You can
force it to type <literal>float</literal> by adding &#8216;<literal>f</literal>&#8217; or &#8216;<literal>F</literal>&#8217;
at the end.  For example,
</para>
<screen>3.14159f
3.14159e0f
1000.f
100E1F
.0005f
.05e-2f
</screen>
<para>Likewise, &#8216;<literal>l</literal>&#8217; or &#8216;<literal>L</literal>&#8217; at the end forces the constant
to type <literal>long double</literal>.
</para>
<para>You can use exponents in hexadecimal floating constants, but since
&#8216;<literal>e</literal>&#8217; would be interpreted as a hexadecimal digit, the character
&#8216;<literal>p</literal>&#8217; or &#8216;<literal>P</literal>&#8217; (for &#8220;power&#8221;) indicates an exponent.
</para>
<para>The exponent in a hexadecimal floating constant is a possibly-signed
decimal integer that specifies a power of 2 (<emphasis>not</emphasis> 10 or 16) to
multiply into the number.
</para>
<para>Here are some examples:
</para>
<screen>0xAp2        // 40 in decimal
0xAp-1       // 5 in decimal
0x2.0Bp4     // 16.75 decimal
0xE.2p3      // 121 decimal
0x123.ABCp0  // 291.6708984375 in decimal
0x123.ABCp4  // 4666.734375 in decimal
0x100p-8     // 1
0x10p-4      // 1
0x1p+4       // 16
0x1p+8       // 256
</screen>
<para>See <link linkend="Floating_002dPoint-Data-Types">Floating-Point Data Types</link>.
</para>
</sect1>
<sect1 label="12.4" id="Imaginary-Constants">
<title>Imaginary Constants</title>
<indexterm role="cp"><primary>imaginary constants</primary></indexterm>
<indexterm role="cp"><primary>complex constants</primary></indexterm>
<indexterm role="cp"><primary>constants, imaginary</primary></indexterm>

<para>A complex number consists of a real part plus an imaginary part.
(Either or both parts may be zero.)  This section explains how to
write numeric constants with imaginary values.  By adding these to
ordinary real-valued numeric constants, we can make constants with
complex values.
</para>
<para>The simple way to write an imaginary-number constant is to attach the
suffix &#8216;<literal>i</literal>&#8217; or &#8216;<literal>I</literal>&#8217;, or &#8216;<literal>j</literal>&#8217; or &#8216;<literal>J</literal>&#8217;, to an integer or
floating-point constant.  For example, <literal>2.5fi</literal> has type
<literal>_Complex float</literal> and <literal>3i</literal> has type <literal>_Complex int</literal>.
The four alternative suffix letters are all equivalent.
</para>
<indexterm role="cp"><primary>_Complex_I</primary></indexterm>
<para>The other way to write an imaginary constant is to multiply a real
constant by <literal>_Complex_I</literal>, which represents the imaginary number
i.  Standard C doesn&#8217;t support suffixing with &#8216;<literal>i</literal>&#8217; or &#8216;<literal>j</literal>&#8217;, so
this clunky way is needed.
</para>
<para>To write a complex constant with a nonzero real part and a nonzero
imaginary part, write the two separately and add them, like this:
</para>
<screen>4.0 + 3.0i
</screen>
<para>That gives the value 4 + 3i, with type <literal>_Complex double</literal>.
</para>
<para>Such a sum can include multiple real constants, or none.  Likewise, it
can include multiple imaginary constants, or none.  For example:
</para>
<screen>_Complex double foo, bar, quux;

foo = 2.0i + 4.0 + 3.0i; /* Imaginary part is 5.0. */
bar = 4.0 + 12.0; /* Imaginary part is 0.0. */
quux = 3.0i + 15.0i; /* Real part is 0.0. */
</screen>
<para>See <link linkend="Complex-Data-Types">Complex Data Types</link>.
</para>
</sect1>
<sect1 label="12.5" id="Invalid-Numbers">
<title>Invalid Numbers</title>

<para>Some number-like constructs which are not really valid as numeric
constants are treated as numbers in preprocessing directives.  If
these constructs appear outside of preprocessing, they are erroneous.
See <link linkend="Preprocessing-Tokens">Preprocessing Tokens</link>.
</para>
<para>Sometimes we need to insert spaces to separate tokens so that they
won&#8217;t be combined into a single number-like construct.  For example,
<literal>0xE+12</literal> is a preprocessing number that is not a valid numeric
constant, so it is a syntax error.  If what we want is the three
tokens <literal>0xE + 12<!-- /@w --></literal>, we have to use those spaces as separators.
</para>
</sect1>
<sect1 label="12.6" id="Character-Constants">
<title>Character Constants</title>
<indexterm role="cp"><primary>character constants</primary></indexterm>
<indexterm role="cp"><primary>constants, character</primary></indexterm>
<indexterm role="cp"><primary>escape sequence</primary></indexterm>

<para>A <firstterm>character constant</firstterm> is written with single quotes, as in
<literal>'<replaceable>c</replaceable>'</literal>.  In the simplest case, <replaceable>c</replaceable> is a single ASCII
character that the constant should represent.  The constant has type
<literal>int</literal>, and its value is the character code of that character.
For instance, <literal>'a'</literal> represents the character code for the letter
&#8216;<literal>a</literal>&#8217;: 97, that is.
</para>
<para>To put the &#8216;<literal>'</literal>&#8217; character (single quote) in the character
constant, <firstterm>quote</firstterm> it with a backslash (&#8216;<literal>\</literal>&#8217;).  This character
constant looks like <literal>'\''</literal>.  This sort of sequence, starting with
&#8216;<literal>\</literal>&#8217;, is called an <firstterm>escape sequence</firstterm>&#8212;the backslash character
here functions as a kind of <firstterm>escape character</firstterm>.
</para>
<para>To put the &#8216;<literal>\</literal>&#8217; character (backslash) in the character constant,
quote it likewise with &#8216;<literal>\</literal>&#8217; (another backslash).  This character
constant looks like <literal>'\\'</literal>.
</para>
<indexterm role="cp"><primary>bell character</primary></indexterm>
<indexterm role="cp"><primary>&#8216;<literal>\a</literal>&#8217;</primary></indexterm>
<indexterm role="cp"><primary>backspace</primary></indexterm>
<indexterm role="cp"><primary>&#8216;<literal>\b</literal>&#8217;</primary></indexterm>
<indexterm role="cp"><primary>tab (ASCII character)</primary></indexterm>
<indexterm role="cp"><primary>&#8216;<literal>\t</literal>&#8217;</primary></indexterm>
<indexterm role="cp"><primary>vertical tab</primary></indexterm>
<indexterm role="cp"><primary>&#8216;<literal>\v</literal>&#8217;</primary></indexterm>
<indexterm role="cp"><primary>formfeed</primary></indexterm>
<indexterm role="cp"><primary>&#8216;<literal>\f</literal>&#8217;</primary></indexterm>
<indexterm role="cp"><primary>newline</primary></indexterm>
<indexterm role="cp"><primary>&#8216;<literal>\n</literal>&#8217;</primary></indexterm>
<indexterm role="cp"><primary>return (ASCII character)</primary></indexterm>
<indexterm role="cp"><primary>&#8216;<literal>\r</literal>&#8217;</primary></indexterm>
<indexterm role="cp"><primary>escape (ASCII character)</primary></indexterm>
<indexterm role="cp"><primary>&#8216;<literal>\e</literal>&#8217;</primary></indexterm>
<para>Here are all the escape sequences that represent specific
characters in a character constant.  The numeric values shown are
the corresponding ASCII character codes, as decimal numbers.
</para>
<screen>'\a' &#8658; 7       /* alarm, <userinput>CTRL-g</userinput> */
'\b' &#8658; 8       /* backspace, <keycap>BS</keycap>, <userinput>CTRL-h</userinput> */
'\t' &#8658; 9       /* tab, <keycap>TAB</keycap>, <userinput>CTRL-i</userinput> */
'\n' &#8658; 10      /* newline, <userinput>CTRL-j</userinput> */
'\v' &#8658; 11      /* vertical tab, <userinput>CTRL-k</userinput> */
'\f' &#8658; 12      /* formfeed, <userinput>CTRL-l</userinput> */
'\r' &#8658; 13      /* carriage return, <keycap>RET</keycap>, <userinput>CTRL-m</userinput> */
'\e' &#8658; 27      /* escape character, <keycap>ESC</keycap>, <userinput>CTRL-[</userinput> */
'\\' &#8658; 92      /* backslash character, <userinput>\</userinput> */
'\'' &#8658; 39      /* singlequote character, <userinput>'</userinput> */
'\&quot;' &#8658; 34      /* doublequote character, <userinput>&quot;</userinput> */
'\?' &#8658; 63      /* question mark, <userinput>?</userinput> */
</screen>
<para>&#8216;<literal>\e</literal>&#8217; is a GNU C extension; to stick to standard C, write &#8216;<literal>\33</literal>&#8217;.
</para>
<para>You can also write octal and hex character codes as
&#8216;<literal>\<replaceable>octalcode</replaceable></literal>&#8217; or &#8216;<literal>\x<replaceable>hexcode</replaceable></literal>&#8217;.  Decimal is not an
option here, so octal codes do not need to start with &#8216;<literal>0</literal>&#8217;.
</para>
<para>The character constant&#8217;s value has type <literal>int</literal>.  However, the
character code is treated initially as a <literal>char</literal> value, which is
then converted to <literal>int</literal>.  If the character code is greater than
127 (<literal>0177</literal> in octal), the resulting <literal>int</literal> may be negative
on a platform where the type <literal>char</literal> is 8 bits long and signed.
</para>
</sect1>
<sect1 label="12.7" id="String-Constants">
<title>String Constants</title>
<indexterm role="cp"><primary>string constants</primary></indexterm>
<indexterm role="cp"><primary>constants, string</primary></indexterm>

<para>A <firstterm>string constant</firstterm> represents a series of characters.  It starts
with &#8216;<literal>&quot;</literal>&#8217; and ends with &#8216;<literal>&quot;</literal>&#8217;; in between are the contents of
the string.  Quoting special characters such as &#8216;<literal>&quot;</literal>&#8217;, &#8216;<literal>\</literal>&#8217; and
newline in the contents works in string constants as in character
constants.  In a string constant, &#8216;<literal>'</literal>&#8217; does not need to be quoted.
</para>
<para>A string constant defines an array of characters which contains the
specified characters followed by the null character (code 0).  Using
the string constant is equivalent to using the name of an array with
those contents.  In simple cases, the length in bytes of the string
constant is one greater than the number of characters written in it.
</para>
<para>As with any array in C, using the string constant in an expression
converts the array to a pointer (see <link linkend="Pointers">Pointers</link>) to the array&#8217;s
first element (see <link linkend="Accessing-Array-Elements">Accessing Array Elements</link>).  This pointer will
have type <literal>char *</literal> because it points to an element of type
<literal>char</literal>.  <literal>char *</literal> is an example of a type designator for a
pointer type (see <link linkend="Pointer-Type-Designators">Pointer Type Designators</link>).  That type is used
for strings generally, not just the strings expressed as constants
in a program.
</para>
<para>Thus, the string constant <literal>&quot;Foo!&quot;</literal> is almost
equivalent to declaring an array like this
</para>
<screen>char string_array_1[] = {'F', 'o', 'o', '!', '\0' };
</screen>
<para>and then using <literal>string_array_1</literal> in the program.  There
are two differences, however:
</para>
<itemizedlist><listitem><para>The string constant doesn&#8217;t define a name for the array.
</para>
</listitem><listitem><para>The string constant is probably stored in a read-only area of memory.
</para></listitem></itemizedlist>
<para>Newlines are not allowed in the text of a string constant.  The motive
for this prohibition is to catch the error of omitting the closing
&#8216;<literal>&quot;</literal>&#8217;.  To put a newline in a constant string, write it as
&#8216;<literal>\n</literal>&#8217; in the string constant.
</para>
<para>A real null character in the source code inside a string constant
causes a warning.  To put a null character in the middle of a string
constant, write &#8216;<literal>\0</literal>&#8217; or &#8216;<literal>\000</literal>&#8217;.
</para>
<para>Consecutive string constants are effectively concatenated.  Thus,
</para>
<screen>&quot;Fo&quot; &quot;o!&quot;   is equivalent to   &quot;Foo!&quot;
</screen>
<para>This is useful for writing a string containing multiple lines,
like this:
</para>
<screen>&quot;This message is so long that it needs more than\n&quot;
&quot;a single line of text.  C does not allow a newline\n&quot;
&quot;to represent itself in a string constant, so we have to\n&quot;
&quot;write \\n to put it in the string.  For readability of\n&quot;
&quot;the source code, it is advisable to put line breaks in\n&quot;
&quot;the source where they occur in the contents of the\n&quot;
&quot;constant.\n&quot;
</screen>
<para>The sequence of a backslash and a newline is ignored anywhere
in a C program, and that includes inside a string constant.
Thus, you can write multi-line string constants this way:
</para>
<screen>&quot;This is another way to put newlines in a string constant\n\
and break the line after them in the source code.&quot;
</screen>
<para>However, concatenation is the recommended way to do this.
</para>
<para>You can also write perverse string constants like this,
</para>
<screen>&quot;Fo\
o!&quot;
</screen>
<para>but don&#8217;t do that&#8212;write it like this instead:
</para>
<screen>&quot;Foo!&quot;
</screen>
<para>Be careful to avoid passing a string constant to a function that
modifies the string it receives.  The memory where the string constant
is stored may be read-only, which would cause a fatal <literal>SIGSEGV</literal>
signal that normally terminates the function (see <link linkend="Signals">Signals</link>.  Even
worse, the memory may not be read-only.  Then the function might
modify the string constant, thus spoiling the contents of other string
constants that are supposed to contain the same value and are unified
by the compiler.
</para>
</sect1>
<sect1 label="12.8" id="UTF_002d8-String-Constants">
<title>UTF-8 String Constants</title>
<indexterm role="cp"><primary>UTF-8 String Constants</primary></indexterm>

<para>Writing &#8216;<literal>u8</literal>&#8217; immediately before a string constant, with no
intervening space, means to represent that string in UTF-8 encoding as
a sequence of bytes.  UTF-8 represents ASCII characters with a single
byte, and represents non-ASCII Unicode characters (codes 128 and up)
as multibyte sequences.  Here is an example of a UTF-8 constant:
</para>
<screen>u8&quot;A cónstàñt&quot;
</screen>
<para>This constant occupies 13 bytes plus the terminating null,
because each of the accented letters is a two-byte sequence.
</para>
<para>Concatenating an ordinary string with a UTF-8 string conceptually
produces another UTF-8 string.  However, if the ordinary string
contains character codes 128 and up, the results cannot be relied on.
</para>
</sect1>
<sect1 label="12.9" id="Unicode-Character-Codes">
<title>Unicode Character Codes</title>
<indexterm role="cp"><primary>Unicode character codes</primary></indexterm>
<indexterm role="cp"><primary>universal character names</primary></indexterm>

<para>You can specify Unicode characters, for individual character constants
or as part of string constants (see <link linkend="String-Constants">String Constants</link>), using
escape sequences.  Use the &#8216;<literal>\u</literal>&#8217; escape sequence with a 16-bit
hexadecimal Unicode character code.  If the code value is too big for
16 bits, use the &#8216;<literal>\U</literal>&#8217; escape sequence with a 32-bit hexadecimal
Unicode character code.  (These codes are called <firstterm>universal
character names</firstterm>.)  For example,
</para>
<screen>\u6C34      /* 16-bit code (UTF-16) */
\U0010ABCD  /* 32-bit code (UTF-32) */
</screen>
<para>One way to use these is in UTF-8 string constants (see <link linkend="UTF_002d8-String-Constants">UTF-8 String
Constants</link>).  For instance,
</para>
<screen>u8&quot;fóó \u6C34 \U0010ABCD&quot;
</screen>
<para>You can also use them in wide character constants (see <link linkend="Wide-Character-Constants">Wide
Character Constants</link>), like this:
</para>
<screen>u'\u6C34'      /* 16-bit code */
U'\U0010ABCD'  /* 32-bit code */
</screen>
<para>and in wide string constants (see <link linkend="Wide-String-Constants">Wide String Constants</link>), like
this:
</para>
<screen>u&quot;\u6C34\u6C33&quot;  /* 16-bit code */
U&quot;\U0010ABCD&quot;    /* 32-bit code */
</screen>
<para>Codes in the range of <literal>D800</literal> through <literal>DFFF</literal> are not valid
in Unicode.  Codes less than <literal>00A0</literal> are also forbidden, except for
<literal>0024</literal>, <literal>0040</literal>, and <literal>0060</literal>; these characters are
actually ASCII control characters, and you can specify them with other
escape sequences (see <link linkend="Character-Constants">Character Constants</link>).
</para>
</sect1>
<sect1 label="12.10" id="Wide-Character-Constants">
<title>Wide Character Constants</title>
<indexterm role="cp"><primary>wide character constants</primary></indexterm>
<indexterm role="cp"><primary>constants, wide character</primary></indexterm>

<para>A <firstterm>wide character constant</firstterm> represents characters with more than 8
bits of character code.  This is an obscure feature that we need to
document but that you probably won&#8217;t ever use.  If you&#8217;re just
learning C, you may as well skip this section.
</para>
<para>The original C wide character constant looks like &#8216;<literal>L</literal>&#8217; (upper
case!) followed immediately by an ordinary character constant (with no
intervening space).  Its data type is <literal>wchar_t</literal>, which is an
alias defined in <filename>stddef.h</filename> for one of the standard integer
types.  Depending on the platform, it could be 16 bits or 32 bits.  If
it is 16 bits, these character constants use the UTF-16 form of
Unicode; if 32 bits, UTF-32.
</para>
<para>There are also Unicode wide character constants which explicitly
specify the width.  These constants start with &#8216;<literal>u</literal>&#8217; or &#8216;<literal>U</literal>&#8217;
instead of &#8216;<literal>L</literal>&#8217;.  &#8216;<literal>u</literal>&#8217; specifies a 16-bit Unicode wide
character constant, and &#8216;<literal>U</literal>&#8217; a 32-bit Unicode wide character
constant.  Their types are, respectively, <literal>char16_t</literal> and
<literal>char32_t</literal><!-- /@w -->; they are declared in the header file
<filename>uchar.h</filename>.  These character constants are valid even if
<filename>uchar.h</filename> is not included, but some uses of them may be
inconvenient without including it to declare those type names.
</para>
<para>The character represented in a wide character constant can be an
ordinary ASCII character.  <literal>L'a'</literal>, <literal>u'a'</literal> and <literal>U'a'</literal> 
are all valid, and they are all equal to <literal>'a'</literal>.
</para>
<para>In all three kinds of wide character constants, you can write a
non-ASCII Unicode character in the constant itself; the constant&#8217;s
value is the character&#8217;s Unicode character code.  Or you can specify
the Unicode character with an escape sequence (see <link linkend="Unicode-Character-Codes">Unicode
Character Codes</link>).
</para>
</sect1>
<sect1 label="12.11" id="Wide-String-Constants">
<title>Wide String Constants</title>
<indexterm role="cp"><primary>wide string constants</primary></indexterm>
<indexterm role="cp"><primary>constants, wide string</primary></indexterm>

<para>A <firstterm>wide string constant</firstterm> stands for an array of 16-bit or 32-bit
characters.  They are rarely used; if you&#8217;re just
learning C, you may as well skip this section.
</para>
<para>There are three kinds of wide string constants, which differ in the
data type used for each character in the string.  Each wide string
constant is equivalent to an array of integers, but the data type of
those integers depends on the kind of wide string.  Using the constant
in an expression will convert the array to a pointer to its first
element, as usual for arrays in C (see <link linkend="Accessing-Array-Elements">Accessing Array Elements</link>).
For each kind of wide string constant, we state here what type that
pointer will be.
</para>
<variablelist><varlistentry><term><literal>char16_t</literal>
</term><listitem><para>This is a 16-bit Unicode wide string constant: each element is a
16-bit Unicode character code with type <literal>char16_t</literal>, so the string
has the pointer type <literal>char16_t&#160;*</literal>.  (That is a type designator;
see <link linkend="Pointer-Type-Designators">Pointer Type Designators</link>.)  The constant is written as
&#8216;<literal>u</literal>&#8217; (which must be lower case) followed (with no intervening
space) by a string constant with the usual syntax.
</para>
</listitem></varlistentry><varlistentry><term><literal>char32_t</literal>
</term><listitem><para>This is a 32-bit Unicode wide string constant: each element is a
32-bit Unicode character code, and the string has type <literal>char32_t&#160;*</literal>.
It&#8217;s written as &#8216;<literal>U</literal>&#8217; (which must be upper case) followed (with no
intervening space) by a string constant with the usual syntax.
</para>
</listitem></varlistentry><varlistentry><term><literal>wchar_t</literal>
</term><listitem><para>This is the original kind of wide string constant.  It&#8217;s written as
&#8216;<literal>L</literal>&#8217; (which must be upper case) followed (with no intervening
space) by a string constant with the usual syntax, and the string has
type <literal>wchar_t&#160;*</literal>.
</para>
<para>The width of the data type <literal>wchar_t</literal> depends on the target
platform, which makes this kind of wide string somewhat less useful
than the newer kinds.
</para></listitem></varlistentry></variablelist>
<para><literal>char16_t</literal> and <literal>char32_t</literal> are declared in the header file
<filename>uchar.h</filename>.  <literal>wchar_t</literal> is declared in <filename>stddef.h</filename>.
</para>
<para>Consecutive wide string constants of the same kind concatenate, just
like ordinary string constants.  A wide string constant concatenated
with an ordinary string constant results in a wide string constant.
You can&#8217;t concatenate two wide string constants of different kinds.
You also can&#8217;t concatenate a wide string constant (of any kind) with a
UTF-8 string constant.
</para>
</sect1>
</chapter>
<chapter label="13" id="Type-Size">
<title>Type Size</title>
<indexterm role="cp"><primary>type size</primary></indexterm>
<indexterm role="cp"><primary>size of type</primary></indexterm>
<indexterm role="fn"><primary>sizeof</primary></indexterm>

<para>Each data type has a <firstterm>size</firstterm>, which is the number of bytes
(see <link linkend="Storage">Storage</link>) that it occupies in memory.  To refer to the size in
a C program, use <literal>sizeof</literal>.  There are two ways to use it:
</para>
<variablelist><varlistentry><term><literal>sizeof <replaceable>expression</replaceable></literal>
</term><listitem><para>This gives the size of <replaceable>expression</replaceable>, based on its data type.  It
does not calculate the value of <replaceable>expression</replaceable>, only its size, so if
<replaceable>expression</replaceable> includes side effects or function calls, they do not
happen.  Therefore, <literal>sizeof</literal> is always a compile-time operation
that has zero run-time cost.
</para>
<para>A value that is a bit field (see <link linkend="Bit-Fields">Bit Fields</link>) is not allowed as an
operand of <literal>sizeof</literal>.
</para>
<para>For example,
</para>
<screen>double a;

i = sizeof a + 10;
</screen>
<para>sets <literal>i</literal> to 18 on most computers because <literal>a</literal> occupies 8 bytes.
</para>
<para>Here&#8217;s how to determine the number of elements in an array
<literal>array</literal>:
</para>
<screen>(sizeof array / sizeof array[0])
</screen>
<para>The expression <literal>sizeof array</literal> gives the size of the array, not
the size of a pointer to an element.  However, if <replaceable>expression</replaceable> is
a function parameter that was declared as an array, that
variable really has a pointer type (see <link linkend="Array-Parm-Pointer">Array Parm Pointer</link>), so
the result is the size of that pointer.
</para>
</listitem></varlistentry><varlistentry><term><literal>sizeof (<replaceable>type</replaceable>)</literal>
</term><listitem><para>This gives the size of <replaceable>type</replaceable>.
For example,
</para>
<screen>i = sizeof (double) + 10;
</screen>
<para>is equivalent to the previous example.
</para>
<para>You can&#8217;t apply <literal>sizeof</literal> to an incomplete type (see <link linkend="Incomplete-Types">Incomplete
Types</link>), nor <literal>void</literal>.  Using it on a function type gives 1 in GNU
C, which makes adding an integer to a function pointer work as desired
(see <link linkend="Pointer-Arithmetic">Pointer Arithmetic</link>).
</para></listitem></varlistentry></variablelist>
<para><emphasis role="bold">Warning</emphasis>: When you use <literal>sizeof</literal> with a type
instead of an expression, you must write parentheses around the type.
</para>
<para><emphasis role="bold">Warning</emphasis>: When applying <literal>sizeof</literal> to the result of a cast
(see <link linkend="Explicit-Type-Conversion">Explicit Type Conversion</link>), you must write parentheses around
the cast expression to avoid an ambiguity in the grammar of C.
Specifically,
</para>
<screen>sizeof (int) -x
</screen>
<para>parses as
</para>
<screen>(sizeof (int)) - x
</screen>
<para>If what you want is
</para>
<screen>sizeof ((int) -x)
</screen>
<para>you must write it that way, with parentheses.
</para>
<para>The data type of the value of the <literal>sizeof</literal> operator is always one
of the unsigned integer types; which one of those types depends on the
machine.  The header file <literal>stddef.h</literal> defines the typedef name
<literal>size_t</literal> as an alias for this type.  See <link linkend="Defining-Typedef-Names">Defining Typedef
Names</link>.
</para>
</chapter>
<chapter label="14" id="Pointers">
<title>Pointers</title>
<indexterm role="cp"><primary>pointers</primary></indexterm>

<para>Among high-level languages, C is rather low level, close to the
machine.  This is mainly because it has explicit <firstterm>pointers</firstterm>.  A
pointer value is the numeric address of data in memory.  The type of
data to be found at that address is specified by the data type of the
pointer itself.  The unary operator &#8216;<literal>*</literal>&#8217; gets the data that a
pointer points to&#8212;this is called <firstterm>dereferencing the pointer</firstterm>.
</para>
<para>C also allows pointers to functions, but since there are some
differences in how they work, we treat them later.  See <link linkend="Function-Pointers">Function
Pointers</link>.
</para>

<sect1 label="14.1" id="Address-of-Data">
<title>Address of Data</title>

<indexterm role="cp"><primary>address-of operator</primary></indexterm>
<para>The most basic way to make a pointer is with the &#8220;address-of&#8221;
operator, &#8216;<literal>&amp;</literal>&#8217;.  Let&#8217;s suppose we have these variables available:
</para>
<screen>int i;
double a[5];
</screen>
<para>Now, <literal>&amp;i</literal> gives the address of the variable <literal>i</literal>&#8212;a pointer
value that points to <literal>i</literal>&#8217;s location&#8212;and <literal>&amp;a[3]</literal> gives the
address of the element 3 of <literal>a</literal>.  (It is actually the fourth
element in the array, since the first element has index 0.)
</para>
<para>The address-of operator is unusual because it operates on a place to
store a value (an lvalue, see <link linkend="Lvalues">Lvalues</link>), not on the value currently
stored there.  (The left argument of a simple assignment is unusual in
the same way.)  You can use it on any lvalue except a bit field
(see <link linkend="Bit-Fields">Bit Fields</link>) or a constructor (see <link linkend="Structure-Constructors">Structure
Constructors</link>).
</para>

</sect1>
<sect1 label="14.2" id="Pointer-Types">
<title>Pointer Types</title>

<para>For each data type <replaceable>t</replaceable>, there is a type for pointers to type
<replaceable>t</replaceable>.  For these variables,
</para>
<screen>int i;
double a[5];
</screen>
<itemizedlist><listitem><para><literal>i</literal> has type <literal>int</literal>; we say
<literal>&amp;i</literal> is a &#8220;pointer to <literal>int</literal>.&#8221;
</para>
</listitem><listitem><para><literal>a</literal> has type <literal>double[5]</literal>; we say <literal>&amp;a</literal> is a &#8220;pointer to
arrays of five <literal>double</literal>s.&#8221;
</para>
</listitem><listitem><para><literal>a[3]</literal> has type <literal>double</literal>; we say <literal>&amp;a[3]</literal> is a &#8220;pointer
to <literal>double</literal>.&#8221;
</para></listitem></itemizedlist>
</sect1>
<sect1 label="14.3" id="Pointer-Declarations">
<title>Pointer-Variable Declarations</title>

<para>The way to declare that a variable <literal>foo</literal> points to type <replaceable>t</replaceable> is
</para>
<screen><replaceable>t</replaceable> *foo;
</screen>
<para>To remember this syntax, think &#8220;if you dereference <literal>foo</literal>, using
the &#8216;<literal>*</literal>&#8217; operator, what you get is type <replaceable>t</replaceable>.  Thus, <literal>foo</literal>
points to type <replaceable>t</replaceable>.&#8221;
</para>
<para>Thus, we can declare variables that hold pointers to these three
types, like this:
</para>
<screen>int *ptri;            /* Pointer to <literal>int</literal>. */
double *ptrd;         /* Pointer to <literal>double</literal>. */
double (*ptrda)[5];   /* Pointer to <literal>double[5]</literal>. */
</screen>
<para>&#8216;<literal>int *ptri;</literal>&#8217; means, &#8220;if you dereference <literal>ptri</literal>, you get an
<literal>int</literal>.&#8221;  &#8216;<literal>double (*ptrda)[5];</literal>&#8217; means, &#8220;if you dereference
<literal>ptrda</literal>, then subscript it by an integer less than 5, you get a
<literal>double</literal>.&#8221;  The parentheses express the point that you would
dereference it first, then subscript it.
</para>
<para>Contrast the last one with this:
</para>
<screen>double *aptrd[5];     /* Array of five pointers to <literal>double</literal>. */
</screen>
<para>Because &#8216;<literal>*</literal>&#8217; has higher syntactic precedence than subscripting,
you would subscript <literal>aptrd</literal> then dereference it.  Therefore, it
declares an array of pointers, not a pointer.
</para>
</sect1>
<sect1 label="14.4" id="Pointer-Type-Designators">
<title>Pointer-Type Designators</title>

<para>Every type in C has a designator; you make it by deleting the variable
name and the semicolon from a declaration (see <link linkend="Type-Designators">Type
Designators</link>).  Here are the designators for the pointer
types of the example declarations in the previous section:
</para>
<screen>int *           /* Pointer to <literal>int</literal>. */
double *        /* Pointer to <literal>double</literal>. */
double (*)[5]   /* Pointer to <literal>double[5]</literal>. */
</screen>
<para>Remember, to understand what type a designator stands for, imagine the
variable name that would be in the declaration, and figure out what
type it would declare that variable with.  <literal>double (*)[5]</literal> can
only come from <literal>double (*<replaceable>variable</replaceable>)[5]</literal>, so it&#8217;s a pointer
which, when dereferenced, gives an array of 5 <literal>double</literal>s.
</para>
</sect1>
<sect1 label="14.5" id="Pointer-Dereference">
<title>Dereferencing Pointers</title>
<indexterm role="cp"><primary>dereferencing pointers</primary></indexterm>
<indexterm role="cp"><primary>pointer dereferencing</primary></indexterm>

<para>The main use of a pointer value is to <firstterm>dereference it</firstterm> (access the
data it points at) with the unary &#8216;<literal>*</literal>&#8217; operator.  For instance,
<literal>*&amp;i</literal> is the value at <literal>i</literal>&#8217;s address&#8212;which is just
<literal>i</literal>.  The two expressions are equivalent, provided <literal>&amp;i</literal> is
valid.
</para>
<para>A pointer-dereference expression whose type is data (not a function)
is an lvalue.
</para>
<para>Pointers become really useful when we store them somewhere and use
them later.  Here&#8217;s a simple example to illustrate the practice:
</para>
<screen>{
  int i;
  int *ptr;

  ptr = &amp;i;

  i = 5;

  &#8230;
  
  return *ptr;   /* Returns 5, fetched from <literal>i</literal>.  */
}
</screen>
<para>This shows how to declare the variable <literal>ptr</literal> as type
<literal>int *</literal> (pointer to <literal>int</literal>), store a pointer value into it
(pointing at <literal>i</literal>), and use it later to get the value of the
object it points at (the value in <literal>i</literal>).
</para>
<para>If anyone can provide a useful example which is this basic,
I would be grateful.
</para>
</sect1>
<sect1 label="14.6" id="Null-Pointers">
<title>Null Pointers</title>
<indexterm role="cp"><primary>null pointers</primary></indexterm>
<indexterm role="cp"><primary>pointers, null</primary></indexterm>

<!-- ???stdio loads sttddef -->

<para>A pointer value can be <firstterm>null</firstterm>, which means it does not point to
any object.  The cleanest way to get a null pointer is by writing
<literal>NULL</literal>, a standard macro defined in <filename>stddef.h</filename>.  You can
also do it by casting 0 to the desired pointer type, as in
<literal>(char *) 0</literal>.  (The cast operator performs explicit type conversion;
See <link linkend="Explicit-Type-Conversion">Explicit Type Conversion</link>.)
</para>
<para>You can store a null pointer in any lvalue whose data type
is a pointer type:
</para>
<screen>char *foo;
foo = NULL;
</screen>
<para>These two, if consecutive, can be combined into a declaration with
initializer,
</para>
<screen>char *foo = NULL;
</screen>
<para>You can also explicitly cast <literal>NULL</literal> to the specific pointer type
you want&#8212;it makes no difference.
</para>
<screen>char *foo;
foo = (char *) NULL;
</screen>
<para>To test whether a pointer is null, compare it with zero or
<literal>NULL</literal>, as shown here:
</para>
<screen>if (p != NULL)
  /* <literal>p</literal> is not null.  */
  operate (p);
</screen>
<para>Since testing a pointer for not being null is basic and frequent, all
but beginners in C will understand the conditional without need for
<literal>!= NULL</literal>:
</para>
<screen>if (p)
  /* <literal>p</literal> is not null.  */
  operate (p);
</screen>
</sect1>
<sect1 label="14.7" id="Invalid-Dereference">
<title>Dereferencing Null or Invalid Pointers</title>

<para>Trying to dereference a null pointer is an error.  On most platforms,
it generally causes a signal, usually <literal>SIGSEGV</literal>
(see <link linkend="Signals">Signals</link>).
</para>
<screen>char *foo = NULL;
c = *foo;    /* This causes a signal and terminates.  */
</screen>
<para>Likewise a pointer that has the wrong alignment for the target data type
(on most types of computer), or points to a part of memory that has
not been allocated in the process&#8217;s address space.
</para>
<para>The signal terminates the program, unless the program has arranged to
handle the signal (see section &#8220;The GNU C Library&#8221; in <citetitle>The GNU C Library Reference Manual</citetitle>).
</para>
<para>However, the signal might not happen if the dereference is optimized
away.  In the example above, if you don&#8217;t subsequently use the value
of <literal>c</literal>, GCC might optimize away the code for <literal>*foo</literal>.  You
can prevent such optimization using the <literal>volatile</literal> qualifier, as
shown here:
</para>
<screen>volatile char *p;
volatile char c;
c = *p;
</screen>
<para>You can use this to test whether <literal>p</literal> points to unallocated
memory.  Set up a signal handler first, so the signal won&#8217;t terminate
the program.
</para>
</sect1>
<sect1 label="14.8" id="Void-Pointers">
<title>Void Pointers</title>
<indexterm role="cp"><primary>void pointers</primary></indexterm>
<indexterm role="cp"><primary>pointers, void</primary></indexterm>

<para>The peculiar type <literal>void *</literal>, a pointer whose target type is
<literal>void</literal>, is used often in C.  It represents a pointer to
we-don&#8217;t-say-what.  Thus,
</para>
<screen>void *numbered_slot_pointer (int);
</screen>
<para>declares a function <literal>numbered_slot_pointer</literal> that takes an
integer parameter and returns a pointer, but we don&#8217;t say what type of
data it points to.
</para>
<para>With type <literal>void *</literal>, you can pass the pointer around and test
whether it is null.  However, dereferencing it gives a <literal>void</literal>
value that can&#8217;t be used (see <link linkend="The-Void-Type">The Void Type</link>).  To dereference the
pointer, first convert it to some other pointer type.
</para>
<para>Assignments convert <literal>void *</literal> automatically to any other pointer
type, if the left operand has a pointer type; for instance,
</para>
<screen>{
  int *p;
  /* Converts return value to <literal>int *</literal>.  */
  p = numbered_slot_pointer (5);
  &#8230;
}
</screen>
<para>Passing an argument of type <literal>void *</literal> for a parameter that has a
pointer type also converts.  For example, supposing the function
<literal>hack</literal> is declared to require type <literal>float *</literal> for its
argument, this will convert the null pointer to that type.
</para>
<screen>/* Declare <literal>hack</literal> that way.
   We assume it is defined somewhere else.  */
void hack (float *);
&#8230;
/* Now call <literal>hack</literal>.  */
{
  /* Converts return value of <literal>numbered_slot_pointer</literal>
     to <literal>float *</literal> to pass it to <literal>hack</literal>.  */
  hack (numbered_slot_pointer (5));
  &#8230;
}
</screen>
<para>You can also convert to another pointer type with an explicit cast
(see <link linkend="Explicit-Type-Conversion">Explicit Type Conversion</link>), like this:
</para><screen>(int *) numbered_slot_pointer (5)
</screen>
<para>Here is an example which decides at run time which pointer
type to convert to:
</para>
<screen>void
extract_int_or_double (void *ptr, bool its_an_int)
{
  if (its_an_int)
    handle_an_int (*(int *)ptr);
  else 
    handle_a_double (*(double *)ptr);
}
</screen>
<para>The expression <literal>*(int *)ptr</literal> means to convert <literal>ptr</literal>
to type <literal>int *</literal>, then dereference it.
</para>
</sect1>
<sect1 label="14.9" id="Pointer-Comparison">
<title>Pointer Comparison</title>
<indexterm role="cp"><primary>pointer comparison</primary></indexterm>
<indexterm role="cp"><primary>comparison, pointer</primary></indexterm>

<para>Two pointer values are equal if they point to the same location, or if
they are both null.  You can test for this with <literal>==</literal> and
<literal>!=</literal>.  Here&#8217;s a trivial example:
</para>
<screen>{
  int i;
  int *p, *q;

  p = &amp;i;
  q = &amp;i;
  if (p == q)
    printf (&quot;This will be printed.\n&quot;);
  if (p != q)
    printf (&quot;This won't be printed.\n&quot;);
}
</screen>
<para>Ordering comparisons such as <literal>&gt;</literal> and <literal>&gt;=</literal> operate on
pointers by converting them to unsigned integers.  The C standard says
the two pointers must point within the same object in memory, but on
GNU/Linux systems these operations simply compare the numeric values
of the pointers.
</para>
<para>The pointer values to be compared should in principle have the same type, but
they are allowed to differ in limited cases.  First of all, if the two
pointers&#8217; target types are nearly compatible (see <link linkend="Compatible-Types">Compatible
Types</link>), the comparison is allowed.
</para>
<para>If one of the operands is <literal>void *</literal> (see <link linkend="Void-Pointers">Void Pointers</link>) and
the other is another pointer type, the comparison operator converts
the <literal>void *</literal> pointer to the other type so as to compare them.
(In standard C, this is not allowed if the other type is a function
pointer type, but that works in GNU C.)
</para>
<para>Comparison operators also allow comparing the integer 0 with a pointer
value.  Thus works by converting 0 to a null pointer of the same type
as the other operand.
</para>
</sect1>
<sect1 label="14.10" id="Pointer-Arithmetic">
<title>Pointer Arithmetic</title>
<indexterm role="cp"><primary>pointer arithmetic</primary></indexterm>
<indexterm role="cp"><primary>arithmetic, pointer</primary></indexterm>

<para>Adding an integer (positive or negative) to a pointer is valid in C.
It assumes that the pointer points to an element in an array, and
advances or retracts the pointer across as many array elements as the
integer specifies.  Here is an example, in which adding a positive
integer advances the pointer to a later element in the same array.
</para>
<screen>void
incrementing_pointers ()
{
  int array[5] = { 45, 29, 104, -3, 123456 };
  int elt0, elt1, elt4;

  int *p = &amp;array[0];
  /* Now <literal>p</literal> points at element 0.  Fetch it.  */
  elt0 = *p;

  ++p;
  /* Now <literal>p</literal> points at element 1.  Fetch it.  */
  elt1 = *p;

  p += 3;
  /* Now <literal>p</literal> points at element 4 (the last).  Fetch it.  */
  elt4 = *p;

  printf (&quot;elt0 %d  elt1 %d  elt4 %d.\n&quot;,
          elt0, elt1, elt4);
  /* Prints elt0 45  elt1 29  elt4 123456.  */
}
</screen>
<para>Here&#8217;s an example where adding a negative integer retracts the pointer
to an earlier element in the same array.
</para>
<screen>void
decrementing_pointers ()
{
  int array[5] = { 45, 29, 104, -3, 123456 };
  int elt0, elt3, elt4;

  int *p = &amp;array[4];
  /* Now <literal>p</literal> points at element 4 (the last).  Fetch it.  */
  elt4 = *p;

  --p;
  /* Now <literal>p</literal> points at element 3.  Fetch it.  */
  elt3 = *p;

  p -= 3;
  /* Now <literal>p</literal> points at element 0.  Fetch it.  */
  elt0 = *p;

  printf (&quot;elt0 %d  elt3 %d  elt4 %d.\n&quot;,
          elt0, elt3, elt4);
  /* Prints elt0 45  elt3 -3  elt4 123456.  */
}
</screen>
<para>If one pointer value was made by adding an integer to another
pointer value, it should be possible to subtract the pointer values
and recover that integer.  That works too in C.
</para>
<screen>void
subtract_pointers ()
{
  int array[5] = { 45, 29, 104, -3, 123456 };
  int *p0, *p3, *p4;

  int *p = &amp;array[4];
  /* Now <literal>p</literal> points at element 4 (the last).  Save the value.  */
  p4 = p;

  --p;
  /* Now <literal>p</literal> points at element 3.  Save the value.  */
  p3 = p;

  p -= 3;
  /* Now <literal>p</literal> points at element 0.  Save the value.  */
  p0 = p;

  printf (&quot;%d, %d, %d, %d\n&quot;,
          p4 - p0, p0 - p0, p3 - p0, p0 - p3);
  /* Prints 4, 0, 3, -3.  */
}
</screen>
<para>The addition operation does not know where arrays are.  All it does is
add the integer (multiplied by object size) to the value of the
pointer.  When the initial pointer and the result point into a single
array, the result is well-defined.
</para>
<para><emphasis role="bold">Warning:</emphasis> Only experts should do pointer arithmetic involving pointers
into different memory objects.
</para>
<para>The difference between two pointers has type <literal>int</literal>, or
<literal>long</literal> if necessary (see <link linkend="Integer-Types">Integer Types</link>).  The clean way to
declare it is to use the typedef name <literal>ptrdiff_t</literal> defined in the
file <filename>stddef.h</filename>.
</para>
<para>This definition of pointer subtraction is consistent with
pointer-integer addition, in that <literal>(p3 - p1) + p1</literal> equals
<literal>p3</literal>, as in ordinary algebra.
</para>
<para>In standard C, addition and subtraction are not allowed on <literal>void
*</literal>, since the target type&#8217;s size is not defined in that case.
Likewise, they are not allowed on pointers to function types.
However, these operations work in GNU C, and the &#8220;size of the target
type&#8221; is taken as 1.
</para>
</sect1>
<sect1 label="14.11" id="Pointers-and-Arrays">
<title>Pointers and Arrays</title>
<indexterm role="cp"><primary>pointers and arrays</primary></indexterm>
<indexterm role="cp"><primary>arrays and pointers</primary></indexterm>

<para>The clean way to refer to an array element is
<literal><replaceable>array</replaceable>[<replaceable>index</replaceable>]</literal>.  Another, complicated way to do the
same job is to get the address of that element as a pointer, then
dereference it: <literal>* (&amp;<replaceable>array</replaceable>[0] + <replaceable>index</replaceable>)</literal> (or
equivalently <literal>* (<replaceable>array</replaceable> + <replaceable>index</replaceable>)</literal>).  This first gets a
pointer to element zero, then increments it with <literal>+</literal> to point to
the desired element, then gets the value from there.
</para>
<para>That pointer-arithmetic construct is the <emphasis>definition</emphasis> of square
brackets in C.  <literal><replaceable>a</replaceable>[<replaceable>b</replaceable>]</literal> means, by definition,
<literal>*(<replaceable>a</replaceable> + <replaceable>b</replaceable>)</literal>.  This definition uses <replaceable>a</replaceable> and <replaceable>b</replaceable>
symmetrically, so one must be a pointer and the other an integer; it
does not matter which comes first.
</para>
<para>Since indexing with square brackets is defined in terms of addition
and dereference, that too is symmetrical.  Thus, you can write
<literal>3[array]</literal> and it is equivalent to <literal>array[3]</literal>.  However, it
would be foolish to write <literal>3[array]</literal>, since it has no advantage
and could confuse people who read the code.
</para>
<para>It may seem like a discrepancy that the definition <literal>*(<replaceable>a</replaceable> +
<replaceable>b</replaceable>)</literal> requires a pointer, but <literal>array[3]</literal> uses an array value
instead.  Why is this valid?  The name of the array, when used by
itself as an expression (other than in <literal>sizeof</literal>), stands for a
pointer to the arrays&#8217;s zeroth element.  Thus, <literal>array + 3</literal>
converts <literal>array</literal> implicitly to <literal>&amp;array[0]</literal>, and the result
is a pointer to element 3, equivalent to <literal>&amp;array[3]</literal>.
</para>
<para>Since square brackets are defined in terms of such addition,
<literal>array[3]</literal> first converts <literal>array</literal> to a pointer.  That&#8217;s why
it works to use an array directly in that construct.
</para>
</sect1>
<sect1 label="14.12" id="Pointer-Arithmetic-Low-Level">
<title>Pointer Arithmetic at Low Level</title>
<indexterm role="cp"><primary>pointer arithmetic, low level</primary></indexterm>
<indexterm role="cp"><primary>low level pointer arithmetic</primary></indexterm>

<para>The behavior of pointer arithmetic is theoretically defined only when
the pointer values all point within one object allocated in memory.
But the addition and subtraction operators can&#8217;t tell whether the
pointer values are all within one object.  They don&#8217;t know where
objects start and end.  So what do they really do?
</para>
<para>Adding pointer <replaceable>p</replaceable> to integer <replaceable>i</replaceable> treats <replaceable>p</replaceable> as a memory
address, which is in fact an integer&#8212;call it <replaceable>pint</replaceable>.  It treats
<replaceable>i</replaceable> as a number of elements of the type that <replaceable>p</replaceable> points to.
These elements&#8217; sizes add up to <literal><replaceable>i</replaceable> * sizeof (*<replaceable>p</replaceable>)</literal>.
So the sum, as an integer, is <literal><replaceable>pint</replaceable> + <replaceable>i</replaceable> * sizeof
(*<replaceable>p</replaceable>)</literal>.  This value is reinterpreted as a pointer like <replaceable>p</replaceable>.
</para>
<para>If the starting pointer value <replaceable>p</replaceable> and the result do not point at
parts of the same object, the operation is not officially legitimate,
and C code is not &#8220;supposed&#8221; to do it.  But you can do it anyway,
and it gives precisely the results described by the procedure above.
In some special situations it can do something useful, but non-wizards
should avoid it.
</para>
<para>Here&#8217;s a function to offset a pointer value <emphasis>as if</emphasis> it pointed to
an object of any given size, by explicitly performing that calculation:
</para>
<screen>#include &lt;stdint.h&gt;

void *
ptr_add (void *p, int i, int objsize)
{
  intptr_t p_address = (long) p;
  intptr_t totalsize = i * objsize;
  intptr_t new_address = p_address + totalsize;
  return (void *) new_address;
}
</screen>
<para><indexterm role="cp"><primary><literal>intptr_t</literal></primary></indexterm>
This does the same job as <literal><replaceable>p</replaceable> + <replaceable>i</replaceable></literal> with the proper
pointer type for <replaceable>p</replaceable>.  It uses the type <literal>intptr_t</literal>, which is
defined in the header file <filename>stdint.h</filename>.  (In practice, <literal>long
long</literal> would always work, but it is cleaner to use <literal>intptr_t</literal>.)
</para>
</sect1>
<sect1 label="14.13" id="Pointer-Increment_002fDecrement">
<title>Pointer Increment and Decrement</title>
<indexterm role="cp"><primary>pointer increment and decrement</primary></indexterm>
<indexterm role="cp"><primary>incrementing pointers</primary></indexterm>
<indexterm role="cp"><primary>decrementing pointers</primary></indexterm>

<para>The &#8216;<literal>++</literal>&#8217; operator adds 1 to a variable.  We have seen it for
integers (see <link linkend="Increment_002fDecrement">Increment/Decrement</link>), but it works for pointers too.
For instance, suppose we have a series of positive integers,
terminated by a zero, and we want to add them all up.
</para>
<screen>int
sum_array_till_0 (int *p)
{
  int sum = 0;

  for (;;)
    {
      /* Fetch the next integer.  */
      int next = *p++;
      /* Exit the loop if it&#8217;s 0.  */
      if (next == 0)
        break;
      /* Add it into running total.  */
      sum += next;
    }

  return sum;
}
</screen>
<para>The statement &#8216;<literal>break;</literal>&#8217; will be explained further on (see <link linkend="break-Statement">break
Statement</link>).  Used in this way, it immediately exits the surrounding
<literal>for</literal> statement.
</para>
<para><literal>*p++</literal> parses as <literal>*(p++)</literal>, because a postfix operator always
takes precedence over a prefix operator.  Therefore, it dereferences
<literal>p</literal>, and increments <literal>p</literal> afterwards.  Incrementing a variable
means adding 1 to it, as in <literal>p = p + 1</literal>.  Since <literal>p</literal> is a
pointer, adding 1 to it advances it by the width of the datum it
points to&#8212;in this case, one <literal>int</literal>.  Therefore, each iteration
of the loop picks up the next integer from the series and puts it into
<literal>next</literal>.
</para>
<para>This <literal>for</literal>-loop has no initialization expression since <literal>p</literal>
and <literal>sum</literal> are already initialized, it has no end-test since the
&#8216;<literal>break;</literal>&#8217; statement will exit it, and needs no expression to
advance it since that&#8217;s done within the loop by incrementing <literal>p</literal>
and <literal>sum</literal>.  Thus, those three expressions after <literal>for</literal> are
left empty.
</para>
<para>Another way to write this function is by keeping the parameter value unchanged
and using indexing to access the integers in the table.
</para>
<screen>int
sum_array_till_0_indexing (int *p)
{
  int i;
  int sum = 0;

  for (i = 0; ; i++)
    {
      /* Fetch the next integer.  */
      int next = p[i];
      /* Exit the loop if it&#8217;s 0.  */
      if (next == 0)
        break;
      /* Add it into running total.  */
      sum += next;
    }

  return sum;
}
</screen>
<para>In this program, instead of advancing <literal>p</literal>, we advance <literal>i</literal>
and add it to <literal>p</literal>.  (Recall that <literal>p[i]</literal> means <literal>*(p +
i)</literal>.)  Either way, it uses the same address to get the next integer.
</para>
<para>It makes no difference in this program whether we write <literal>i++</literal> or
<literal>++i</literal>, because the value is not used.  All that matters is the
effect, to increment <literal>i</literal>.
</para>
<para>The &#8216;<literal>--</literal>&#8217; operator also works on pointers; it can be used
to scan backwards through an array, like this:
</para>
<screen>int
after_last_nonzero (int *p, int len)
{
  /* Set up <literal>q</literal> to point just after the last array element.  */
  int *q = p + len;

  while (q != p)
    /* Step <literal>q</literal> back until it reaches a nonzero element.  */
    if (*--q != 0)
      /* Return the index of the element after that nonzero.  */
      return q - p + 1;

  return 0;
}
</screen>
<para>That function returns the length of the nonzero part of the
array specified by its arguments; that is, the index of the
first zero of the run of zeros at the end.
</para>
</sect1>
<sect1 label="14.14" id="Pointer-Arithmetic-Drawbacks">
<title>Drawbacks of Pointer Arithmetic</title>
<indexterm role="cp"><primary>drawbacks of pointer arithmetic</primary></indexterm>
<indexterm role="cp"><primary>pointer arithmetic, drawbacks</primary></indexterm>

<para>Pointer arithmetic is clean and elegant, but it is also the cause of a
major security flaw in the C language.  Theoretically, it is only
valid to adjust a pointer within one object allocated as a unit in
memory.  However, if you unintentionally adjust a pointer across the
bounds of the object and into some other object, the system has no way
to detect this error.
</para>
<para>A bug which does that can easily result in clobbering part of another
object.  For example, with <literal>array[-1]</literal> you can read or write the
nonexistent element before the beginning of an array&#8212;probably part
of some other data.
</para>
<para>Combining pointer arithmetic with casts between pointer types, you can
create a pointer that fails to be properly aligned for its type.  For
example,
</para>
<screen>int a[2];
char *pa = (char *)a;
int *p = (int *)(pa + 1);
</screen>
<para>gives <literal>p</literal> a value pointing to an &#8220;integer&#8221; that includes part
of <literal>a[0]</literal> and part of <literal>a[1]</literal>.  Dereferencing that with
<literal>*p</literal> can cause a fatal <literal>SIGSEGV</literal> signal or it can return the
contents of that badly aligned <literal>int</literal> (see <link linkend="Signals">Signals</link>.  If it
&#8220;works,&#8221; it may be quite slow.  It can also cause aliasing
confusions (see <link linkend="Aliasing">Aliasing</link>).
</para>
<para><emphasis role="bold">Warning:</emphasis> Using improperly aligned pointers is risky&#8212;don&#8217;t do it
unless it is really necessary.
</para>
</sect1>
<sect1 label="14.15" id="Pointer_002dInteger-Conversion">
<title>Pointer-Integer Conversion</title>
<indexterm role="cp"><primary>pointer-integer conversion</primary></indexterm>
<indexterm role="cp"><primary>conversion between pointers and integers</primary></indexterm>
<indexterm role="cp"><primary><literal>uintptr_t</literal></primary></indexterm>

<para>On modern computers, an address is simply a number.  It occupies the
same space as some size of integer.  In C, you can convert a pointer
to the appropriate integer types and vice versa, without losing
information.  The appropriate integer types are <literal>uintptr_t</literal> (an
unsigned type) and <literal>intptr_t</literal> (a signed type).  Both are defined
in <filename>stdint.h</filename>.
</para>
<para>For instance,
</para>
<screen>#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;

void
print_pointer (void *ptr)
{
  uintptr_t converted = (uintptr_t) ptr;

  printf (&quot;Pointer value is 0x%x\n&quot;,
          (unsigned int) converted);
}
</screen>
<para>The specification &#8216;<literal>%x</literal>&#8217; in the template (the first argument) for
<literal>printf</literal> means to represent this argument using hexadecimal
notation.  It&#8217;s cleaner to use <literal>uintptr_t</literal>, since hexadecimal
printing treats the number as unsigned, but it won&#8217;t actually matter:
all <literal>printf</literal> gets to see is the series of bits in the number.
</para>
<para><emphasis role="bold">Warning:</emphasis> Converting pointers to integers is risky&#8212;don&#8217;t do
it unless it is really necessary.
</para>
</sect1>
<sect1 label="14.16" id="Printing-Pointers">
<title>Printing Pointers</title>

<para>To print the numeric value of a pointer, use the &#8216;<literal>%p</literal>&#8217; specifier.
For example:
</para>
<screen>void
print_pointer (void *ptr)
{
  printf (&quot;Pointer value is %p\n&quot;, ptr);
}
</screen>
<para>The specification &#8216;<literal>%p</literal>&#8217; works with any pointer type.  It prints
&#8216;<literal>0x</literal>&#8217; followed by the address in hexadecimal, printed as the
appropriate unsigned integer type.
</para>
</sect1>
</chapter>
<chapter label="15" id="Structures">
<title>Structures</title>
<indexterm role="cp"><primary>structures</primary></indexterm>
<indexterm role="fn"><primary>struct</primary></indexterm>
<indexterm role="cp"><primary>fields in structures</primary></indexterm>

<para>A <firstterm>structure</firstterm> is a user-defined data type that holds various
<firstterm>fields</firstterm> of data.  Each field has a name and a data type specified
in the structure&#8217;s definition.
</para>
<para>Here we define a structure suitable for storing a linked list of
integers.  Each list item will hold one integer, plus a pointer
to the next item.
</para>
<screen>struct intlistlink
  {
    int datum;
    struct intlistlink *next;
  };
</screen>
<para>The structure definition has a <firstterm>type tag</firstterm> so that the code can
refer to this structure.  The type tag here is <literal>intlistlink</literal>.
The definition refers recursively to the same structure through that
tag.
</para>
<para>You can define a structure without a type tag, but then you can&#8217;t
refer to it again.  That is useful only in some special contexts, such
as inside a <literal>typedef</literal> or a <literal>union</literal>.
</para>
<para>The contents of the structure are specified by the <firstterm>field
declarations</firstterm> inside the braces.  Each field in the structure needs a
declaration there.  The fields in one structure definition must have
distinct names, but these names do not conflict with any other names
in the program.
</para>
<para>A field declaration looks just like a variable declaration.  You can
combine field declarations with the same beginning, just as you can
combine variable declarations.
</para>
<para>This structure has two fields.  One, named <literal>datum</literal>, has type
<literal>int</literal> and will hold one integer in the list.  The other, named
<literal>next</literal>, is a pointer to another <literal>struct intlistlink</literal>
which would be the rest of the list.  In the last list item, it would
be <literal>NULL</literal>.
</para>
<para>This structure definition is recursive, since the type of the
<literal>next</literal> field refers to the structure type.  Such recursion is not
a problem; in fact, you can use the type <literal>struct intlistlink *</literal>
before the definition of the type <literal>struct intlistlink</literal> itself.
That works because pointers to all kinds of structures really look the
same at the machine level.
</para>
<para>After defining the structure, you can declare a variable of type
<literal>struct intlistlink</literal> like this:
</para>
<screen>struct intlistlink foo;
</screen>
<para>The structure definition itself can serve as the beginning of a
variable declaration, so you can declare variables immediately after,
like this:
</para>
<screen>struct intlistlink
  {
    int datum;
    struct intlistlink *next;
  } foo;
</screen>
<para>But that is ugly.  It is almost always clearer to separate the
definition of the structure from its uses.
</para>
<para>Declaring a structure type inside a block (see <link linkend="Blocks">Blocks</link>) limits
the scope of the structure type name to that block.  That means the
structure type is recognized only within that block.  Declaring it in
a function parameter list, as here,
</para>
<screen>int f (struct foo {int a, b} parm);
</screen>
<para>(assuming that <literal>struct foo</literal> is not already defined) limits the
scope of the structure type <literal>struct foo</literal> to that parameter list;
that is basically useless, so it triggers a warning.
</para>
<para>Standard C requires at least one field in a structure.
GNU C does not require this.
</para>

<sect1 label="15.1" id="Referencing-Fields">
<title>Referencing Structure Fields</title>
<indexterm role="cp"><primary>referencing structure fields</primary></indexterm>
<indexterm role="cp"><primary>structure fields, referencing</primary></indexterm>

<para>To make a structure useful, there has to be a way to examine and store
its fields.  The &#8216;<literal>.</literal>&#8217; (period) operator does that; its use looks
like <literal><replaceable>object</replaceable>.<replaceable>field</replaceable></literal>.
</para>
<para>Given this structure and variable,
</para>
<screen>struct intlistlink
  {
    int datum;
    struct intlistlink *next;
  };

struct intlistlink foo;
</screen>
<para>you can write <literal>foo.datum</literal> and <literal>foo.next</literal> to refer to the two
fields in the value of <literal>foo</literal>.  These fields are lvalues, so you
can store values into them, and read the values out again.
</para>
<para>Most often, structures are dynamically allocated (see the next
section), and we refer to the objects via pointers.
<literal>(*p).<replaceable>field</replaceable></literal> is somewhat cumbersome, so there is an
abbreviation: <literal>p-&gt;<replaceable>field</replaceable></literal>.  For instance, assume the program
contains this declaration:
</para>
<screen>struct intlistlink *ptr;
</screen>
<para>You can write <literal>ptr-&gt;datum</literal> and <literal>ptr-&gt;next</literal> to refer
to the two fields in the object that <literal>ptr</literal> points to.
</para>
<para>If a unary operator precedes an expression using &#8216;<literal>-&gt;</literal>&#8217;,
the &#8216;<literal>-&gt;</literal>&#8217; nests inside:
</para>
<screen>  -ptr-&gt;datum   is equivalent to   -(ptr-&gt;datum)
</screen>
<para>You can intermix &#8216;<literal>-&gt;</literal>&#8217; and &#8216;<literal>.</literal>&#8217; without parentheses,
as shown here:
</para>
<screen>struct { double d; struct intlistlink l; } foo;

&#8230;foo.l.next-&gt;next-&gt;datum&#8230;
</screen>
</sect1>
<sect1 label="15.2" id="Dynamic-Memory-Allocation">
<title>Dynamic Memory Allocation</title>
<indexterm role="cp"><primary>dynamic memory allocation</primary></indexterm>
<indexterm role="cp"><primary>memory allocation, dynamic</primary></indexterm>
<indexterm role="cp"><primary>allocating memory dynamically</primary></indexterm>

<para>To allocate an object dynamically, call the library function
<literal>malloc</literal> (see section &#8220;The GNU C Library&#8221; in <citetitle>The GNU C Library
Reference Manual</citetitle>).  Here is how to allocate an object of type
<literal>struct intlistlink</literal>.  To make this code work, include the file
<filename>stdlib.h</filename>, like this:
</para>
<screen>#include &lt;stddef.h&gt;  /* Defines <literal>NULL</literal>. */
#include &lt;stdlib.h&gt;  /* Declares <literal>malloc</literal>.  */

&#8230;

struct intlistlink *
alloc_intlistlink ()
{
  struct intlistlink *p;

  p = malloc (sizeof (struct intlistlink));

  if (p == NULL)
    fatal (&quot;Ran out of storage&quot;);

  /* Initialize the contents. */
  p-&gt;datum = 0;
  p-&gt;next = NULL;

  return p;
}
</screen>
<para><literal>malloc</literal> returns <literal>void *</literal>, so the assignment to <literal>p</literal>
will automatically convert it to type <literal>struct intlistlink *</literal>.
The return value of <literal>malloc</literal> is always sufficiently aligned
(see <link linkend="Type-Alignment">Type Alignment</link>) that it is valid for any data type.
</para>
<para>The test for <literal>p == NULL</literal> is necessary because <literal>malloc</literal>
returns a null pointer if it cannot get any storage.  We assume that
the program defines the function <literal>fatal</literal> to report a fatal error
to the user.
</para>
<para>Here&#8217;s how to add one more integer to the front of such a list:
</para>
<screen>struct intlistlink *my_list = NULL;

void
add_to_mylist (int my_int)
{
  struct intlistlink *p = alloc_intlistlink ();

  p-&gt;datum = my_int;
  p-&gt;next = mylist;
  mylist = p;
}
</screen>
<para>The way to free the objects is by calling <literal>free</literal>.  Here&#8217;s
a function to free all the links in one of these lists:
</para>
<screen>void
free_intlist (struct intlistlink *p)
{
  while (p)
    {
      struct intlistlink *q = p;
      p = p-&gt;next;
      free (q);
    }
}
</screen>
<para>We must extract the <literal>next</literal> pointer from the object before freeing
it, because <literal>free</literal> can clobber the data that was in the object.
For the same reason, the program must not use the list any more after
freeing its elements.  To make sure it won&#8217;t, it is best to clear out
the variable where the list was stored, like this:
</para>
<screen>free_intlist (mylist);

mylist = NULL;
</screen>
</sect1>
<sect1 label="15.3" id="Field-Offset">
<title>Field Offset</title>
<indexterm role="cp"><primary>field offset</primary></indexterm>
<indexterm role="cp"><primary>structure field offset</primary></indexterm>
<indexterm role="cp"><primary>offset of structure fields</primary></indexterm>

<para>To determine the offset of a given field <replaceable>field</replaceable> in a structure
type <replaceable>type</replaceable>, use the macro <literal>offsetof</literal>, which is defined in
the file <filename>stddef.h</filename>.  It is used like this:
</para>
<screen>offsetof (<replaceable>type</replaceable>, <replaceable>field</replaceable>)
</screen>
<para>Here is an example:
</para>
<screen>struct foo
{
  int element;
  struct foo *next;
};

offsetof (struct foo, next)
/* On most machines that is 4.  It may be 8.  */
</screen>
</sect1>
<sect1 label="15.4" id="Structure-Layout">
<title>Structure Layout</title>
<indexterm role="cp"><primary>structure layout</primary></indexterm>
<indexterm role="cp"><primary>layout of structures</primary></indexterm>

<para>The rest of this chapter covers advanced topics about structures.  If
you are just learning C, you can skip it.
</para>
<para>The precise layout of a <literal>struct</literal> type is crucial when using it to
overlay hardware registers, to access data structures in shared
memory, or to assemble and disassemble packets for network
communication.  It is also important for avoiding memory waste when
the program makes many objects of that type.  However, the layout
depends on the target platform.  Each platform has conventions for
structure layout, which compilers need to follow.
</para>
<para>Here are the conventions used on most platforms.
</para>
<para>The structure&#8217;s fields appear in the structure layout in the order
they are declared.  When possible, consecutive fields occupy
consecutive bytes within the structure.  However, if a field&#8217;s type
demands more alignment than it would get that way, C gives it the
alignment it requires by leaving a gap after the previous field.
</para>
<para>Once all the fields have been laid out, it is possible to determine
the structure&#8217;s alignment and size.  The structure&#8217;s alignment is the
maximum alignment of any of the fields in it.  Then the structure&#8217;s
size is rounded up to a multiple of its alignment.  That may require
leaving a gap at the end of the structure.
</para>
<para>Here are some examples, where we assume that <literal>char</literal> has size and
alignment 1 (always true), and <literal>int</literal> has size and alignment 4
(true on most kinds of computers):
</para>
<screen>struct foo
{
  char a, b;
  int c;
};
</screen>
<para>This structure occupies 8 bytes, with an alignment of 4.  <literal>a</literal> is
at offset 0, <literal>b</literal> is at offset 1, and <literal>c</literal> is at offset 4.
There is a gap of 2 bytes before <literal>c</literal>.
</para>
<para>Contrast that with this structure:
</para>
<screen>struct foo
{
  char a;
  int c;
  char b;
};
</screen>
<para>This structure has size 12 and alignment 4.  <literal>a</literal> is at offset 0,
<literal>c</literal> is at offset 4, and <literal>b</literal> is at offset 8.  There are two
gaps: three bytes before <literal>c</literal>, and three bytes at the end.
</para>
<para>These two structures have the same contents at the C level, but one
takes 8 bytes and the other takes 12 bytes due to the ordering of the
fields.  A reliable way to avoid this sort of wastage is to order the
fields by size, biggest fields first.
</para>
</sect1>
<sect1 label="15.5" id="Packed-Structures">
<title>Packed Structures</title>
<indexterm role="cp"><primary>packed structures</primary></indexterm>
<indexterm role="cp"><primary><literal>__attribute__((packed))</literal></primary></indexterm>

<para>In GNU C you can force a structure to be laid out with no gaps by
adding <literal>__attribute__((packed))</literal> after <literal>struct</literal> (or at the
end of the structure type declaration).  Here&#8217;s an example:
</para>
<screen>struct __attribute__((packed)) foo
{
  char a;
  int c;
  char b;
};
</screen>
<para>Without <literal>__attribute__((packed))</literal>, this structure occupies 12
bytes (as described in the previous section), assuming 4-byte
alignment for <literal>int</literal>.  With <literal>__attribute__((packed))</literal>, it is
only 6 bytes long&#8212;the sum of the lengths of its fields.
</para>
<para>Use of <literal>__attribute__((packed))</literal> often results in fields that
don&#8217;t have the normal alignment for their types.  Taking the address
of such a field can result in an invalid pointer because of its
improper alignment.  Dereferencing such a pointer can cause a
<literal>SIGSEGV</literal> signal on a machine that doesn&#8217;t, in general, allow
unaligned pointers.
</para>
<para>See <link linkend="Attributes">Attributes</link>.
</para>
</sect1>
<sect1 label="15.6" id="Bit-Fields">
<title>Bit Fields</title>
<indexterm role="cp"><primary>bit fields</primary></indexterm>

<para>A structure field declaration with an integer type can specify the
number of bits the field should occupy.  We call that a <firstterm>bit
field</firstterm>.  These are useful because consecutive bit fields are packed
into a larger storage unit.  For instance,
</para>
<screen>unsigned char opcode: 4;
</screen>
<para>specifies that this field takes just 4 bits.
Since it is unsigned, its possible values range
from 0 to 15.  A signed field with 4 bits, such as this,
</para>
<screen>signed char small: 4;
</screen>
<para>can hold values from -8 to 7.
</para>
<para>You can subdivide a single byte into those two parts by writing
</para>
<screen>unsigned char opcode: 4;
signed char small: 4;
</screen>
<para>in the structure.  With bit fields, these two numbers fit into
a single <literal>char</literal>.
</para>
<para>Here&#8217;s how to declare a one-bit field that can hold either 0 or 1:
</para>
<screen>unsigned char special_flag: 1;
</screen>
<para>You can also use the <literal>bool</literal> type for bit fields:
</para>
<screen>bool special_flag: 1;
</screen>
<para>Except when using <literal>bool</literal> (which is always unsigned,
see <link linkend="Boolean-Type">Boolean Type</link>), always specify <literal>signed</literal> or <literal>unsigned</literal>
for a bit field.  There is a default, if that&#8217;s not specified: the bit
field is signed if plain <literal>char</literal> is signed, except that the option
<option>-funsigned-bitfields</option> forces unsigned as the default.  But it
is cleaner not to depend on this default.
</para>
<para>Bit fields are special in that you cannot take their address with
&#8216;<literal>&amp;</literal>&#8217;.  They are not stored with the size and alignment appropriate
for the specified type, so they cannot be addressed through pointers
to that type.
</para>
</sect1>
<sect1 label="15.7" id="Bit-Field-Packing">
<title>Bit Field Packing</title>

<para>Programs to communicate with low-level hardware interfaces need to
define bit fields laid out to match the hardware data.  This section
explains how to do that.
</para>
<para>Consecutive bit fields are packed together, but each bit field must
fit within a single object of its specified type.  In this example,
</para>
<screen>unsigned short a : 3, b : 3, c : 3, d : 3, e : 3;
</screen>
<para>all five fields fit consecutively into one two-byte <literal>short</literal>.
They need 15 bits, and one <literal>short</literal> provides 16.  By contrast,
</para>
<screen>unsigned char a : 3, b : 3, c : 3, d : 3, e : 3;
</screen>
<para>needs three bytes.  It fits <literal>a</literal> and <literal>b</literal> into one
<literal>char</literal>, but <literal>c</literal> won&#8217;t fit in that <literal>char</literal> (they would
add up to 9 bits).  So <literal>c</literal> and <literal>d</literal> go into a second
<literal>char</literal>, leaving a gap of two bits between <literal>b</literal> and <literal>c</literal>.
Then <literal>e</literal> needs a third <literal>char</literal>.  By contrast,
</para>
<screen>unsigned char a : 3, b : 3;
unsigned int c : 3;
unsigned char d : 3, e : 3;
</screen>
<para>needs only two bytes: the type <literal>unsigned int</literal>
allows <literal>c</literal> to straddle bytes that are in the same word.
</para>
<para>You can leave a gap of a specified number of bits by defining a
nameless bit field.  This looks like <literal><replaceable>type</replaceable> : <replaceable>nbits</replaceable>;</literal>.
It is allocated space in the structure just as a named bit field would
be allocated.
</para>
<para>You can force the following bit field to advance to the following
aligned memory object with <literal><replaceable>type</replaceable> : 0;</literal>.
</para>
<para>Both of these constructs can syntactically share <replaceable>type</replaceable> with
ordinary bit fields.  This example illustrates both:
</para>
<screen>unsigned int a : 5, : 3, b : 5, : 0, c : 5, : 3, d : 5;
</screen>
<para>It puts <literal>a</literal> and <literal>b</literal> into one <literal>int</literal>, with a 3-bit gap
between them.  Then <literal>: 0</literal> advances to the next <literal>int</literal>,
so <literal>c</literal> and <literal>d</literal> fit into that one.
</para>
<para>These rules for packing bit fields apply to most target platforms,
including all the usual real computers.  A few embedded controllers
have special layout rules.
</para>
</sect1>
<sect1 label="15.8" id="const-Fields">
<title><literal>const</literal> Fields</title>
<indexterm role="cp"><primary>const fields</primary></indexterm>
<indexterm role="cp"><primary>structure fields, constant</primary></indexterm>

<!-- ??? Is this a C standard feature? -->

<para>A structure field declared <literal>const</literal> cannot be assigned to
(see <link linkend="const">const</link>).  For instance, let&#8217;s define this modified version of
<literal>struct intlistlink</literal>:
</para>
<screen>struct intlistlink_ro  /* &#8220;ro&#8221; for read-only.  */
  {
    const int datum;
    struct intlistlink *next;
  };
</screen>
<para>This structure can be used to prevent part of the code from modifying
the <literal>datum</literal> field:
</para>
<screen>/* <literal>p</literal> has type <literal>struct intlistlink *</literal>.
   Convert it to <literal>struct intlistlink_ro *</literal>.  */
struct intlistlink_ro *q
  = (struct intlistlink_ro *) p;

q-&gt;datum = 5;     /* Error! */
p-&gt;datum = 5;     /* Valid since <literal>*p</literal> is
                     not a <literal>struct intlistlink_ro</literal>.  */
</screen>
<para>A <literal>const</literal> field can get a value in two ways: by initialization of
the whole structure, and by making a pointer-to-structure point to an object
in which that field already has a value.
</para>
<para>Any <literal>const</literal> field in a structure type makes assignment impossible
for structures of that type (see <link linkend="Structure-Assignment">Structure Assignment</link>).  That is
because structure assignment works by assigning the structure&#8217;s
fields, one by one.
</para>
</sect1>
<sect1 label="15.9" id="Zero-Length">
<title>Arrays of Length Zero</title>
<indexterm role="cp"><primary>array of length zero</primary></indexterm>
<indexterm role="cp"><primary>zero-length arrays</primary></indexterm>
<indexterm role="cp"><primary>length-zero arrays</primary></indexterm>

<para>GNU C allows zero-length arrays.  They are useful as the last element
of a structure that is really a header for a variable-length object.
Here&#8217;s an example, where we construct a variable-size structure
to hold a line which is <literal>this_length</literal> characters long:
</para>
<screen>struct line {
  int length;
  char contents[0];
};

struct line *thisline
  = ((struct line *)
     malloc (sizeof (struct line)
             + this_length));
thisline-&gt;length = this_length;
</screen>
<para>In ISO C90, we would have to give <literal>contents</literal> a length of 1, which
means either wasting space or complicating the argument to <literal>malloc</literal>.
</para>
</sect1>
<sect1 label="15.10" id="Flexible-Array-Fields">
<title>Flexible Array Fields</title>
<indexterm role="cp"><primary>flexible array fields</primary></indexterm>
<indexterm role="cp"><primary>array fields, flexible</primary></indexterm>

<para>The C99 standard adopted a more complex equivalent of zero-length
array fields.  It&#8217;s called a <firstterm>flexible array</firstterm>, and it&#8217;s indicated
by omitting the length, like this:
</para>
<screen>struct line
{
  int length;
  char contents[];
};
</screen>
<para>The flexible array has to be the last field in the structure, and there
must be other fields before it.
</para>
<para>Under the C standard, a structure with a flexible array can&#8217;t be part
of another structure, and can&#8217;t be an element of an array.
</para>
<para>GNU C allows static initialization of flexible array fields.  The effect
is to &#8220;make the array long enough&#8221; for the initializer.
</para>
<screen>struct f1 { int x; int y[]; } f1
  = { 1, { 2, 3, 4 } };
</screen>
<para>This defines a structure variable named <literal>f1</literal>
whose type is <literal>struct f1</literal>.  In C, a variable name or function name
never conflicts with a structure type tag.
</para>
<para>Omitting the flexible array field&#8217;s size lets the initializer
determine it.  This is allowed only when the flexible array is defined
in the outermost structure and you declare a variable of that
structure type.  For example:
</para>
<screen>struct foo { int x; int y[]; };
struct bar { struct foo z; };

struct foo a = { 1, { 2, 3, 4 } };        // Valid.
struct bar b = { { 1, { 2, 3, 4 } } };    // Invalid.
struct bar c = { { 1, { } } };            // Valid.
struct foo d[1] = { { 1 { 2, 3, 4 } } };  // Invalid.
</screen>
</sect1>
<sect1 label="15.11" id="Overlaying-Structures">
<title>Overlaying Different Structures</title>
<indexterm role="cp"><primary>overlaying structures</primary></indexterm>
<indexterm role="cp"><primary>structures, overlaying</primary></indexterm>

<para>Be careful about using different structure types to refer to the same
memory within one function, because GNU C can optimize code assuming
it never does that.  See <link linkend="Aliasing">Aliasing</link>.  Here&#8217;s an example of the kind of
aliasing that can cause the problem:
</para>
<screen>struct a { int size; char *data; };
struct b { int size; char *data; };
struct a foo;
struct b *q = (struct b *) &amp;foo;
</screen>
<para>Here <literal>q</literal> points to the same memory that the variable <literal>foo</literal>
occupies, but they have two different types.  The two types
<literal>struct a</literal> and <literal>struct b</literal> are defined alike, but they are
not the same type.  Interspersing references using the two types,
like this,
</para>
<screen>p-&gt;size = 0;
q-&gt;size = 1;
x = p-&gt;size;
</screen>
<para>allows GNU C to assume that <literal>p-&gt;size</literal> is still zero when it is
copied into <literal>x</literal>.  The compiler &#8220;knows&#8221; that <literal>q</literal> points to
a <literal>struct b</literal> and this cannot overlap with a <literal>struct a</literal>.
</para>
<para>Other compilers might also do this optimization.  The ISO C standard
considers such code erroneous, precisely so that this optimization
will be valid.
</para>
</sect1>
<sect1 label="15.12" id="Structure-Assignment">
<title>Structure Assignment</title>
<indexterm role="cp"><primary>structure assignment</primary></indexterm>
<indexterm role="cp"><primary>assigning structures</primary></indexterm>

<para>Assignment operating on a structure type copies the structure.  The
left and right operands must have the same type.  Here is an example:
</para>
<screen>#include &lt;stddef.h&gt;  /* Defines <literal>NULL</literal>. */
#include &lt;stdlib.h&gt;  /* Declares <literal>malloc</literal>.  */
&#8230;

struct point { double x, y; };

struct point *
copy_point (struct point point)
{
  struct point *p
    = (struct point *) malloc (sizeof (struct point));
  if (p == NULL)
    fatal (&quot;Out of memory&quot;);
  *p = point;
  return p;
}
</screen>
<para>Notionally, assignment on a structure type works by copying each of
the fields.  Thus, if any of the fields has the <literal>const</literal>
qualifier, that structure type does not allow assignment:
</para>
<screen>struct point { const double x, y; };

struct point a, b;

a = b;            /* Error! */
</screen>
<para>See <link linkend="Assignment-Expressions">Assignment Expressions</link>.
</para>
</sect1>
<sect1 label="15.13" id="Unions">
<title>Unions</title>
<indexterm role="cp"><primary>unions</primary></indexterm>
<indexterm role="fn"><primary>union</primary></indexterm>

<para>A <firstterm>union type</firstterm> defines alternative ways of looking at the same
piece of memory.  Each alternative view is defined with a data type,
and identified by a name.  A union definition looks like this:
</para>
<screen>union <replaceable>name</replaceable>
{
  <replaceable>alternative declarations</replaceable>&#8230;
};
</screen>
<para>Each alternative declaration looks like a structure field declaration,
except that it can&#8217;t be a bit field.  For instance,
</para>
<screen>union number
{
  long int integer;
  double float;
}
</screen>
<para>lets you store either an integer (type <literal>long int</literal>) or a floating
point number (type <literal>double</literal>) in the same place in memory.  The
length and alignment of the union type are the maximum of all the
alternatives&#8212;they do not have to be the same.  In this union
example, <literal>double</literal> probably takes more space than <literal>long int</literal>,
but that doesn&#8217;t cause a problem in programs that use the union in the
normal way.
</para>
<para>The members don&#8217;t have to be different in data type.  Sometimes
each member pertains to a way the data will be used.  For instance,
</para>
<screen>union datum
{
  double latitude;
  double longitude;
  double height;
  double weight;
  int continent;
}
</screen>
<para>This union holds one of several kinds of data; most kinds are floating
points, but the value can also be a code for a continent which is an
integer.  You <emphasis>could</emphasis> use one member of type <literal>double</literal> to
access all the values which have that type, but the different member
names will make the program clearer.
</para>
<para>The alignment of a union type is the maximum of the alignments of the
alternatives.  The size of the union type is the maximum of the sizes
of the alternatives, rounded up to a multiple of the alignment
(because every type&#8217;s size must be a multiple of its alignment).
</para>
<para>All the union alternatives start at the address of the union itself.
If an alternative is shorter than the union as a whole, it occupies
the first part of the union&#8217;s storage, leaving the last part unused
<emphasis>for that alternative</emphasis>.
</para>
<para><emphasis role="bold">Warning:</emphasis> if the code stores data using one union alternative
and accesses it with another, the results depend on the kind of
computer in use.  Only wizards should try to do this.  However, when
you need to do this, a union is a clean way to do it.
</para>
<para>Assignment works on any union type by copying the entire value.
</para>
</sect1>
<sect1 label="15.14" id="Packing-With-Unions">
<title>Packing With Unions</title>

<para>Sometimes we design a union with the intention of packing various
kinds of objects into a certain amount of memory space.  For example.
</para>
<screen>union bytes8
{
  long long big_int_elt;
  double double_elt;
  struct { int first, second; } two_ints;
  struct { void *first, *second; } two_ptrs;
};

union bytes8 *p;
</screen>
<para>This union makes it possible to look at 8 bytes of data that <literal>p</literal>
points to as a single 8-byte integer (<literal>p-&gt;big_int_elt</literal>), as a
single floating-point number (<literal>p-&gt;double_elt</literal>), as a pair of
integers (<literal>p-&gt;two_ints.first</literal> and <literal>p-&gt;two_ints.second</literal>), or
as a pair of pointers (<literal>p-&gt;two_ptrs.first</literal> and
<literal>p-&gt;two_ptrs.second</literal>).
</para>
<para>To pack storage with such a union makes assumptions about the sizes of
all the types involved.  This particular union was written expecting a
pointer to have the same size as <literal>int</literal>.  On a machine where one
pointer takes 8 bytes, the code using this union probably won&#8217;t work
as expected.  The union, as such, will function correctly&#8212;if you
store two values through <literal>two_ints</literal> and extract them through
<literal>two_ints</literal>, you will get the same integers back&#8212;but the part of
the program that expects the union to be 8 bytes long could
malfunction, or at least use too much space.
</para>
<para>The above example shows one case where a <literal>struct</literal> type with no
tag can be useful.  Another way to get effectively the same result
is with arrays as members of the union:
</para>
<screen>union eight_bytes
{
  long long big_int_elt;
  double double_elt;
  int two_ints[2];
  void *two_ptrs[2];
};
</screen>
</sect1>
<sect1 label="15.15" id="Cast-to-Union">
<title>Cast to a Union Type</title>
<indexterm role="cp"><primary>cast to a union</primary></indexterm>
<indexterm role="cp"><primary>union, casting to a</primary></indexterm>

<para>In GNU C, you can explicitly cast any of the alternative types to the
union type; for instance,
</para>
<screen>(union eight_bytes) (long long) 5
</screen>
<para>makes a value of type <literal>union eight_bytes</literal> which gets its contents
through the alternative named <literal>big_int_elt</literal>.
</para>
<para>The value being cast must exactly match the type of the alternative,
so this is not valid:
</para>
<screen>(union eight_bytes) 5  /* Error!  5 is <literal>int</literal>. */
</screen>
<para>A cast to union type looks like any other cast, except that the type
specified is a union type.  You can specify the type either with
<literal>union <replaceable>tag</replaceable></literal> or with a typedef name (see <link linkend="Defining-Typedef-Names">Defining
Typedef Names</link>).
</para>
<para>Using the cast as the right-hand side of an assignment to a variable of
union type is equivalent to storing in an alternative of the union:
</para>
<screen>union foo u;

u = (union foo) x   means   u.i = x

u = (union foo) y   means   u.d = y
</screen>
<para>You can also use the union cast as a function argument:
</para>
<screen>void hack (union foo);
&#8230;
hack ((union foo) x);
</screen>
</sect1>
<sect1 label="15.16" id="Structure-Constructors">
<title>Structure Constructors</title>
<indexterm role="cp"><primary>structure constructors</primary></indexterm>
<indexterm role="cp"><primary>constructors, structure</primary></indexterm>

<para>You can construct a structure value by writing its type in
parentheses, followed by an initializer that would be valid in a
declaration for that type.  For instance, given this declaration,
</para>
<screen>struct foo {int a; char b[2];} structure;
</screen>
<para>you can create a <literal>struct foo</literal> value as follows:
</para>
<screen>((struct foo) {x + y, 'a', 0})
</screen>
<para>This specifies <literal>x + y</literal> for field <literal>a</literal>,
the character &#8216;<literal>a</literal>&#8217; for field <literal>b</literal>&#8217;s element 0,
and the null character for field <literal>b</literal>&#8217;s element 1.
</para>
<para>The parentheses around that constructor are to necessary, but we
recommend writing them to make the nesting of the containing
expression clearer.
</para>
<para>You can also show the nesting of the two by writing it like
this:
</para>
<screen>((struct foo) {x + y, {'a', 0} })
</screen>
<para>Each of those is equivalent to writing the following statement
expression (see <link linkend="Statement-Exprs">Statement Exprs</link>):
</para>
<screen>({
  struct foo temp = {x + y, 'a', 0};
  temp;
})
</screen>
<para>You can also create a union value this way, but it is not especially
useful since that is equivalent to doing a cast:
</para>
<screen>  ((union whosis) {<replaceable>value</replaceable>})
is equivalent to
  ((union whosis) (<replaceable>value</replaceable>))
</screen>
</sect1>
<sect1 label="15.17" id="Unnamed-Types-as-Fields">
<title>Unnamed Types as Fields</title>
<indexterm role="cp"><primary>unnamed structures</primary></indexterm>
<indexterm role="cp"><primary>unnamed unions</primary></indexterm>
<indexterm role="cp"><primary>structures, unnamed</primary></indexterm>
<indexterm role="cp"><primary>unions, unnamed</primary></indexterm>

<para>A structure or a union can contain, as fields,
unnamed structures and unions.  Here&#8217;s an example:
</para>
<screen>struct
{
  int a;
  union
  {
    int b;
    float c;
  };
  int d;
} foo;
</screen>
<para>You can access the fields of the unnamed union within <literal>foo</literal> as if they
were individual fields at the same level as the union definition:
</para>
<screen>foo.a = 42;
foo.b = 47;
foo.c = 5.25; // Overwrites the value in <literal>foo.b</literal>.
foo.d = 314;
</screen>
<para>Avoid using field names that could cause ambiguity.  For example, with
this definition:
</para>
<screen>struct
{
  int a;
  struct
  {
    int a;
    float b;
  };
} foo;
</screen>
<para>it is impossible to tell what <literal>foo.a</literal> refers to.  GNU C reports
an error when a definition is ambiguous in this way.
</para>
</sect1>
<sect1 label="15.18" id="Incomplete-Types">
<title>Incomplete Types</title>
<indexterm role="cp"><primary>incomplete types</primary></indexterm>
<indexterm role="cp"><primary>types, incomplete</primary></indexterm>

<para>A type that has not been fully defined is called an <firstterm>incomplete
type</firstterm>.  Structure and union types are incomplete when the code makes a
forward reference, such as <literal>struct foo</literal>, before defining the
type.  An array type is incomplete when its length is unspecified.
</para>
<para>You can&#8217;t use an incomplete type to declare a variable or field, or
use it for a function parameter or return type.  The operators
<literal>sizeof</literal> and <literal>_Alignof</literal> give errors when used on an
incomplete type.
</para>
<para>However, you can define a pointer to an incomplete type, and declare a
variable or field with such a pointer type.  In general, you can do
everything with such pointers except dereference them.  For example:
</para>
<screen>extern void bar (struct mysterious_value *);

void
foo (struct mysterious_value *arg)
{
  bar (arg);
}

&#8230;

{
  struct mysterious_value *p, **q;

  p = *q;
  foo (p);
}
</screen>
<para>These examples are valid because the code doesn&#8217;t try to understand
what <literal>p</literal> points to; it just passes the pointer around.
(Presumably <literal>bar</literal> is defined in some other file that really does
have a definition for <literal>struct mysterious_value</literal>.)  However,
dereferencing the pointer would get an error; that requires a
definition for the structure type.
</para>
</sect1>
<sect1 label="15.19" id="Intertwined-Incomplete-Types">
<title>Intertwined Incomplete Types</title>

<para>When several structure types contain pointers to each other, you can
define the types in any order because pointers to types that come
later are incomplete types.  Thus, 
Here is an example.
</para>
<screen>/* An employee record points to a group.  */
struct employee
{
  char *name;
  &#8230;
  struct group *group;  /* incomplete type.  */
  &#8230;
};

/* An employee list points to employees.  */
struct employee_list
{
  struct employee *this_one;
  struct employee_list *next;  /* incomplete type.  */
  &#8230;
};
  
/* A group points to one employee_list.  */
struct group
{
  char *name;
  &#8230;
  struct employee_list *employees;
  &#8230;
};
</screen>
</sect1>
<sect1 label="15.20" id="Type-Tags">
<title>Type Tags</title>
<indexterm role="cp"><primary>type tags</primary></indexterm>

<para>The name that follows <literal>struct</literal> (see <link linkend="Structures">Structures</link>), <literal>union</literal>
(see <link linkend="Unions">Unions</link>, or <literal>enum</literal> (see <link linkend="Enumeration-Types">Enumeration Types</link>) is called
a <firstterm>type tag</firstterm>.  In C, a type tag never conflicts with a variable
name or function name; the type tags have a separate <firstterm>name space</firstterm>.
Thus, there is no name conflict in this code:
</para>
<screen>struct pair { int a, b; };
int pair = 1;
</screen>
<para>nor in this one:
</para>
<screen>struct pair { int a, b; } pair;
</screen>
<para>where <literal>pair</literal> is both a structure type tag and a variable name.
</para>
<para>However, <literal>struct</literal>, <literal>union</literal>, and <literal>enum</literal> share the same
name space of tags, so this is a conflict:
</para>
<screen>struct pair { int a, b; };
enum pair { c, d };
</screen>
<para>and so is this:
</para>
<screen>struct pair { int a, b; };
struct pair { int c, d; };
</screen>
<para>When the code defines a type tag inside a block, the tag&#8217;s scope is
limited to that block (as for local variables).  Two definitions for
one type tag do not conflict if they are in different scopes; rather,
each is valid in its scope.  For example,
</para>
<screen>struct pair { int a, b; };

void
pair_up_doubles (int len, double array[])
{
  struct pair { double a, b; };
  &#8230;
}
</screen>
<para>has two definitions for <literal>struct pair</literal> which do not conflict.  The
one inside the function applies only within the definition of
<literal>pair_up_doubles</literal>.  Within its scope, that definition
<firstterm>shadows</firstterm> the outer definition.
</para>
<para>If <literal>struct pair</literal> appears inside the function body, before the
inner definition, it refers to the outer definition&#8212;the only one
that has been seen at that point.  Thus, in this code,
</para>
<screen>struct pair { int a, b; };

void
pair_up_doubles (int len, double array[])
{
  struct two_pairs { struct pair *p, *q; };
  struct pair { double a, b; };
  &#8230;
}
</screen>
<para>the structure <literal>two_pairs</literal> has pointers to the outer definition of
<literal>struct pair</literal>, which is probably not desirable.
</para>
<para>To prevent that, you can write <literal>struct pair;</literal> inside the function
body as a variable declaration with no variables.  This is a
<firstterm>forward declaration</firstterm> of the type tag <literal>pair</literal>: it makes the
type tag local to the current block, with the details of the type to
come later.  Here&#8217;s an example:
</para>
<screen>void
pair_up_doubles (int len, double array[])
{
  /* Forward declaration for <literal>pair</literal>.  */
  struct pair;
  struct two_pairs { struct pair *p, *q; };
  /* Give the details.  */
  struct pair { double a, b; };
  &#8230;
}
</screen>
<para>However, the cleanest practice is to avoid shadowing type tags.
</para>
</sect1>
</chapter>
<chapter label="16" id="Arrays">
<title>Arrays</title>
<indexterm role="cp"><primary>array</primary></indexterm>
<indexterm role="cp"><primary>elements of arrays</primary></indexterm>

<para>An <firstterm>array</firstterm> is a data object that holds a series of <firstterm>elements</firstterm>,
all of the same data type.  Each element is identified by its numeric
<replaceable>index</replaceable> within the array.
</para>
<para>We presented arrays of numbers in the sample programs early in this
manual (see <link linkend="Array-Example">Array Example</link>).  However, arrays can have elements of
any data type, including pointers, structures, unions, and other
arrays.
</para>
<para>If you know another programming language, you may suppose that you know all
about arrays, but C arrays have special quirks, so in this chapter we
collect all the information about arrays in C.
</para>
<para>The elements of a C array are allocated consecutively in memory,
with no gaps between them.  Each element is aligned as required
for its data type (see <link linkend="Type-Alignment">Type Alignment</link>).
</para>

<sect1 label="16.1" id="Accessing-Array-Elements">
<title>Accessing Array Elements</title>
<indexterm role="cp"><primary>accessing array elements</primary></indexterm>
<indexterm role="cp"><primary>array elements, accessing</primary></indexterm>

<para>If the variable <literal>a</literal> is an array, the <replaceable>n</replaceable>th element of
<literal>a</literal> is <literal>a[<replaceable>n</replaceable>]</literal>.  You can use that expression to access
an element&#8217;s value or to assign to it:
</para>
<screen>x = a[5];
a[6] = 1;
</screen>
<para>Since the variable <literal>a</literal> is an lvalue, <literal>a[<replaceable>n</replaceable>]</literal> is also an
lvalue.
</para>
<para>The lowest valid index in an array is 0, <emphasis>not</emphasis> 1, and the highest
valid index is one less than the number of elements.
</para>
<para>The C language does not check whether array indices are in bounds, so
if the code uses an out-of-range index, it will access memory outside the
array.
</para>
<para><emphasis role="bold">Warning:</emphasis> Using only valid index values in C is the
programmer&#8217;s responsibility.
</para>
<para>Array indexing in C is not a primitive operation: it is defined in
terms of pointer arithmetic and dereferencing.  Now that we know
<emphasis>what</emphasis> <literal>a[i]</literal> does, we can ask <emphasis>how</emphasis> <literal>a[i]</literal> does
its job.
</para>
<para>In C, <literal><replaceable>x</replaceable>[<replaceable>y</replaceable>]</literal> is an abbreviation for
<literal>*(<replaceable>x</replaceable>+<replaceable>y</replaceable>)</literal>.  Thus, <literal>a[i]</literal> really means
<literal>*(a+i)</literal>.  See <link linkend="Pointers-and-Arrays">Pointers and Arrays</link>.
</para>
<para>When an expression with array type (such as <literal>a</literal>) appears as part
of a larger C expression, it is converted automatically to a pointer
to element zero of that array.  For instance, <literal>a</literal> in an
expression is equivalent to <literal>&amp;a[0]</literal>.  Thus, <literal>*(a+i)</literal> is
computed as <literal>*(&amp;a[0]+i)</literal>.
</para>
<para>Now we can analyze how that expression gives us the desired element of
the array.  It makes a pointer to element 0 of <literal>a</literal>, advances it
by the value of <literal>i</literal>, and dereferences that pointer.
</para>
<para>Another equivalent way to write the expression is <literal>(&amp;a[0])[i]</literal>.
</para>
</sect1>
<sect1 label="16.2" id="Declaring-an-Array">
<title>Declaring an Array</title>
<indexterm role="cp"><primary>declaring an array</primary></indexterm>
<indexterm role="cp"><primary>array, declaring</primary></indexterm>

<para>To make an array declaration, write <literal>[<replaceable>length</replaceable>]</literal> after the
name being declared.  This construct is valid in the declaration of a
variable, a function parameter, a function value type (the value can&#8217;t
be an array, but it can be a pointer to one), a structure field, or a
union alternative.
</para>
<para>The surrounding declaration specifies the element type of the array;
that can be any type of data, but not <literal>void</literal> or a function type.
For instance,
</para>
<screen>double a[5];
</screen>
<para>declares <literal>a</literal> as an array of 5 <literal>double</literal>s.
</para>
<screen>struct foo bstruct[length];
</screen>
<para>declares <literal>bstruct</literal> as an array of <literal>length</literal> objects of type
<literal>struct foo</literal>.  A variable array size like this is allowed when
the array is not file-scope.
</para>
<para>Other declaration constructs can nest within the array declaration
construct.  For instance:
</para>
<screen>struct foo *b[length];
</screen>
<para>declares <literal>b</literal> as an array of <literal>length</literal> pointers to
<literal>struct foo</literal>.  This shows that the length need not be a constant
(see <link linkend="Arrays-of-Variable-Length">Arrays of Variable Length</link>).
</para>
<screen>double (*c)[5];
</screen>
<para>declares <literal>c</literal> as a pointer to an array of 5 <literal>double</literal>s, and
</para>
<screen>char *(*f (int))[5];
</screen>
<para>declares <literal>f</literal> as a function taking an <literal>int</literal> argument and
returning a pointer to an array of 5 strings (pointers to
<literal>char</literal>s).
</para>
<screen>double aa[5][10];
</screen>
<para>declares <literal>aa</literal> as an array of 5 elements, each of which is an
array of 10 <literal>double</literal>s.  This shows how to declare a
multidimensional array in C (see <link linkend="Multidimensional-Arrays">Multidimensional Arrays</link>).
</para>
<para>All these declarations specify the array&#8217;s length, which is needed in
these cases in order to allocate storage for the array.
</para>
</sect1>
<sect1 label="16.3" id="Strings">
<title>Strings</title>
<indexterm role="cp"><primary>string</primary></indexterm>

<para>A string in C is a sequence of elements of type <literal>char</literal>,
terminated with the null character, the character with code zero.
</para>
<para>Programs often need to use strings with specific, fixed contents.  To
write one in a C program, use a <firstterm>string constant</firstterm> such as
<literal>&quot;Take me to your leader!&quot;</literal>.  The data type of a string constant
is <literal>char *</literal>.  For the full syntactic details of writing string
constants, <link linkend="String-Constants">String Constants</link>.
</para>
<para>To declare a place to store a non-constant string, declare an array of
<literal>char</literal>.  Keep in mind that it must include one extra <literal>char</literal>
for the terminating null.  For instance,
</para>
<screen>char text = { 'H', 'e', 'l', 'l', 'o', 0 };
</screen>
<para>declares an array named &#8216;<literal>text</literal>&#8217; with six elements&#8212;five letters
and the terminating null character.  An equivalent way to get the same
result is this,
</para>
<screen>char text = &quot;Hello&quot;;
</screen>
<para>which copies the elements of the string constant, including <emphasis>its</emphasis>
terminating null character.
</para>
<screen>char message[200];
</screen>
<para>declares an array long enough to hold a string of 199 ASCII characters
plus the terminating null character.
</para>
<para>When you store a string into <literal>message</literal> be sure to check or prove
that the length does not exceed its size.  For example,
</para>
<screen>void
set_message (char *text)
{
  int i;
  for (i = 0; i &lt; sizeof (message); i++)
    {
      message[i] = text[i];
      if (text[i] == 0)
        return;
    }
  fatal_error (&quot;Message is too long for `message');
}
</screen>
<para>It&#8217;s easy to do this with the standard library function
<literal>strncpy</literal>, which fills out the whole destination array (up to a
specified length) with null characters.  Thus, if the last character
of the destination is not null, the string did not fit.  Many system
libraries, including the GNU C library, hand-optimize <literal>strncpy</literal>
to run faster than an explicit <literal>for</literal>-loop.
</para>
<para>Here&#8217;s what the code looks like:
</para>
<screen>void
set_message (char *text)
{
  strncpy (message, text, sizeof (message));
  if (message[sizeof (message) - 1] != 0)
    fatal_error (&quot;Message is too long for `message');
}
</screen>
<para>See section &#8220;The GNU C Library&#8221; in <citetitle>The GNU C
Library Reference Manual</citetitle>, for more information about the standard
library functions for operating on strings.
</para>
<para>You can avoid putting a fixed length limit on strings you construct or
operate on by allocating the space for them dynamically.
See <link linkend="Dynamic-Memory-Allocation">Dynamic Memory Allocation</link>.
</para>
</sect1>
<sect1 label="16.4" id="Array-Type-Designators">
<title>Array Type Designators</title>

<para>Every C type has a type designator, which you make by deleting the
variable name and the semicolon from a declaration (see <link linkend="Type-Designators">Type
Designators</link>).  The designators for array types follow this rule, but
they may appear surprising.
</para>
<screen>type   int a[5];           designator   int [5]
type   double a[5][3];     designator   double [5][3]
type   struct foo *a[5];   designator   struct foo *[5]
</screen>
</sect1>
<sect1 label="16.5" id="Incomplete-Array-Types">
<title>Incomplete Array Types</title>
<indexterm role="cp"><primary>incomplete array types</primary></indexterm>
<indexterm role="cp"><primary>array types, incomplete</primary></indexterm>

<para>An array is equivalent, for most purposes, to a pointer to its zeroth
element.  When that is true, the length of the array is irrelevant.
The length needs to be known only for allocating space for the array, or
for <literal>sizeof</literal> and <literal>typeof</literal> (see <link linkend="Auto-Type">Auto Type</link>).  Thus, in some
contexts C allows
</para>
<itemizedlist><listitem><para>An <literal>extern</literal> declaration says how to refer to a variable allocated
elsewhere.  It does not need to allocate space for the variable,
so if it is an array, you can omit the length.  For example,
</para>
<screen>extern int foo[];
</screen>
</listitem><listitem><para>When declaring a function parameter as an array, the argument value
passed to the function is really a pointer to the array&#8217;s zeroth
element.  This value does not say how long the array really is, there
is no need to declare it.  For example,
</para>
<screen>int
func (int foo[])
</screen></listitem></itemizedlist>
<para>These declarations are examples of <firstterm>incomplete</firstterm> array types, types
that are not fully specified.  The incompleteness makes no difference
for accessing elements of the array, but it matters for some other
things.  For instance, <literal>sizeof</literal> is not allowed on an incomplete
type.
</para>
<para>With multidimensional arrays, only the first dimension can be omitted:
</para>
<screen>extern struct chesspiece *funnyboard foo[][8];
</screen>
<para>In other words, the code doesn&#8217;t have to say how many rows there are,
but it must state how big each row is.
</para>
</sect1>
<sect1 label="16.6" id="Limitations-of-C-Arrays">
<title>Limitations of C Arrays</title>
<indexterm role="cp"><primary>limitations of C arrays</primary></indexterm>
<indexterm role="cp"><primary>first-class object</primary></indexterm>

<para>Arrays have quirks in C because they are not &#8220;first-class objects&#8221;:
there is no way in C to operate on an array as a unit.
</para>
<para>The other composite objects in C, structures and unions, are
first-class objects: a C program can copy a structure or union value
in an assignment, or pass one as an argument to a function, or make a
function return one.  You can&#8217;t do those things with an array in C.
That is because a value you can operate on never has an array type.
</para>
<para>An expression in C can have an array type, but that doesn&#8217;t produce
the array as a value.  Instead it is converted automatically to a
pointer to the array&#8217;s element at index zero.  The code can operate
on the pointer, and through that on individual elements of the array,
but it can&#8217;t get and operate on the array as a unit.
</para>
<para>There are three exceptions to this conversion rule, but none of them 
offers a way to operate on the array as a whole.
</para>
<para>First, &#8216;<literal>&amp;</literal>&#8217; applied to an expression with array type gives you the
address of the array, as an array type.  However, you can&#8217;t operate on the
whole array that way&#8212;if you apply &#8216;<literal>*</literal>&#8217; to get the array back,
that expression converts, as usual, to a pointer to its zeroth
element.
</para>
<para>Second, the operators <literal>sizeof</literal>, <literal>_Alignof</literal>, and
<literal>typeof</literal> do not convert the array to a pointer; they leave it as
an array.  But they don&#8217;t operate on the array&#8217;s data&#8212;they only give
information about its type.
</para>
<para>Third, a string constant used as an initializer for an array is not
converted to a pointer&#8212;rather, the declaration copies the
<emphasis>contents</emphasis> of that string in that one special case.
</para>
<para>You <emphasis>can</emphasis> copy the contents of an array, just not with an
assignment operator.  You can do it by calling the library function
<literal>memcpy</literal> or <literal>memmove</literal> (see section &#8220;The
GNU C Library&#8221; in <citetitle>The GNU C Library Reference Manual</citetitle>).  Also,
when a structure contains just an array, you can copy that structure.
</para>
<para>An array itself is an lvalue if it is a declared variable, or part of
a structure or union that is an lvalue.  When you construct an array
from elements (see <link linkend="Constructing-Array-Values">Constructing Array Values</link>), that array is not
an lvalue.
</para>
</sect1>
<sect1 label="16.7" id="Multidimensional-Arrays">
<title>Multidimensional Arrays</title>
<indexterm role="cp"><primary>multidimensional arrays</primary></indexterm>
<indexterm role="cp"><primary>array, multidimensional</primary></indexterm>

<para>Strictly speaking, all arrays in C are unidimensional.  However, you
can create an array of arrays, which is more or less equivalent to a
multidimensional array.  For example,
</para>
<screen>struct chesspiece *board[8][8];
</screen>
<para>declares an array of 8 arrays of 8 pointers to <literal>struct
chesspiece</literal>.  This data type could represent the state of a chess
game.  To access one square&#8217;s contents requires two array index
operations, one for each dimension.  For instance, you can write
<literal>board[row][column]</literal>, assuming <literal>row</literal> and <literal>column</literal>
are variables with integer values in the proper range.
</para>
<para>How does C understand <literal>board[row][column]</literal>?  First of all,
<literal>board</literal> is converted automatically to a pointer to the zeroth
element (at index zero) of <literal>board</literal>.  Adding <literal>row</literal> to that
makes it point to the desired element.  Thus, <literal>board[row]</literal>&#8217;s
value is an element of <literal>board</literal>&#8212;an array of 8 pointers.
</para>
<para>However, as an expression with array type, it is converted
automatically to a pointer to the array&#8217;s zeroth element.  The second
array index operation, <literal>[column]</literal>, accesses the chosen element
from that array.
</para>
<para>As this shows, pointer-to-array types are meaningful in C.
You can declare a variable that points to a row in a chess board
like this:
</para>
<screen>struct chesspiece *(*rowptr)[8];
</screen>
<para>This points to an array of 8 pointers to <literal>struct chesspiece</literal>.
You can assign to it as follows:
</para>
<screen>rowptr = &amp;board[5];
</screen>
<para>The dimensions don&#8217;t have to be equal in length.  Here we declare
<literal>statepop</literal> as an array to hold the population of each state in
the United States for each year since 1900:
</para>
<screen>#define NSTATES 50
{
  int nyears = current_year - 1900 + 1;
  int statepop[NSTATES][nyears];
  &#8230;
}
</screen>
<para>The variable <literal>statepop</literal> is an array of <literal>NSTATES</literal> subarrays,
each indexed by the year (counting from 1900).  Thus, to get the
element for a particular state and year, we must subscript it first
by the number that indicates the state, and second by the index for
the year:
</para>
<screen>statepop[state][year - 1900]
</screen>
<indexterm role="cp"><primary>array, layout in memory</primary></indexterm>
<para>The subarrays within the multidimensional array are allocated
consecutively in memory, and within each subarray, its elements are
allocated consecutively in memory.  The most efficient way to process
all the elements in the array is to scan the last subscript in the
innermost loop.  This means consecutive accesses go to consecutive
memory locations, which optimizes use of the processor&#8217;s memory cache.
For example:
</para>
<screen>int total = 0;
float average;

for (int state = 0; state &lt; NSTATES, ++state)
  {
    for (int year = 0; year &lt; nyears; ++year)
      {
        total += statepop[state][year];
      }
  }

average = total / nyears;
</screen>
<para>C&#8217;s layout for multidimensional arrays is different from Fortran&#8217;s
layout.  In Fortran, a multidimensional array is not an array of
arrays; rather, multidimensional arrays are a primitive feature, and
it is the first index that varies most rapidly between consecutive
memory locations.  Thus, the memory layout of a 50x114 array in C
matches that of a 114x50 array in Fortran.
</para>
</sect1>
<sect1 label="16.8" id="Constructing-Array-Values">
<title>Constructing Array Values</title>
<indexterm role="cp"><primary>constructing array values</primary></indexterm>
<indexterm role="cp"><primary>array values, constructing</primary></indexterm>

<para>You can construct an array from elements by writing them inside
braces, and preceding all that with the array type&#8217;s designator in
parentheses.  There is no need to specify the array length, since the
number of elements determines that.  The constructor looks like this:
</para>
<screen>(<replaceable>elttype</replaceable>[]) { <replaceable>elements</replaceable> };
</screen>
<para>Here is an example, which constructs an array of string pointers:
</para>
<screen>(char *[]) { &quot;x&quot;, &quot;y&quot;, &quot;z&quot; };
</screen>
<para>That&#8217;s equivalent in effect to declaring an array with the same
initializer, like this:
</para>
<screen>char *array[] = { &quot;x&quot;, &quot;y&quot;, &quot;z&quot; };
</screen>
<para>and then using the array.
</para>
<para>If all the elements are simple constant expressions, or made up of
such, then the compound literal can be coerced to a pointer to its
zeroth element and used to initialize a file-scope variable
(see <link linkend="File_002dScope-Variables">File-Scope Variables</link>), as shown here:
</para>
<screen>char **foo = (char *[]) { &quot;x&quot;, &quot;y&quot;, &quot;z&quot; };
</screen>
<para>The data type of <literal>foo</literal> is <literal>char **</literal>, which is a pointer
type, not an array type.  The declaration is equivalent to defining
and then using an array-type variable:
</para>
<screen>char *nameless_array[] = { &quot;x&quot;, &quot;y&quot;, &quot;z&quot; };
char **foo = &amp;nameless_array[0];
</screen>
</sect1>
<sect1 label="16.9" id="Arrays-of-Variable-Length">
<title>Arrays of Variable Length</title>
<indexterm role="cp"><primary>array of variable length</primary></indexterm>
<indexterm role="cp"><primary>variable-length arrays</primary></indexterm>

<para>In GNU C, you can declare variable-length arrays like any other
arrays, but with a length that is not a constant expression.  The
storage is allocated at the point of declaration and deallocated when
the block scope containing the declaration exits.  For example:
</para>
<screen>#include &lt;stdio.h&gt;  /* Defines <literal>FILE</literal>. */
#include &lt;string.h&gt; /* Declares <literal>str</literal>. */

FILE *
concat_fopen (char *s1, char *s2, char *mode)
{
  char str[strlen (s1) + strlen (s2) + 1];
  strcpy (str, s1);
  strcat (str, s2);
  return fopen (str, mode);
}
</screen>
<para>(This uses some standard library functions; see section &#8220;String and Array
Utilities&#8221; in <citetitle>The GNU C Library Reference Manual</citetitle>.)
</para>
<para>The length of an array is computed once when the storage is allocated
and is remembered for the scope of the array in case it is used in
<literal>sizeof</literal>.
</para>
<para><emphasis role="bold">Warning:</emphasis> don&#8217;t allocate a variable-length array if the size
might be very large (more than 100,000), or in a recursive function,
because that is likely to cause stack overflow.  Allocate the array
dynamically instead (see <link linkend="Dynamic-Memory-Allocation">Dynamic Memory Allocation</link>).
</para>
<para>Jumping or breaking out of the scope of the array name deallocates the
storage.  Jumping into the scope is not allowed; that gives an error
message.
</para>
<para>You can also use variable-length arrays as arguments to functions:
</para>
<screen>struct entry
tester (int len, char data[len][len])
{
  &#8230;
}
</screen>
<para>As usual, a function argument declared with an array type
is really a pointer to an array that already exists.
Calling the function does not allocate the array, so there&#8217;s no
particular danger of stack overflow in using this construct.
</para>
<para>To pass the array first and the length afterward, use a forward
declaration in the function&#8217;s parameter list (another GNU extension).
For example,
</para>
<screen>struct entry
tester (int len; char data[len][len], int len)
{
  &#8230;
}
</screen>
<para>The <literal>int len</literal> before the semicolon is a <firstterm>parameter forward
declaration</firstterm>, and it serves the purpose of making the name <literal>len</literal>
known when the declaration of <literal>data</literal> is parsed.
</para>
<para>You can write any number of such parameter forward declarations in the
parameter list.  They can be separated by commas or semicolons, but
the last one must end with a semicolon, which is followed by the
&#8220;real&#8221; parameter declarations.  Each forward declaration must match
a &#8220;real&#8221; declaration in parameter name and data type.  ISO C11 does
not support parameter forward declarations.
</para>
</sect1>
</chapter>
<chapter label="17" id="Enumeration-Types">
<title>Enumeration Types</title>
<indexterm role="cp"><primary>enumeration types</primary></indexterm>
<indexterm role="cp"><primary>types, enumeration</primary></indexterm>
<indexterm role="cp"><primary>enumerator</primary></indexterm>

<para>An <firstterm>enumeration type</firstterm> represents a limited set of integer values,
each with a name.  It is effectively equivalent to a primitive integer
type.
</para>
<para>Suppose we have a list of possible emotional states to store in an
integer variable.  We can give names to these alternative values with
an enumeration:
</para>
<screen>enum emotion_state { neutral, happy, sad, worried,
                     calm, nervous };
</screen>
<para>(Never mind that this is a simplistic way to classify emotional states;
it&#8217;s just a code example.)
</para>
<para>The names inside the enumeration are called <firstterm>enumerators</firstterm>.  The
enumeration type defines them as constants, and their values are
consecutive integers; <literal>neutral</literal> is 0, <literal>happy</literal> is 1,
<literal>sad</literal> is 2, and so on.  Alternatively, you can specify values for
the enumerators explicitly like this:
</para>
<screen>enum emotion_state { neutral = 2, happy = 5,
                     sad = 20, worried = 10,
                     calm = -5, nervous = -300 };
</screen>
<para>Each enumerator which does not specify a value gets value zero
(if it is at the beginning) or the next consecutive integer.
</para>
<screen>/* <literal>neutral</literal> is 0 by default,
   and <literal>worried</literal> is 21 by default.  */
enum emotion_state { neutral,
                      happy = 5, sad = 20, worried,
                      calm = -5, nervous = -300 };
</screen>
<para>If an enumerator is obsolete, you can specify that using it should
cause a warning, by including an attribute in the enumerator&#8217;s
declaration.  Here is how <literal>happy</literal> would look with this
attribute:
</para>
<screen>happy __attribute__
      ((deprecated
        (&quot;impossible under plutocratic rule&quot;)))
      = 5,
</screen>
<para>See <link linkend="Attributes">Attributes</link>.
</para>
<para>You can declare variables with the enumeration type:
</para>
<screen>enum emotion_state feelings_now;
</screen>
<para>In the C code itself, this is equivalent to declaring the variable
<literal>int</literal>.  (If all the enumeration values are positive, it is
equivalent to <literal>unsigned int</literal>.)  However, declaring it with the
enumeration type has an advantage in debugging, because GDB knows it
should display the current value of the variable using the
corresponding name.  If the variable&#8217;s type is <literal>int</literal>, GDB can
only show the value as a number.
</para>
<para>The identifier that follows <literal>enum</literal> is called a <firstterm>type tag</firstterm>
since it distinguishes different enumeration types.  Type tags are in
a separate name space and belong to scopes like most other names in C.
See <link linkend="Type-Tags">Type Tags</link>, for explanation.
</para>
<para>You can predeclare an <literal>enum</literal> type tag like a structure or union
type tag, like this:
</para>
<screen>enum foo;
</screen>
<para>The <literal>enum</literal> type is incomplete until you finish defining it.
</para>
<para>You can optionally include a trailing comma at the end of a list of
enumeration values:
</para>
<screen>enum emotion_state { neutral, happy, sad, worried,
                     calm, nervous, };
</screen>
<para>This is useful in some macro definitions, since it enables you to
assemble the list of enumerators without knowing which one is last.
The extra comma does not change the meaning of the enumeration in any
way.
</para>
</chapter>
<chapter label="18" id="Defining-Typedef-Names">
<title>Defining Typedef Names</title>
<indexterm role="cp"><primary>typedef names</primary></indexterm>
<indexterm role="fn"><primary>typedef</primary></indexterm>

<para>You can define a data type keyword as an alias for any type, and then
use the alias syntactically like a built-in type keyword such as
<literal>int</literal>.  You do this using <literal>typedef</literal>, so these aliases are
also called <firstterm>typedef names</firstterm>.
</para>
<para><literal>typedef</literal> is followed by text that looks just like a variable
declaration, but instead of declaring variables it defines data type
keywords.
</para>
<para>Here&#8217;s how to define <literal>fooptr</literal> as a typedef alias for the type
<literal>struct foo *</literal>, then declare <literal>x</literal> and <literal>y</literal> as variables
with that type:
</para>
<screen>typedef struct foo *fooptr;

fooptr x, y;
</screen>
<para>That declaration is equivalent to the following one:
</para>
<screen>struct foo *x, *y;
</screen>
<para>You can define a typedef alias for any type.  For instance, this makes
<literal>frobcount</literal> an alias for type <literal>int</literal>:
</para>
<screen>typedef int frobcount;
</screen>
<para>This doesn&#8217;t define a new type distinct from <literal>int</literal>.  Rather,
<literal>frobcount</literal> is another name for the type <literal>int</literal>.  Once the
variable is declared, it makes no difference which name the
declaration used.
</para>
<para>There is a syntactic difference, however, between <literal>frobcount</literal> and
<literal>int</literal>: A typedef name cannot be used with
<literal>signed</literal>, <literal>unsigned</literal>, <literal>long</literal> or <literal>short</literal>.  It has
to specify the type all by itself.  So you can&#8217;t write this:
</para>
<screen>unsigned frobcount f1;  /* Error! */
</screen>
<para>But you can write this:
</para>
<screen>typedef unsigned int unsigned_frobcount;

unsigned_frobcount f1;
</screen>
<para>In other words, a typedef name is not an alias for <emphasis>a keyword</emphasis>
such as <literal>int</literal>.  It stands for a <emphasis>type</emphasis>, and that could be
the type <literal>int</literal>.
</para>
<para>Typedef names are in the same namespace as functions and variables, so
you can&#8217;t use the same name for a typedef and a function, or a typedef
and a variable.  When a typedef is declared inside a code block, it is
in scope only in that block.
</para>
<para><emphasis role="bold">Warning:</emphasis> Avoid defining typedef names that end in &#8216;<literal>_t</literal>&#8217;,
because many of these have standard meanings.
</para>
<para>You can redefine a typedef name to the exact same type as its first
definition, but you cannot redefine a typedef name to a
different type, even if the two types are compatible. For example, this
is valid:
</para>
<screen>typedef int frobcount;
typedef int frotzcount;
typedef frotzcount frobcount;
typedef frobcount frotzcount;
</screen>
<para>because each typedef name is always defined with the same type
(<literal>int</literal>), but this is not valid:
</para>
<screen>enum foo {f1, f2, f3};
typedef enum foo frobcount;
typedef int frobcount;
</screen>
<para>Even though the type <literal>enum foo</literal> is compatible with <literal>int</literal>,
they are not the <emphasis>same</emphasis> type.
</para>
</chapter>
<chapter label="19" id="Statements">
<title>Statements</title>
<indexterm role="cp"><primary>statements</primary></indexterm>

<para>A <firstterm>statement</firstterm> specifies computations to be done for effect; it
does not produce a value, as an expression would.  In general a
statement ends with a semicolon (&#8216;<literal>;</literal>&#8217;), but blocks (which are
statements, more or less) are an exception to that rule.
See <link linkend="Blocks">Blocks</link>.
</para>
<para>The places to use statements are inside a block, and inside a
complex statement.  A <firstterm>complex statement</firstterm> contains one or two
components that are nested statements.  Each such component must
consist of one and only one statement.  The way to put multiple
statements in such a component is to group them into a <firstterm>block</firstterm>
(see <link linkend="Blocks">Blocks</link>), which counts as one statement.
</para>
<para>The following sections describe the various kinds of statement.
</para>

<sect1 label="19.1" id="Expression-Statement">
<title>Expression Statement</title>
<indexterm role="cp"><primary>expression statement</primary></indexterm>
<indexterm role="cp"><primary>statement, expression</primary></indexterm>

<para>The most common kind of statement in C is an <firstterm>expression statement</firstterm>.
It consists of an expression followed by a
semicolon.  The expression&#8217;s value is discarded, so the expressions
that are useful are those that have side effects: assignment
expressions, increment and decrement expressions, and function calls.
Here are examples of expression statements:
</para>
<screen>x = 5;              /* Assignment expression. */
p++;                /* Increment expression. */
printf (&quot;Done\n&quot;);  /* Function call expression. */
*p;                 /* Cause <literal>SIGSEGV</literal> signal if <literal>p</literal> is null. */
x + y;              /* Useless statement without effect. */
</screen>
<para>In very unusual circumstances we use an expression statement
whose purpose is to get a fault if an address is invalid:
</para>
<screen>volatile char *p;
&#8230;
*p;                 /* Cause signal if <literal>p</literal> is null. */
</screen>
<para>If the target of <literal>p</literal> is not declared <literal>volatile</literal>, the
compiler might optimize away the memory access, since it knows that
the value isn&#8217;t really used.  See <link linkend="volatile">volatile</link>.
</para>
</sect1>
<sect1 label="19.2" id="if-Statement">
<title><literal>if</literal> Statement</title>
<indexterm role="cp"><primary><literal>if</literal> statement</primary></indexterm>
<indexterm role="cp"><primary>statement, <literal>if</literal></primary></indexterm>
<indexterm role="fn"><primary>if</primary></indexterm>

<para>An <literal>if</literal> statement computes an expression to decide
whether to execute the following statement or not.
It looks like this:
</para>
<screen>if (<replaceable>condition</replaceable>)
  <replaceable>execute-if-true</replaceable>
</screen>
<para>The first thing this does is compute the value of <replaceable>condition</replaceable>.  If
that is true (nonzero), then it executes the statement
<replaceable>execute-if-true</replaceable>.  If the value of <replaceable>condition</replaceable> is false
(zero), it doesn&#8217;t execute <replaceable>execute-if-true</replaceable>; instead, it does
nothing.
</para>
<para>This is a <firstterm>complex statement</firstterm> because it contains a component
<replaceable>if-true-substatement</replaceable> that is a nested statement.  It must be one
and only one statement.  The way to put multiple statements there is
to group them into a <firstterm>block</firstterm> (see <link linkend="Blocks">Blocks</link>).
</para>
</sect1>
<sect1 label="19.3" id="if_002delse-Statement">
<title><literal>if-else</literal> Statement</title>
<indexterm role="cp"><primary><literal>if</literal>&#8230;<literal>else</literal> statement</primary></indexterm>
<indexterm role="cp"><primary>statement, <literal>if</literal>&#8230;<literal>else</literal></primary></indexterm>
<indexterm role="fn"><primary>else</primary></indexterm>

<para>An <literal>if</literal>-<literal>else</literal> statement computes an expression to decide
which of two nested statements to execute.
It looks like this:
</para>
<screen>if (<replaceable>condition</replaceable>)
  <replaceable>if-true-substatement</replaceable>
else
  <replaceable>if-false-substatement</replaceable>
</screen>
<para>The first thing this does is compute the value of <replaceable>condition</replaceable>.  If
that is true (nonzero), then it executes the statement
<replaceable>if-true-substatement</replaceable>.  If the value of <replaceable>condition</replaceable> is false
(zero), then it executes the statement <replaceable>if-false-substatement</replaceable> instead.
</para>
<para>This is a <firstterm>complex statement</firstterm> because it contains components
<replaceable>if-true-substatement</replaceable> and <replaceable>if-else-substatement</replaceable> that are
nested statements.  Each must be one and only one statement.  The way
to put multiple statements in such a component is to group them into a
<firstterm>block</firstterm> (see <link linkend="Blocks">Blocks</link>).
</para>
</sect1>
<sect1 label="19.4" id="Blocks">
<title>Blocks</title>
<indexterm role="cp"><primary>block</primary></indexterm>
<indexterm role="cp"><primary>compound statement</primary></indexterm>

<para>A <firstterm>block</firstterm> is a construct that contains multiple statements of any
kind.  It begins with &#8216;<literal>{</literal>&#8217; and ends with &#8216;<literal>}</literal>&#8217;, and has a
series of statements and declarations in between.  Another name for
blocks is <firstterm>compound statements</firstterm>.
</para>
<para>Is a block a statement?  Yes and no.  It doesn&#8217;t <emphasis>look</emphasis> like a
normal statement&#8212;it does not end with a semicolon.  But you can
<emphasis>use</emphasis> it like a statement; anywhere that a statement is required
or allowed, you can write a block and consider that block a statement.
</para>
<para>So far it seems that a block is a kind of statement with an unusual
syntax.  But that is not entirely true: a function body is also a
block, and that block is definitely not a statement.  The text after a
function header is not treated as a statement; only a function body is
allowed there, and nothing else would be meaningful there.
</para>
<para>In a formal grammar we would have to choose&#8212;either a block is a kind
of statement or it is not.  But this manual is meant for humans, not
for parser generators.  The clearest answer for humans is, &#8220;a block
is a statement, in some ways.&#8221;
</para>
<indexterm role="cp"><primary>nested block</primary></indexterm>
<indexterm role="cp"><primary>internal block</primary></indexterm>
<para>A block that isn&#8217;t a function body is called an <firstterm>internal block</firstterm>
or a <firstterm>nested block</firstterm>.  You can put a nested block directly inside
another block, but more often the nested block is inside some complex
statement, such as a <literal>for</literal> statement or an <literal>if</literal> statement.
</para>
<para>There are two uses for nested blocks in C:
</para>
<itemizedlist><listitem><para>To specify the scope for local declarations.  For instance, a local
variable&#8217;s scope is the rest of the innermost containing block.
</para>
</listitem><listitem><para>To write a series of statements where, syntactically, one statement is
called for.  For instance, the <replaceable>execute-if-true</replaceable> of an <literal>if</literal>
statement is one statement.  To put multiple statements there, they
have to be wrapped in a block, like this:
</para>
<screen>if (x &lt; 0)
  {
    printf (&quot;x was negative\n&quot;);
    x = -x;
  }
</screen></listitem></itemizedlist>
<para>This example (repeated from above) shows a nested block which serves
both purposes: it includes two statements (plus a declaration) in the
body of a <literal>while</literal> statement, and it provides the scope for the
declaration of <literal>q</literal>.
</para>
<screen>void
free_intlist (struct intlistlink *p)
{
  while (p)
    {
      struct intlistlink *q = p;
      p = p-&gt;next;
      free (q);
    }
}
</screen>
</sect1>
<sect1 label="19.5" id="return-Statement">
<title><literal>return</literal> Statement</title>
<indexterm role="cp"><primary><literal>return</literal> statement</primary></indexterm>
<indexterm role="cp"><primary>statement, <literal>return</literal></primary></indexterm>
<indexterm role="fn"><primary>return</primary></indexterm>

<para>The <literal>return</literal> statement makes the containing function return
immediately.  It has two forms.  This one specifies no value to
return:
</para>
<screen>return;
</screen>
<para>That form is meant for functions whose return type is <literal>void</literal>
(see <link linkend="The-Void-Type">The Void Type</link>).  You can also use it in a function that
returns nonvoid data, but that&#8217;s a bad idea, since it makes the
function return garbage.
</para>
<para>The form that specifies a value looks like this:
</para>
<screen>return <replaceable>value</replaceable>;
</screen>
<para>which computes the expression <replaceable>value</replaceable> and makes the function
return that.  If necessary, the value undergoes type conversion to
the function&#8217;s declared return value type, which works like
assigning the value to a variable of that type.
</para>
</sect1>
<sect1 label="19.6" id="Loop-Statements">
<title>Loop Statements</title>
<indexterm role="cp"><primary>loop statements</primary></indexterm>
<indexterm role="cp"><primary>statements, loop</primary></indexterm>
<indexterm role="cp"><primary>iteration</primary></indexterm>

<para>You can use a loop statement when you need to execute a series of
statements repeatedly, making an <firstterm>iteration</firstterm>.  C provides several
different kinds of loop statements, described in the following
subsections.
</para>
<para>Every kind of loop statement is a complex statement because contains a
component, here called <replaceable>body</replaceable>, which is a nested statement.
Most often the body is a block.
</para>

<sect2 label="19.6.1" id="while-Statement">
<title><literal>while</literal> Statement</title>
<indexterm role="cp"><primary><literal>while</literal> statement</primary></indexterm>
<indexterm role="cp"><primary>statement, <literal>while</literal></primary></indexterm>
<indexterm role="fn"><primary>while</primary></indexterm>

<para>The <literal>while</literal> statement is the simplest loop construct.
It looks like this:
</para>
<screen>while (<replaceable>test</replaceable>)
  <replaceable>body</replaceable>
</screen>
<para>Here, <replaceable>body</replaceable> is a statement (often a nested block) to repeat, and
<replaceable>test</replaceable> is the test expression that controls whether to repeat it again.
Each iteration of the loop starts by computing <replaceable>test</replaceable> and, if it
is true (nonzero), that means the loop should execute <replaceable>body</replaceable> again
and then start over.
</para>
<para>Here&#8217;s an example of advancing to the last structure in a chain of
structures chained through the <literal>next</literal> field:
</para>
<screen>#include &lt;stddef.h&gt; /* Defines <literal>NULL</literal>. */
&#8230;
while (chain-&gt;next != NULL)
  chain = chain-&gt;next;
</screen>
<para>This code assumes the chain isn&#8217;t empty to start with; if the chain is
empty (that is, if <literal>chain</literal> is a null pointer), the code gets a
<literal>SIGSEGV</literal> signal trying to dereference that null pointer (see <link linkend="Signals">Signals</link>).
</para>
</sect2>
<sect2 label="19.6.2" id="do_002dwhile-Statement">
<title><literal>do-while</literal> Statement</title>
<indexterm role="cp"><primary><literal>do</literal>&#8211;<literal>while</literal> statement</primary></indexterm>
<indexterm role="cp"><primary>statement, <literal>do</literal>&#8211;<literal>while</literal></primary></indexterm>
<indexterm role="fn"><primary>do</primary></indexterm>

<para>The <literal>do</literal>&#8211;<literal>while</literal> statement is a simple loop construct that
performs the test at the end of the iteration.
</para>
<screen>do
  <replaceable>body</replaceable>
while (<replaceable>test</replaceable>);
</screen>
<para>Here, <replaceable>body</replaceable> is a statement (possibly a block) to repeat, and
<replaceable>test</replaceable> is an expression that controls whether to repeat it again.
</para>
<para>Each iteration of the loop starts by executing <replaceable>body</replaceable>.  Then it
computes <replaceable>test</replaceable> and, if it is true (nonzero), that means to go
back and start over with <replaceable>body</replaceable>.  If <replaceable>test</replaceable> is false (zero),
then the loop stops repeating and execution moves on past it.
</para>
</sect2>
<sect2 label="19.6.3" id="break-Statement">
<title><literal>break</literal> Statement</title>
<indexterm role="cp"><primary><literal>break</literal> statement</primary></indexterm>
<indexterm role="cp"><primary>statement, <literal>break</literal></primary></indexterm>
<indexterm role="fn"><primary>break</primary></indexterm>

<para>The <literal>break</literal> statement looks like &#8216;<literal>break;</literal>&#8217;.  Its effect is to
exit immediately from the innermost loop construct or <literal>switch</literal>
statement (see <link linkend="switch-Statement">switch Statement</link>).
</para>
<para>For example, this loop advances <literal>p</literal> until the next null
character or newline.
</para>
<screen>while (*p)
  {
    /* End loop if we have reached a newline.  */
    if (*p == '\n')
      break;
    p++
  }
</screen>
<para>When there are nested loops, the <literal>break</literal> statement exits from the
innermost loop containing it.
</para>
<screen>struct list_if_tuples
{
  struct list_if_tuples next;
  int length;
  data *contents;
};

void
process_all_elements (struct list_if_tuples *list)
{
  while (list)
    {
      /* Process all the elements in this node&#8217;s vector,
         stopping when we reach one that is null.  */
      for (i = 0; i &lt; list-&gt;length; i++
        {
          /* Null element terminates this node&#8217;s vector.  */
          if (list-&gt;contents[i] == NULL)
            /* Exit the <literal>for</literal> loop.  */
            break;
          /* Operate on the next element.  */
          process_element (list-&gt;contents[i]);
        }

      list = list-&gt;next;
    }
}
</screen>
<para>The only way in C to exit from an outer loop is with
<literal>goto</literal> (see <link linkend="goto-Statement">goto Statement</link>).
</para>
</sect2>
<sect2 label="19.6.4" id="for-Statement">
<title><literal>for</literal> Statement</title>
<indexterm role="cp"><primary><literal>for</literal> statement</primary></indexterm>
<indexterm role="cp"><primary>statement, <literal>for</literal></primary></indexterm>
<indexterm role="fn"><primary>for</primary></indexterm>

<para>A <literal>for</literal> statement uses three expressions written inside a
parenthetical group to define the repetition of the loop.  The first
expression says how to prepare to start the loop.  The second says how
to test, before each iteration, whether to continue looping.  The
third says how to advance, at the end of an iteration, for the next
iteration.  All together, it looks like this:
</para>
<screen>for (<replaceable>start</replaceable>; <replaceable>continue-test</replaceable>; <replaceable>advance</replaceable>)
  <replaceable>body</replaceable>
</screen>
<para>The first thing the <literal>for</literal> statement does is compute <replaceable>start</replaceable>.
The next thing it does is compute the expression <replaceable>continue-test</replaceable>.
If that expression is false (zero), the <literal>for</literal> statement finishes
immediately, so <replaceable>body</replaceable> is executed zero times.
</para>
<para>However, if <replaceable>continue-test</replaceable> is true (nonzero), the <literal>for</literal>
statement executes <replaceable>body</replaceable>, then <replaceable>advance</replaceable>.  Then it loops back
to the not-quite-top to test <replaceable>continue-test</replaceable> again.  But it does
not compute <replaceable>start</replaceable> again.
</para>
</sect2>
<sect2 label="19.6.5" id="Example-of-for">
<title>Example of <literal>for</literal></title>

<para>Here is the <literal>for</literal> statement from the iterative Fibonacci
function:
</para>
<screen>int i;
for (i = 1; i &lt; n; ++i)
  /* If <literal>n</literal> is 1 or less, the loop runs zero times,  */
  /* since <literal>i &lt; n</literal> is false the first time.  */
  {
    /* Now <replaceable>last</replaceable> is <literal>fib (<replaceable>i</replaceable>)</literal>
       and <replaceable>prev</replaceable> is <literal>fib (<replaceable>i</replaceable> &#8722; 1)</literal>.  */
    /* Compute <literal>fib (<replaceable>i</replaceable> + 1)</literal>.  */
    int next = prev + last;
    /* Shift the values down.  */
    prev = last;
    last = next;
    /* Now <replaceable>last</replaceable> is <literal>fib (<replaceable>i</replaceable> + 1)</literal>
       and <replaceable>prev</replaceable> is <literal>fib (<replaceable>i</replaceable>)</literal>.
       But that won&#8217;t stay true for long,
       because we are about to increment <replaceable>i</replaceable>.  */
  }
</screen>
<para>In this example, <replaceable>start</replaceable> is <literal>i = 1</literal>, meaning set <literal>i</literal> to
1.  <replaceable>continue-test</replaceable> is <literal>i &lt; n</literal>, meaning keep repeating the
loop as long as <literal>i</literal> is less than <literal>n</literal>.  <replaceable>advance</replaceable> is
<literal>i++</literal>, meaning increment <literal>i</literal> by 1.  The body is a block
that contains a declaration and two statements.
</para>
</sect2>
<sect2 label="19.6.6" id="Omitted-for_002dExpressions">
<title>Omitted <literal>for</literal>-Expressions</title>

<para>A fully-fleshed <literal>for</literal> statement contains all these parts,
</para>
<screen>for (<replaceable>start</replaceable>; <replaceable>continue-test</replaceable>; <replaceable>advance</replaceable>)
  <replaceable>body</replaceable>
</screen>
<para>but you can omit any of the three expressions inside the parentheses.
The parentheses and the two semicolons are required syntactically, but
the expressions between them may be missing.  A missing expression
means this loop doesn&#8217;t use that particular feature of the <literal>for</literal>
statement.
</para>
<para>Instead of using <replaceable>start</replaceable>, you can do the loop preparation
before the <literal>for</literal> statement: the effect is the same.  So we
could have written the beginning of the previous example this way:
</para>
<screen>int i = 0;
for (; i &lt; n; ++i)
</screen>
<para>instead of this way:
</para>
<screen>int i;
for (i = 0; i &lt; n; ++i)
</screen>
<para>Omitting <replaceable>continue-test</replaceable> means the loop runs forever (or until
something else causes exit from it).  Statements inside the loop can
test conditions for termination and use &#8216;<literal>break;</literal>&#8217; to exit.  This
is more flexible since you can put those tests anywhere in the loop,
not solely at the beginning.
</para>
<para>Putting an expression in <replaceable>advance</replaceable> is almost equivalent to writing
it at the end of the loop body; it does almost the same thing.  The
only difference is for the <literal>continue</literal> statement (see <link linkend="continue-Statement">continue
Statement</link>).  So we could have written this:
</para>
<screen>for (i = 0; i &lt; n;)
  {
    &#8230;
    ++i;
  }
</screen>
<para>instead of this:
</para>
<screen>for (i = 0; i &lt; n; ++i)
  {
    &#8230;
  }
</screen>
<para>The choice is mainly a matter of what is more readable for
programmers.  However, there is also a syntactic difference:
<replaceable>advance</replaceable> is an expression, not a statement.  It can&#8217;t include
loops, blocks, declarations, etc.
</para>
</sect2>
<sect2 label="19.6.7" id="for_002dIndex-Declarations">
<title><literal>for</literal>-Index Declarations</title>

<para>You can declare loop-index variables directly in the <replaceable>start</replaceable>
portion of the <literal>for</literal>-loop, like this:
</para>
<screen>for (int i = 0; i &lt; n; ++i)
  {
    &#8230;
  }
</screen>
<para>This kind of <replaceable>start</replaceable> is limited to a single declaration; it can
declare one or more variables, separated by commas, all of which are
the same <replaceable>basetype</replaceable> (<literal>int</literal>, in this example):
</para>
<screen>for (int i = 0, j = 1, *p = NULL; i &lt; n; ++i, ++j, ++p)
  {
    &#8230;
  }
</screen>
<para>The scope of these variables is the <literal>for</literal> statement as a whole.
See <link linkend="Variable-Declarations">Variable Declarations</link> for a explanation of <replaceable>basetype</replaceable>.
</para>
<para>Variables declared in <literal>for</literal> statements should have initializers.
Omitting the initialization gives the variables unpredictable initial
values, so this code is erroneous.
</para>
<screen>for (int i; i &lt; n; ++i)
  {
    &#8230;
  }
</screen>
</sect2>
<sect2 label="19.6.8" id="continue-Statement">
<title><literal>continue</literal> Statement</title>
<indexterm role="cp"><primary><literal>continue</literal> statement</primary></indexterm>
<indexterm role="cp"><primary>statement, <literal>continue</literal></primary></indexterm>
<indexterm role="fn"><primary>continue</primary></indexterm>

<para>The <literal>continue</literal> statement looks like &#8216;<literal>continue;</literal>&#8217;, and its
effect is to jump immediately to the end of the innermost loop
construct.  If it is a <literal>for</literal>-loop, the next thing that happens
is to execute the loop&#8217;s <replaceable>advance</replaceable> expression.
</para>
<para>For example, this loop increments <literal>p</literal> until the next null character
or newline, and operates (in some way not shown) on all the characters
in the line except for spaces.  All it does with spaces is skip them.
</para>
<screen>for (;*p; ++p)
  {
    /* End loop if we have reached a newline.  */
    if (*p == '\n')
      break;
    /* Pay no attention to spaces.  */
    if (*p == ' ')
      continue;
    /* Operate on the next character.  */
    &#8230;
  }
</screen>
<para>Executing &#8216;<literal>continue;</literal>&#8217; skips the loop body but it does not
skip the <replaceable>advance</replaceable> expression, <literal>p++</literal>.
</para>
<para>We could also write it like this:
</para>
<screen>for (;*p; ++p)
  {
    /* Exit if we have reached a newline.  */
    if (*p == '\n')
      break;
    /* Pay no attention to spaces.  */
    if (*p != ' ')
      {
        /* Operate on the next character.  */
        &#8230;
      }
  }
</screen>
<para>The advantage of using <literal>continue</literal> is that it reduces the
depth of nesting.
</para>
<para>Contrast <literal>continue</literal> with the <literal>break</literal> statement.  See <link linkend="break-Statement">break
Statement</link>.
</para>
</sect2>
</sect1>
<sect1 label="19.7" id="switch-Statement">
<title><literal>switch</literal> Statement</title>
<indexterm role="cp"><primary><literal>switch</literal> statement</primary></indexterm>
<indexterm role="cp"><primary>statement, <literal>switch</literal></primary></indexterm>
<indexterm role="fn"><primary>switch</primary></indexterm>
<indexterm role="fn"><primary>case</primary></indexterm>
<indexterm role="fn"><primary>default</primary></indexterm>

<para>The <literal>switch</literal> statement selects code to run according to the value
of an expression.  The expression, in parentheses, follows the keyword
<literal>switch</literal>.  After that come all the cases to select among,
inside braces.  It looks like this:
</para>
<screen>switch (<replaceable>selector</replaceable>)
  {
    <replaceable>cases</replaceable>&#8230;
  }
</screen>
<para>A case can look like this:
</para>
<screen>case <replaceable>value</replaceable>:
  <replaceable>statements</replaceable>
  break;
</screen>
<para>which means &#8220;come here if <replaceable>selector</replaceable> happens to have the value
<replaceable>value</replaceable>,&#8221; or like this (a GNU C extension):
</para>
<screen>case <replaceable>rangestart</replaceable> ... <replaceable>rangeend</replaceable>:
  <replaceable>statements</replaceable>
  break;
</screen>
<para>which means &#8220;come here if <replaceable>selector</replaceable> happens to have a value
between <replaceable>rangestart</replaceable> and <replaceable>rangeend</replaceable> (inclusive).&#8221;  See <link linkend="Case-Ranges">Case
Ranges</link>.
</para>
<para>The values in <literal>case</literal> labels must reduce to integer constants.
They can use arithmetic, and <literal>enum</literal> constants, but they cannot
refer to data in memory, because they have to be computed at compile
time.  It is an error if two <literal>case</literal> labels specify the same
value, or ranges that overlap, or if one is a range and the other is a
value in that range.
</para>
<para>You can also define a default case to handle &#8220;any other value,&#8221; like
this:
</para>
<screen>default:
  <replaceable>statements</replaceable>
  break;
</screen>
<para>If the <literal>switch</literal> statement has no <literal>default:</literal> label, then it
does nothing when the value matches none of the cases.
</para>
<para>The brace-group inside the <literal>switch</literal> statement is a block, and you
can declare variables with that scope just as in any other block
(see <link linkend="Blocks">Blocks</link>).  However, initializers in these declarations won&#8217;t
necessarily be executed every time the <literal>switch</literal> statement runs,
so it is best to avoid giving them initializers.
</para>
<para><literal>break;</literal> inside a <literal>switch</literal> statement exits immediately from
the <literal>switch</literal> statement.  See <link linkend="break-Statement">break Statement</link>.
</para>
<para>If there is no <literal>break;</literal> at the end of the code for a case,
execution continues into the code for the following case.  This
happens more often by mistake than intentionally, but since this
feature is used in real code, we cannot eliminate it.
</para>
<para><emphasis role="bold">Warning:</emphasis> When one case is intended to fall through to the
next, write a comment like &#8216;<literal>falls through</literal>&#8217; to say it&#8217;s
intentional.  That way, other programmers won&#8217;t assume it was an error
and &#8220;fix&#8221; it erroneously.
</para>
<para>Consecutive <literal>case</literal> statements could, pedantically, be considered
an instance of falling through, but we don&#8217;t consider or treat them that
way because they won&#8217;t confuse anyone.
</para>
</sect1>
<sect1 label="19.8" id="switch-Example">
<title>Example of <literal>switch</literal></title>

<para>Here&#8217;s an example of using the <literal>switch</literal> statement
to distinguish among characters:
</para>
<indexterm role="cp"><primary>counting vowels and punctuation</primary></indexterm>
<screen>struct vp { int vowels, punct; };

struct vp
count_vowels_and_punct (char *string)
{
  int c;
  int vowels = 0;
  int punct = 0;
  /* Don&#8217;t change the parameter itself.  */
  /* That helps in debugging.  */
  char *p = string;
  struct vp value;

  while (c = *p++)
    switch (c)
      {
        case 'y':
        case 'Y':
          /* We assume <literal>y_is_consonant</literal> will check surrounding
                letters to determine whether this y is a vowel.  */
          if (y_is_consonant (p - 1))
            break;

          /* Falls through */

        case 'a':
        case 'e':
        case 'i':
        case 'o':
        case 'u':
        case 'A':
        case 'E':
        case 'I':
        case 'O':
        case 'U':
          vowels++;
          break;

        case '.':
        case ',':
        case ':':
        case ';':
        case '?':
        case '!':
        case '\&quot;':
        case '\'':
          punct++;
          break;
      }

  value.vowels = vowels;
  value.punct = punct;

  return value;
}
</screen>
</sect1>
<sect1 label="19.9" id="Duffs-Device">
<title>Duff&#8217;s Device</title>
<indexterm role="cp"><primary>Duff&#8217;s device</primary></indexterm>

<para>The cases in a <literal>switch</literal> statement can be inside other control
constructs.  For instance, we can use a technique known as <firstterm>Duff&#8217;s
device</firstterm> to optimize this simple function,
</para>
<screen>void
copy (char *to, char *from, int count)
{
  while (count &gt; 0)
    *to++ = *from++, count--;
}
</screen>
<para>which copies memory starting at <replaceable>from</replaceable> to memory starting at
<replaceable>to</replaceable>.
</para>
<para>Duff&#8217;s device involves unrolling the loop so that it copies
several characters each time around, and using a <literal>switch</literal> statement
to enter the loop body at the proper point:
</para>
<screen>void
copy (char *to, char *from, int count)
{
  if (count &lt;= 0)
    return;
  int n = (count + 7) / 8;
  switch (count % 8)
    {
      do {
        case 0: *to++ = *from++;
        case 7: *to++ = *from++;
        case 6: *to++ = *from++;
        case 5: *to++ = *from++;
        case 4: *to++ = *from++;
        case 3: *to++ = *from++;
        case 2: *to++ = *from++;
        case 1: *to++ = *from++;
        } while (--n &gt; 0);
    }
}
</screen>
</sect1>
<sect1 label="19.10" id="Case-Ranges">
<title>Case Ranges</title>
<indexterm role="cp"><primary>case ranges</primary></indexterm>
<indexterm role="cp"><primary>ranges in case statements</primary></indexterm>

<para>You can specify a range of consecutive values in a single <literal>case</literal> label,
like this:
</para>
<screen>case <replaceable>low</replaceable> ... <replaceable>high</replaceable>:
</screen>
<para>This has the same effect as the proper number of individual <literal>case</literal>
labels, one for each integer value from <replaceable>low</replaceable> to <replaceable>high</replaceable>, inclusive.
</para>
<para>This feature is especially useful for ranges of ASCII character codes:
</para>
<screen>case 'A' ... 'Z':
</screen>
<para><emphasis role="bold">Be careful:</emphasis> with integers, write spaces around the <literal>...</literal>
to prevent it from being parsed wrong.  For example, write this:
</para>
<screen>case 1 ... 5:
</screen>
<para>rather than this:
</para>
<screen>case 1...5:
</screen>
</sect1>
<sect1 label="19.11" id="Null-Statement">
<title>Null Statement</title>
<indexterm role="cp"><primary>null statement</primary></indexterm>
<indexterm role="cp"><primary>statement, null</primary></indexterm>

<para>A <firstterm>null statement</firstterm> is just a semicolon.  It does nothing.
</para>
<para>A null statement is a placeholder for use where a statement is
grammatically required, but there is nothing to be done.  For
instance, sometimes all the work of a <literal>for</literal>-loop is done in the
<literal>for</literal>-header itself, leaving no work for the body.  Here is an
example that searches for the first newline in <literal>array</literal>:
</para>
<screen>for (p = array; *p != '\n'; p++)
  ;
</screen>
</sect1>
<sect1 label="19.12" id="goto-Statement">
<title><literal>goto</literal> Statement and Labels</title>
<indexterm role="cp"><primary><literal>goto</literal> statement</primary></indexterm>
<indexterm role="cp"><primary>statement, <literal>goto</literal></primary></indexterm>
<indexterm role="cp"><primary>label</primary></indexterm>
<indexterm role="fn"><primary>goto</primary></indexterm>

<para>The <literal>goto</literal> statement looks like this:
</para>
<screen>goto <replaceable>label</replaceable>;
</screen>
<para>Its effect is to transfer control immediately to another part of the
current function&#8212;where the label named <replaceable>label</replaceable> is defined.
</para>
<para>An ordinary label definition looks like this:
</para>
<screen><replaceable>label</replaceable>:
</screen>
<para>and it can appear before any statement.  You can&#8217;t use <literal>default</literal>
as a label, since that has a special meaning for <literal>switch</literal>
statements.
</para>
<para>An ordinary label doesn&#8217;t need a separate declaration; defining it is
enough.
</para>
<para>Here&#8217;s an example of using <literal>goto</literal> to implement a loop
equivalent to <literal>do</literal>&#8211;<literal>while</literal>:
</para>
<screen>{
 loop_restart:
  <replaceable>body</replaceable>
  if (<replaceable>condition</replaceable>)
    goto loop_restart;
}
</screen>
<para>The name space of labels is separate from that of variables and functions.
Thus, there is no error in using a single name in both ways:
</para>
<screen>{
  int foo;    // Variable <literal>foo</literal>.
 foo:         // Label <literal>foo</literal>.
  <replaceable>body</replaceable>
  if (foo &gt; 0)  // Variable <literal>foo</literal>.
    goto foo;   // Label <literal>foo</literal>.
}
</screen>
<para>Blocks have no effect on ordinary labels; each label name is defined
throughout the whole of the function it appears in.  It looks strange to
jump into a block with <literal>goto</literal>, but it works.  For example,
</para>
<screen>if (x &lt; 0)
  goto negative;
if (y &lt; 0)
  {
   negative:
    printf (&quot;Negative\n&quot;);
    return;
  }
</screen>
<para>If the goto jumps into the scope of a variable, it does not
initialize the variable.  For example, if <literal>x</literal> is negative,
</para>
<screen>if (x &lt; 0)
  goto negative;
if (y &lt; 0)
  {
    int i = 5;
   negative:
    printf (&quot;Negative, and i is %d\n&quot;, i);
    return;
  }
</screen>
<para>prints junk because <literal>i</literal> was not initialized.
</para>
<para>If the block declares a variable-length automatic array, jumping into
it gives a compilation error.  However, jumping out of the scope of a
variable-length array works fine, and deallocates its storage.
</para>
<para>A label can&#8217;t come directly before a declaration, so the code can&#8217;t
jump directly to one.  For example, this is not allowed:
</para>
<screen>{
  goto foo;
foo:
  int x = 5;
  bar(&amp;x);
}
</screen>
<para>The workaround is to add a statement, even an empty statement,
directly after the label.  For example:
</para>
<screen>{
  goto foo;
foo:
  ;
  int x = 5;
  bar(&amp;x);
}
</screen>
<para>Likewise, a label can&#8217;t be the last thing in a block.  The workaround
solution is the same: add a semicolon after the label.
</para>
<para>These unnecessary restrictions on labels make no sense, and ought in
principle to be removed; but they do only a little harm since labels
and <literal>goto</literal> are rarely the best way to write a program.
</para>
<para>These examples are all artificial; it would be more natural to
write them in other ways, without <literal>goto</literal>.  For instance,
the clean way to write the example that prints &#8216;<literal>Negative</literal>&#8217; is this:
</para>
<screen>if (x &lt; 0 || y &lt; 0)
  {
    printf (&quot;Negative\n&quot;);
    return;
  }
</screen>
<para>It is hard to construct simple examples where <literal>goto</literal> is actually
the best way to write a program.  Its rare good uses tend to be in
complex code, thus not apt for the purpose of explaining the meaning
of <literal>goto</literal>.
</para>
<para>The only good time to use <literal>goto</literal> is when it makes the code
simpler than any alternative.  Jumping backward is rarely desirable,
because usually the other looping and control constructs give simpler
code.  Using <literal>goto</literal> to jump forward is more often desirable, for
instance when a function needs to do some processing in an error case
and errors can occur at various different places within the function.
</para>
</sect1>
<sect1 label="19.13" id="Local-Labels">
<title>Locally Declared Labels</title>
<indexterm role="cp"><primary>local labels</primary></indexterm>
<indexterm role="cp"><primary>macros, local labels</primary></indexterm>
<indexterm role="fn"><primary>__label__</primary></indexterm>

<para>In GNU C you can declare <firstterm>local labels</firstterm> in any nested block
scope.  A local label is used in a <literal>goto</literal> statement just like an
ordinary label, but you can only reference it within the block in
which it was declared.
</para>
<para>A local label declaration looks like this:
</para>
<screen>__label__ <replaceable>label</replaceable>;
</screen>
<para>or
</para>
<screen>__label__ <replaceable>label1</replaceable>, <replaceable>label2</replaceable>, &#8230;;
</screen>
<para>Local label declarations must come at the beginning of the block,
before any ordinary declarations or statements.
</para>
<para>The label declaration declares the label <emphasis>name</emphasis>, but does not define
the label itself.  That&#8217;s done in the usual way, with
<literal><replaceable>label</replaceable>:</literal>, before one of the statements in the block.
</para>
<para>The local label feature is useful for complex macros.  If a macro
contains nested loops, a <literal>goto</literal> can be useful for breaking out of
them.  However, an ordinary label whose scope is the whole function
cannot be used: if the macro can be expanded several times in one
function, the label will be multiply defined in that function.  A
local label avoids this problem.  For example:
</para>
<screen>#define SEARCH(value, array, target)              \
do {                                              \
  __label__ found;                                \
  __auto_type _SEARCH_target = (target);          \
  __auto_type _SEARCH_array = (array);            \
  int i, j;                                       \
  int value;                                      \
  for (i = 0; i &lt; max; i++)                       \
    for (j = 0; j &lt; max; j++)                     \
      if (_SEARCH_array[i][j] == _SEARCH_target)  \
        { (value) = i; goto found; }              \
  (value) = -1;                                   \
 found:;                                          \
} while (0)
</screen>
<para>This could also be written using a statement expression
(see <link linkend="Statement-Exprs">Statement Exprs</link>):
</para>
<screen>#define SEARCH(array, target)                     \
({                                                \
  __label__ found;                                \
  __auto_type _SEARCH_target = (target);      \
  __auto_type _SEARCH_array = (array);     \
  int i, j;                                       \
  int value;                                      \
  for (i = 0; i &lt; max; i++)                       \
    for (j = 0; j &lt; max; j++)                     \
      if (_SEARCH_array[i][j] == _SEARCH_target)  \
        { value = i; goto found; }                \
  value = -1;                                     \
 found:                                           \
  value;                                          \
})
</screen>
<para>Ordinary labels are visible throughout the function where they are
defined, and only in that function.  However, explicitly declared
local labels of a block are visible in nested functions declared
within that block.  See <link linkend="Nested-Functions">Nested Functions</link>, for details.
</para>
<para>See <link linkend="goto-Statement">goto Statement</link>.
</para>
</sect1>
<sect1 label="19.14" id="Labels-as-Values">
<title>Labels as Values</title>
<indexterm role="cp"><primary>labels as values</primary></indexterm>
<indexterm role="cp"><primary>computed gotos</primary></indexterm>
<indexterm role="cp"><primary>goto with computed label</primary></indexterm>
<indexterm role="cp"><primary>address of a label</primary></indexterm>

<para>In GNU C, you can get the address of a label defined in the current
function (or a local label defined in the containing function) with
the unary operator &#8216;<literal>&amp;&amp;</literal>&#8217;.  The value has type <literal>void *</literal>.  This
value is a constant and can be used wherever a constant of that type
is valid.  For example:
</para>
<screen>void *ptr;
&#8230;
ptr = &amp;&amp;foo;
</screen>
<para>To use these values requires a way to jump to one.  This is done
with the computed goto statement<footnote><para>The analogous feature in
Fortran is called an assigned goto, but that name seems inappropriate in
C, since you can do more with label addresses than store them in special label
variables.</para></footnote>, <literal>goto *<replaceable>exp</replaceable>;</literal>.  For example,
</para>
<screen>goto *ptr;
</screen>
<para>Any expression of type <literal>void *</literal> is allowed.
</para>
<para>See <link linkend="goto-Statement">goto Statement</link>.
</para>

<sect2 label="19.14.1" id="Label-Value-Uses">
<title>Label Value Uses</title>

<para>One use for label-valued constants is to initialize a static array to
serve as a jump table:
</para>
<screen>static void *array[] = { &amp;&amp;foo, &amp;&amp;bar, &amp;&amp;hack };
</screen>
<para>Then you can select a label with indexing, like this:
</para>
<screen>goto *array[i];
</screen>
<para>Note that this does not check whether the subscript is in bounds&#8212;array
indexing in C never checks that.
</para>
<para>You can make the table entries offsets instead of addresses
by subtracting one label from the others.  Here is an example:
</para>
<screen>static const int array[] = { &amp;&amp;foo - &amp;&amp;foo, &amp;&amp;bar - &amp;&amp;foo,
                             &amp;&amp;hack - &amp;&amp;foo };
goto *(&amp;&amp;foo + array[i]);
</screen>
<para>Using offsets is preferable in shared libraries, as it avoids the need
for dynamic relocation of the array elements; therefore, the array can
be read-only.
</para>
<para>An array of label values or offsets serves a purpose much like that of
the <literal>switch</literal> statement.  The <literal>switch</literal> statement is cleaner,
so use <literal>switch</literal> by preference when feasible.
</para>
<para>Another use of label values is in an interpreter for threaded code.
The labels within the interpreter function can be stored in the
threaded code for super-fast dispatching.
</para>
</sect2>
<sect2 label="19.14.2" id="Label-Value-Caveats">
<title>Label Value Caveats</title>

<para>Jumping to a label defined in another function does not work.
It can cause unpredictable results.
</para>
<para>The best way to avoid this is to store label values only in
automatic variables, or static variables whose names are declared
within the function.  Never pass them as arguments.
</para>
<indexterm role="cp"><primary>cloning</primary></indexterm>
<para>An optimization known as <firstterm>cloning</firstterm> generates multiple simplified
variants of a function&#8217;s code, for use with specific fixed arguments.
Using label values in certain ways, such as saving the address in one
call to the function and using it again in another call, would make cloning
give incorrect results.  These functions must disable cloning.
</para>
<para>Inlining calls to the function would also result in multiple copies of
the code, each with its own value of the same label.  Using the label
in a computed goto is no problem, because the computed goto inhibits
inlining.  However, using the label value in some other way, such as
an indication of where an error occurred, would be optimized wrong.
These functions must disable inlining.
</para>
<para>To prevent inlining or cloning of a function, specify
<literal>__attribute__((__noinline__,__noclone__))</literal> in its definition.
See <link linkend="Attributes">Attributes</link>.
</para>
<para>When a function uses a label value in a static variable initializer,
that automatically prevents inlining or cloning the function.
</para>
</sect2>
</sect1>
<sect1 label="19.15" id="Statement-Exprs">
<title>Statements and Declarations in Expressions</title>
<indexterm role="cp"><primary>statements inside expressions</primary></indexterm>
<indexterm role="cp"><primary>declarations inside expressions</primary></indexterm>
<indexterm role="cp"><primary>expressions containing statements</primary></indexterm>

<!-- the above section title wrapped and causes an underfull hbox.. i -->
<!-- changed it from "within" to "in". -mew 4feb93 -->
<para>A block enclosed in parentheses can be used as an expression in GNU
C.  This provides a way to use local variables, loops and switches within
an expression.  We call it a <firstterm>statement expression</firstterm>.
</para>
<para>Recall that a block is a sequence of statements
surrounded by braces.  In this construct, parentheses go around the
braces.  For example:
</para>
<screen>({ int y = foo (); int z;
   if (y &gt; 0) z = y;
   else z = - y;
   z; })
</screen>
<para>is a valid (though slightly more complex than necessary) expression
for the absolute value of <literal>foo ()</literal>.
</para>
<para>The last statement in the block should be an expression statement; an
expression followed by a semicolon, that is.  The value of this
expression serves as the value of statement expression.  If the last
statement is anything else, the statement expression&#8217;s value is
<literal>void</literal>.
</para>
<para>This feature is mainly useful in making macro definitions compute each
operand exactly once.  See <link linkend="Macros-and-Auto-Type">Macros and Auto Type</link>.
</para>
<para>Statement expressions are not allowed in expressions that must be
constant, such as the value for an enumerator, the width of a
bit-field, or the initial value of a static variable.
</para>
<para>Jumping into a statement expression&#8212;with <literal>goto</literal>, or using a
<literal>switch</literal> statement outside the statement expression&#8212;is an
error.  With a computed <literal>goto</literal> (see <link linkend="Labels-as-Values">Labels as Values</link>), the
compiler can&#8217;t detect the error, but it still won&#8217;t work.
</para>
<para>Jumping out of a statement expression is permitted, but since
subexpressions in C are not computed in a strict order, it is
unpredictable which other subexpressions will have been computed by
then.  For example,
</para>
<screen>  foo (), (({ bar1 (); goto a; 0; }) + bar2 ()), baz();
</screen>
<para>calls <literal>foo</literal> and <literal>bar1</literal> before it jumps, and never
calls <literal>baz</literal>, but may or may not call <literal>bar2</literal>.  If <literal>bar2</literal>
does get called, that occurs after <literal>foo</literal> and before <literal>bar1</literal>.
</para>
</sect1>
</chapter>
<chapter label="20" id="Variables">
<title>Variables</title>
<indexterm role="cp"><primary>variables</primary></indexterm>

<para>Every variable used in a C program needs to be made known by a
<firstterm>declaration</firstterm>.  It can be used only after it has been declared.
It is an error to declare a variable name more than once in the same
scope; an exception is that <literal>extern</literal> declarations and tentative
definitions can coexist with another declaration of the same
variable.
</para>
<para>Variables can be declared anywhere within a block or file. (Older
versions of C required that all variable declarations within a block
occur before any statements.)
</para>
<para>Variables declared within a function or block are <firstterm>local</firstterm> to
it.  This means that the variable name is visible only until the end
of that function or block, and the memory space is allocated only
while control is within it.
</para>
<para>Variables declared at the top level in a file are called <firstterm>file-scope</firstterm>.
They are assigned fixed, distinct memory locations, so they retain
their values for the whole execution of the program.
</para>

<sect1 label="20.1" id="Variable-Declarations">
<title>Variable Declarations</title>
<indexterm role="cp"><primary>variable declarations</primary></indexterm>
<indexterm role="cp"><primary>declaration of variables</primary></indexterm>

<para>Here&#8217;s what a variable declaration looks like:
</para>
<screen><replaceable>keywords</replaceable> <replaceable>basetype</replaceable> <replaceable>decorated-variable</replaceable> [= <replaceable>init</replaceable>];
</screen>
<para>The <replaceable>keywords</replaceable> specify how to handle the scope of the variable
name and the allocation of its storage.  Most declarations have
no keywords because the defaults are right for them.
</para>
<para>C allows these keywords to come before or after <replaceable>basetype</replaceable>, or
even in the middle of it as in <literal>unsigned static int</literal>, but don&#8217;t
do that&#8212;it would surprise other programmers.  Always write the
keywords first.
</para>
<para>The <replaceable>basetype</replaceable> can be any of the predefined types of C, or a type
keyword defined with <literal>typedef</literal>.  It can also be <literal>struct
<replaceable>tag</replaceable></literal>, <literal>union <replaceable>tag</replaceable></literal>, or <literal>enum <replaceable>tag</replaceable></literal>.  In
addition, it can include type qualifiers such as <literal>const</literal> and
<literal>volatile</literal> (see <link linkend="Type-Qualifiers">Type Qualifiers</link>).
</para>
<para>In the simplest case, <replaceable>decorated-variable</replaceable> is just the variable
name.  That declares the variable with the type specified by
<replaceable>basetype</replaceable>.  For instance,
</para>
<screen>int foo;
</screen>
<para>uses <literal>int</literal> as the <replaceable>basetype</replaceable> and <literal>foo</literal> as the
<replaceable>decorated-variable</replaceable>.  It declares <literal>foo</literal> with type
<literal>int</literal>.
</para>
<screen>struct tree_node foo;
</screen>
<para>declares <literal>foo</literal> with type <literal>struct tree_node</literal>.
</para>

<sect2 label="20.1.1" id="Declaring-Arrays-and-Pointers">
<title>Declaring Arrays and Pointers</title>
<indexterm role="cp"><primary>declaring arrays and pointers</primary></indexterm>
<indexterm role="cp"><primary>array, declaring</primary></indexterm>
<indexterm role="cp"><primary>pointers, declaring</primary></indexterm>

<para>To declare a variable that is an array, write
<literal><replaceable>variable</replaceable>[<replaceable>length</replaceable>]</literal> for <replaceable>decorated-variable</replaceable>:
</para>
<screen>int foo[5];
</screen>
<para>To declare a variable that has a pointer type, write
<literal>*<replaceable>variable</replaceable></literal> for <replaceable>decorated-variable</replaceable>:
</para>
<screen>struct list_elt *foo;
</screen>
<para>These constructs nest.  For instance,
</para>
<screen>int foo[3][5];
</screen>
<para>declares <literal>foo</literal> as an array of 3 arrays of 5 integers each,
</para>
<screen>struct list_elt *foo[5];
</screen>
<para>declares <literal>foo</literal> as an array of 5 pointers to structures, and
</para>
<screen>struct list_elt **foo;
</screen>
<para>declares <literal>foo</literal> as a pointer to a pointer to a structure.
</para>
<screen>int **(*foo[30])(int, double);
</screen>
<para>declares <literal>foo</literal> as an array of 30 pointers to functions
(see <link linkend="Function-Pointers">Function Pointers</link>), each of which must accept two arguments
(one <literal>int</literal> and one <literal>double</literal>) and return type <literal>int **</literal>.
</para>
<screen>void
bar (int size)
{
  int foo[size];
  &#8230;
}
</screen>
<para>declares <literal>foo</literal> as an array of integers with a size specified at
run time when the function <literal>bar</literal> is called.
</para>
</sect2>
<sect2 label="20.1.2" id="Combining-Variable-Declarations">
<title>Combining Variable Declarations</title>
<indexterm role="cp"><primary>combining variable declarations</primary></indexterm>
<indexterm role="cp"><primary>variable declarations, combining</primary></indexterm>
<indexterm role="cp"><primary>declarations, combining</primary></indexterm>

<para>When multiple declarations have the same <replaceable>keywords</replaceable> and
<replaceable>basetype</replaceable>, you can combine them using commas.  Thus,
</para>
<screen><replaceable>keywords</replaceable> <replaceable>basetype</replaceable>
   <replaceable>decorated-variable-1</replaceable> [= <replaceable>init1</replaceable>],
   <replaceable>decorated-variable-2</replaceable> [= <replaceable>init2</replaceable>];
</screen>
<para>is equivalent to
</para>
<screen><replaceable>keywords</replaceable> <replaceable>basetype</replaceable>
   <replaceable>decorated-variable-1</replaceable> [= <replaceable>init1</replaceable>];
<replaceable>keywords</replaceable> <replaceable>basetype</replaceable>
   <replaceable>decorated-variable-2</replaceable> [= <replaceable>init2</replaceable>];
</screen>
<para>Here are some simple examples:
</para>
<screen>int a, b;
int a = 1, b = 2;
int a, *p, array[5];
int a = 0, *p = &amp;a, array[5] = {1, 2};
</screen>
<para>In the last two examples, <literal>a</literal> is an <literal>int</literal>, <literal>p</literal> is a
pointer to <literal>int</literal>, and <literal>array</literal> is an array of 5 <literal>int</literal>s.
Since the initializer for <literal>array</literal> specifies only two elements,
the other three elements are initialized to zero.
</para>
</sect2>
</sect1>
<sect1 label="20.2" id="Initializers">
<title>Initializers</title>
<indexterm role="cp"><primary>initializers</primary></indexterm>

<para>A variable&#8217;s declaration, unless it is <literal>extern</literal>, should also
specify its initial value.  For numeric and pointer-type variables,
the initializer is an expression for the value.  If necessary, it is
converted to the variable&#8217;s type, just as in an assignment.
</para>
<para>You can also initialize a local structure-type (see <link linkend="Structures">Structures</link>) or
local union-type (see <link linkend="Unions">Unions</link>) variable this way, from an
expression whose value has the same type.  But you can&#8217;t initialize an
array this way (see <link linkend="Arrays">Arrays</link>), since arrays are not first-class
objects in C (see <link linkend="Limitations-of-C-Arrays">Limitations of C Arrays</link>) and there is no array
assignment.
</para>
<para>You can initialize arrays and structures componentwise,
with a list of the elements or components.  You can initialize
a union with any one of its alternatives.
</para>
<itemizedlist><listitem><para>A component-wise initializer for an array consists of element values
surrounded by &#8216;<literal>{&#8230;}</literal>&#8217;.  If the values in the initializer
don&#8217;t cover all the elements in the array, the remaining elements are
initialized to zero.
</para>
<para>You can omit the size of the array when you declare it, and let
the initializer specify the size:
</para>
<screen>int array[] = { 3, 9, 12 };
</screen>
</listitem><listitem><para>A component-wise initializer for a structure consists of field values
surrounded by &#8216;<literal>{&#8230;}</literal>&#8217;.  Write the field values in the same
order as the fields are declared in the structure.  If the values in
the initializer don&#8217;t cover all the fields in the structure, the
remaining fields are initialized to zero.
</para>
</listitem><listitem><para>The initializer for a union-type variable has the form <literal>{
<replaceable>value</replaceable> }</literal>, where <replaceable>value</replaceable> initializes the <emphasis>first alternative</emphasis>
in the union definition.
</para></listitem></itemizedlist>
<para>For an array of arrays, a structure containing arrays, an array of
structures, etc., you can nest these constructs.  For example,
</para>
<screen>struct point { double x, y; };

struct point series[]
  = { {0, 0}, {1.5, 2.8}, {99, 100.0004} };
</screen>
<para>You can omit a pair of inner braces if they contain the right
number of elements for the sub-value they initialize, so that
no elements or fields need to be filled in with zeros.
But don&#8217;t do that very much, as it gets confusing.
</para>
<para>An array of <literal>char</literal> can be initialized using a string constant.
Recall that the string constant includes an implicit null character at
the end (see <link linkend="String-Constants">String Constants</link>).  Using a string constant as
initializer means to use its contents as the initial values of the
array elements.  Here are examples:
</para>
<screen>char text[6] = &quot;text!&quot;;     /* Includes the null. */
char text[5] = &quot;text!&quot;;     /* Excludes the null. */
char text[] = &quot;text!&quot;;      /* Gets length 6. */
char text[]
  = { 't', 'e', 'x', 't', '!', 0 };  /* same as above. */
char text[] = { &quot;text!&quot; };  /* Braces are optional. */
</screen>
<para>and this kind of initializer can be nested inside braces to initialize
structures or arrays that contain a <literal>char</literal>-array.
</para>
<para>In like manner, you can use a wide string constant to initialize
an array of <literal>wchar_t</literal>.
</para>
</sect1>
<sect1 label="20.3" id="Designated-Inits">
<title>Designated Initializers</title>
<indexterm role="cp"><primary>initializers with labeled elements</primary></indexterm>
<indexterm role="cp"><primary>labeled elements in initializers</primary></indexterm>
<indexterm role="cp"><primary>case labels in initializers</primary></indexterm>
<indexterm role="cp"><primary>designated initializers</primary></indexterm>

<para>In a complex structure or long array, it&#8217;s useful to indicate
which field or element we are initializing.
</para>
<para>To designate specific array elements during initialization, include
the array index in brackets, and an assignment operator, for each
element:
</para>
<screen>int foo[10] = { [3] = 42, [7] = 58 };
</screen>
<para>This does the same thing as:
</para>
<screen>int foo[10] = { 0, 0, 0, 42, 0, 0, 0, 58, 0, 0 };
</screen>
<para>The array initialization can include non-designated element values
alongside designated indices; these follow the expected ordering
of the array initialization, so that
</para>
<screen>int foo[10] = { [3] = 42, 43, 44, [7] = 58 };
</screen>
<para>does the same thing as:
</para>
<screen>int foo[10] = { 0, 0, 0, 42, 43, 44, 0, 58, 0, 0 };
</screen>
<para>Note that you can only use constant expressions as array index values,
not variables.
</para>
<para>If you need to initialize a subsequence of sequential array elements to
the same value, you can specify a range:
</para>
<screen>int foo[100] = { [0 ... 19] = 42, [20 ... 99] = 43 };
</screen>
<para>Using a range this way is a GNU C extension.
</para>
<para>When subsequence ranges overlap, each element is initialized by the
last specification that applies to it.  Thus, this initialization is
equivalent to the previous one.
</para>
<screen>int foo[100] = { [0 ... 99] = 43, [0 ... 19] = 42 };
</screen>
<para>as the second overrides the first for elements 0 through 19.
</para>
<para>The value used to initialize a range of elements is evaluated only
once, for the first element in the range.  So for example, this code
</para>
<screen>int random_values[100]
  = { [0 ... 99] = get_random_number() };
</screen>
<para>would initialize all 100 elements of the array <literal>random_values</literal> to
the same value&#8212;probably not what is intended.
</para>
<para>Similarly, you can initialize specific fields of a structure variable
by specifying the field name prefixed with a dot:
</para>
<screen>struct point { int x; int y; };

struct point foo = { .y = 42; };
</screen>
<para>The same syntax works for union variables as well:
</para>
<screen>union int_double { int i; double d; };

union int_double foo = { .d = 34 };
</screen>
<para>This casts the integer value 34 to a double and stores it
in the union variable <literal>foo</literal>.
</para>
<para>You can designate both array elements and structure elements in
the same initialization; for example, here&#8217;s an array of point
structures:
</para>
<screen>struct point point_array[10] = { [4].y = 32, [6].y = 39 };
</screen>
<para>Along with the capability to specify particular array and structure
elements to initialize comes the possibility of initializing the same
element more than once:
</para>
<screen>int foo[10] = { [4] = 42, [4] = 98 };
</screen>
<para>In such a case, the last initialization value is retained.
</para>
</sect1>
<sect1 label="20.4" id="Auto-Type">
<title>Referring to a Type with <literal>__auto_type</literal></title>
<indexterm role="fn"><primary>__auto_type</primary></indexterm>
<indexterm role="fn"><primary>typeof</primary></indexterm>
<indexterm role="cp"><primary>macros, types of arguments</primary></indexterm>

<para>You can declare a variable copying the type from
the initializer by using <literal>__auto_type</literal> instead of a particular type.
Here&#8217;s an example:
</para>
<screen>#define max(a,b) \
  ({ __auto_type _a = (a); \
      __auto_type _b = (b); \
    _a &gt; _b ? _a : _b })
</screen>
<para>This defines <literal>_a</literal> to be of the same type as <literal>a</literal>, and
<literal>_b</literal> to be of the same type as <literal>b</literal>.  This is a useful thing
to do in a macro that ought to be able to handle any type of data
(see <link linkend="Macros-and-Auto-Type">Macros and Auto Type</link>).
</para>
<para>The original GNU C method for obtaining the type of a value is to use
<literal>typeof</literal>, which takes as an argument either a value or the name of
a type.  The previous example could also be written as:
</para>
<screen>#define max(a,b) \
  ({ typeof(a) _a = (a); \
      typeof(b) _b = (b); \
    _a &gt; _b ? _a : _b })
</screen>
<para><literal>typeof</literal> is more flexible than <literal>__auto_type</literal>; however, the
principal use case for <literal>typeof</literal> is in variable declarations with
initialization, which is exactly what <literal>__auto_type</literal> handles.
</para>
</sect1>
<sect1 label="20.5" id="Local-Variables">
<title>Local Variables</title>
<indexterm role="cp"><primary>local variables</primary></indexterm>
<indexterm role="cp"><primary>variables, local</primary></indexterm>

<para>Declaring a variable inside a function definition (see <link linkend="Function-Definitions">Function
Definitions</link>) makes the variable name <firstterm>local</firstterm> to the containing
block&#8212;that is, the containing pair of braces.  More precisely, the
variable&#8217;s name is visible starting just after where it appears in the
declaration, and its visibility continues until the end of the block.
</para>
<para>Local variables in C are generally <firstterm>automatic</firstterm> variables: each
variable&#8217;s storage exists only from the declaration to the end of the
block.  Execution of the declaration allocates the storage, computes
the initial value, and stores it in the variable.  The end of the
block deallocates the storage.<footnote><para>Due to compiler optimizations,
allocation and deallocation don&#8217;t necessarily really happen at
those times.</para></footnote>
</para>
<para><emphasis role="bold">Warning:</emphasis> Two declarations for the same local variable
in the same scope are an error.
</para>
<para><emphasis role="bold">Warning:</emphasis> Automatic variables are stored in the run-time stack.
The total space for the program&#8217;s stack may be limited; therefore,
in using very large arrays, it may be necessary to allocate
them in some other way to stop the program from crashing.
</para>
<para><emphasis role="bold">Warning:</emphasis> If the declaration of an automatic variable does not
specify an initial value, the variable starts out containing garbage.
In this example, the value printed could be anything at all:
</para>
<screen>{
  int i;

  printf (&quot;Print junk %d\n&quot;, i);
}
</screen>
<para>In a simple test program, that statement is likely to print 0, simply
because every process starts with memory zeroed.  But don&#8217;t rely on it
to be zero&#8212;that is erroneous.
</para>
<para><emphasis role="bold">Note:</emphasis> Make sure to store a value into each local variable (by
assignment, or by initialization) before referring to its value.
</para>
</sect1>
<sect1 label="20.6" id="File_002dScope-Variables">
<title>File-Scope Variables</title>
<indexterm role="cp"><primary>file-scope variables</primary></indexterm>
<indexterm role="cp"><primary>global variables</primary></indexterm>
<indexterm role="cp"><primary>variables, file-scope</primary></indexterm>
<indexterm role="cp"><primary>variables, global</primary></indexterm>

<para>A variable declaration at the top level in a file (not inside a
function definition) declares a <firstterm>file-scope variable</firstterm>.  Loading a
program allocates the storage for all the file-scope variables in it,
and initializes them too.
</para>
<para>Each file-scope variable is either <firstterm>static</firstterm> (limited to one
compilation module) or <firstterm>global</firstterm> (shared with all compilation
modules in the program).  To make the variable static, write the
keyword <literal>static</literal> at the start of the declaration.  Omitting
<literal>static</literal> makes the variable global.
</para>
<para>The initial value for a file-scope variable can&#8217;t depend on the
contents of storage, and can&#8217;t call any functions.
</para>
<screen>int foo = 5;         /* Valid. */
int bar = foo;       /* Invalid! */
int bar = sin (1.0); /* Invalid! */
</screen>
<para>But it can use the address of another file-scope variable:
</para>
<screen>int foo;
int *bar = &amp;foo;     /* Valid. */
int arr[5];
int *bar3 = &amp;arr[3]; /* Valid. */
int *bar4 = arr + 4; /* Valid. */
</screen>
<para>It is valid for a module to have multiple declarations for a
file-scope variable, as long as they are all global or all static, but
at most one declaration can specify an initial value for it.
</para>
</sect1>
<sect1 label="20.7" id="Static-Local-Variables">
<title>Static Local Variables</title>
<indexterm role="cp"><primary>static local variables</primary></indexterm>
<indexterm role="cp"><primary>variables, static local</primary></indexterm>
<indexterm role="fn"><primary>static</primary></indexterm>

<para>The keyword <literal>static</literal> in a local variable declaration says to
allocate the storage for the variable permanently, just like a
file-scope variable, even if the declaration is within a function.
</para>
<para>Here&#8217;s an example:
</para>
<screen>int
increment_counter ()
{
  static int counter = 0;
  return ++counter;
}
</screen>
<para>The scope of the name <literal>counter</literal> runs from the declaration to the
end of the containing block, just like an automatic local variable,
but its storage is permanent, so the value persists from one call to
the next.  As a result, each call to <literal>increment_counter</literal>
returns a different, unique value.
</para>
<para>The initial value of a static local variable has the same limitations
as for file-scope variables: it can&#8217;t depend on the contents of
storage or call any functions.  It can use the address of a file-scope
variable or a static local variable, because those addresses are
determined before the program runs.
</para>
</sect1>
<sect1 label="20.8" id="Extern-Declarations">
<title><literal>extern</literal> Declarations</title>
<indexterm role="cp"><primary><literal>extern</literal> declarations</primary></indexterm>
<indexterm role="cp"><primary>declarations, <literal>extern</literal></primary></indexterm>
<indexterm role="fn"><primary>extern</primary></indexterm>

<para>An <literal>extern</literal> declaration is used to refer to a global variable
whose principal declaration comes elsewhere&#8212;in the same module, or in
another compilation module.  It looks like this:
</para>
<screen>extern <replaceable>basetype</replaceable> <replaceable>decorated-variable</replaceable>;
</screen>
<para>Its meaning is that, in the current scope, the variable name refers to
the file-scope variable of that name&#8212;which needs to be declared in a
non-<literal>extern</literal>, non-<literal>static</literal> way somewhere else.
</para>
<para>For instance, if one compilation module has this global variable
declaration
</para>
<screen>int error_count = 0;
</screen>
<para>then other compilation modules can specify this
</para>
<screen>extern int error_count;
</screen>
<para>to allow reference to the same variable.
</para>
<para>The usual place to write an <literal>extern</literal> declaration is at top level
in a source file, but you can write an <literal>extern</literal> declaration
inside a block to make a global or static file-scope variable
accessible in that block.
</para>
<para>Since an <literal>extern</literal> declaration does not allocate space for the
variable, it can omit the size of an array:
</para>
<screen>extern int array[];
</screen>
<para>You can use <literal>array</literal> normally in all contexts where it is
converted automatically to a pointer.  However, to use it as the
operand of <literal>sizeof</literal> is an error, since the size is unknown.
</para>
<para>It is valid to have multiple <literal>extern</literal> declarations for the same
variable, even in the same scope, if they give the same type.  They do
not conflict&#8212;they agree.  For an array, it is legitimate for some
<literal>extern</literal> declarations can specify the size while others omit it.
However, if two declarations give different sizes, that is an error.
</para>
<para>Likewise, you can use <literal>extern</literal> declarations at file scope
(see <link linkend="File_002dScope-Variables">File-Scope Variables</link>) followed by an ordinary global
(non-static) declaration of the same variable.  They do not conflict,
because they say compatible things about the same meaning of the variable.
</para>
</sect1>
<sect1 label="20.9" id="Allocating-File_002dScope">
<title>Allocating File-Scope Variables</title>
<indexterm role="cp"><primary>allocation file-scope variables</primary></indexterm>
<indexterm role="cp"><primary>file-scope variables, allocating</primary></indexterm>

<para>Some file-scope declarations allocate space for the variable, and some
don&#8217;t.
</para>
<para>A file-scope declaration with an initial value <emphasis>must</emphasis> allocate
space for the variable; if there are two of such declarations for the
same variable, even in different compilation modules, they conflict.
</para>
<para>An <literal>extern</literal> declaration <emphasis>never</emphasis> allocates space for the variable.
If all the top-level declarations of a certain variable are
<literal>extern</literal>, the variable never gets memory space.  If that variable
is used anywhere in the program, the use will be reported as an error,
saying that the variable is not defined.
</para>
<indexterm role="cp"><primary>tentative definition</primary></indexterm>
<para>A file-scope declaration without an initial value is called a
<firstterm>tentative definition</firstterm>.  This is a strange hybrid: it <emphasis>can</emphasis>
allocate space for the variable, but does not insist.  So it causes no
conflict, no error, if the variable has another declaration that
allocates space for it, perhaps in another compilation module.  But if
nothing else allocates space for the variable, the tentative
definition will do it.  Any number of compilation modules can declare
the same variable in this way, and that is sufficient for all of them
to use the variable.
</para>
<!-- @opindex -fno-common -->
<!-- @opindex -warn_common -->
<para>In programs that are very large or have many contributors, it may be
wise to adopt the convention of never using tentative definitions.
You can use the compilation option <option>-fno-common</option> to make them
an error, or <option>--warn-common</option> to warn about them.
</para>
<para>If a file-scope variable gets its space through a tentative
definition, it starts out containing all zeros.
</para>
</sect1>
<sect1 label="20.10" id="auto-and-register">
<title><literal>auto</literal> and <literal>register</literal></title>
<indexterm role="cp"><primary><literal>auto</literal> declarations</primary></indexterm>
<indexterm role="cp"><primary><literal>register</literal> declarations</primary></indexterm>
<indexterm role="fn"><primary>auto</primary></indexterm>
<indexterm role="fn"><primary>register</primary></indexterm>

<para>For historical reasons, you can write <literal>auto</literal> or <literal>register</literal>
before a local variable declaration.  <literal>auto</literal> merely emphasizes
that the variable isn&#8217;t static; it changes nothing.
</para>
<para><literal>register</literal> suggests to the compiler storing this variable in a
register.  However, GNU C ignores this suggestion, since it can
choose the best variables to store in registers without any hints.
</para>
<para>It is an error to take the address of a variable declared
<literal>register</literal>, so you cannot use the unary &#8216;<literal>&amp;</literal>&#8217; operator on it.
If the variable is an array, you can&#8217;t use it at all (other than as
the operand of <literal>sizeof</literal>), which makes it rather useless.
</para>
</sect1>
<sect1 label="20.11" id="Omitting-Types">
<title>Omitting Types in Declarations</title>
<indexterm role="cp"><primary>omitting types in declarations</primary></indexterm>

<para>The syntax of C traditionally allows omitting the data type in a
declaration if it specifies a storage class, a type qualifier (see the
next chapter), or <literal>auto</literal> or <literal>register</literal>.  Then the type
defaults to <literal>int</literal>.  For example:
</para>
<screen>auto foo = 42;
</screen>
<para>This is bad practice; if you see it, fix it.
</para>
</sect1>
</chapter>
<chapter label="21" id="Type-Qualifiers">
<title>Type Qualifiers</title>

<para>A declaration can include type qualifiers to advise the compiler
about how the variable will be used.  There are three different
qualifiers, <literal>const</literal>, <literal>volatile</literal> and <literal>restrict</literal>.  They
pertain to different issues, so you can use more than one together.
For instance, <literal>const volatile</literal> describes a value that the
program is not allowed to change, but might have a different value
each time the program examines it.  (This might perhaps be a special
hardware register, or part of shared memory.)
</para>
<para>If you are just learning C, you can skip this chapter.
</para>

<sect1 label="21.1" id="const">
<title><literal>const</literal> Variables and Fields</title>
<indexterm role="cp"><primary><literal>const</literal> variables and fields</primary></indexterm>
<indexterm role="cp"><primary>variables, <literal>const</literal></primary></indexterm>
<indexterm role="fn"><primary>const</primary></indexterm>

<para>You can mark a variable as &#8220;constant&#8221; by writing <literal>const</literal> in
front of the declaration.  This says to treat any assignment to that
variable as an error.  It may also permit some compiler
optimizations&#8212;for instance, to fetch the value only once to satisfy
multiple references to it.  The construct looks like this:
</para>
<screen>const double pi = 3.14159;
</screen>
<para>After this definition, the code can use the variable <literal>pi</literal>
but cannot assign a different value to it.
</para>
<screen>pi = 3.0; /* Error! */
</screen>
<para>Simple variables that are constant can be used for the same purposes
as enumeration constants, and they are not limited to integers.  The
constantness of the variable propagates into pointers, too.
</para>
<para>A pointer type can specify that the <emphasis>target</emphasis> is constant.  For
example, the pointer type <literal>const double *</literal> stands for a pointer
to a constant <literal>double</literal>.  That&#8217;s the typethat results from taking
the address of <literal>pi</literal>.  Such a pointer can&#8217;t be dereferenced in the
left side of an assignment.
</para>
<screen>*(&amp;pi) = 3.0; /* Error! */
</screen>
<para>Nonconstant pointers can be converted automatically to constant
pointers, but not vice versa.  For instance,
</para>
<screen>const double *cptr;
double *ptr;

cptr = &amp;pi;    /* Valid. */
cptr = ptr;    /* Valid. */
ptr = cptr;    /* Error! */
ptr = &amp;pi;     /* Error! */
</screen>
<para>This is not an ironclad protection against modifying the value.  You
can always cast the constant pointer to a nonconstant pointer type:
</para>
<screen>ptr = (double *)cptr;    /* Valid. */
ptr = (double *)&amp;pi;     /* Valid. */
</screen>
<para>However, <literal>const</literal> provides a way to show that a certain function
won&#8217;t modify the data structure whose address is passed to it.  Here&#8217;s
an example:
</para>
<screen>int
string_length (const char *string)
{
  int count = 0;
  while (*string++)
    count++;
  return count;
}
</screen>
<para>Using <literal>const char *</literal> for the parameter is a way of saying this
function never modifies the memory of the string itself.
</para>
<para>In calling <literal>string_length</literal>, you can specify an ordinary
<literal>char *</literal> since that can be converted automatically to <literal>const
char *</literal>.
</para>
</sect1>
<sect1 label="21.2" id="volatile">
<title><literal>volatile</literal> Variables and Fields</title>
<indexterm role="cp"><primary><literal>volatile</literal> variables and fields</primary></indexterm>
<indexterm role="cp"><primary>variables, <literal>volatile</literal></primary></indexterm>
<indexterm role="fn"><primary>volatile</primary></indexterm>

<para>The GNU C compiler often performs optimizations that eliminate the
need to write or read a variable.  For instance,
</para>
<screen>int foo;
foo = 1;
foo++;
</screen>
<para>might simply store the value 2 into <literal>foo</literal>, without ever storing 1.
These optimizations can also apply to structure fields in some cases.
</para>
<para>If the memory containing <literal>foo</literal> is shared with another program,
or if it is examined asynchronously by hardware, such optimizations
could confuse the communication.  Using <literal>volatile</literal> is one way
to prevent them.
</para>
<para>Writing <literal>volatile</literal> with the type in a variable or field declaration
says that the value may be examined or changed for reasons outside the
control of the program at any moment.  Therefore, the program must
execute in a careful way to assure correct interaction with those
accesses, whenever they may occur.
</para>
<para>The simplest use looks like this:
</para>
<screen>volatile int lock;
</screen>
<para>This directs the compiler not to do certain common optimizations on
use of the variable <literal>lock</literal>.  All the reads and writes for a volatile
variable or field are really done, and done in the order specified
by the source code.  Thus, this code:
</para>
<screen>lock = 1;
list = list-&gt;next;
if (lock)
  lock_broken (&amp;lock);
lock = 0;
</screen>
<para>really stores the value 1 in <literal>lock</literal>, even though there is no
sign it is really used, and the <literal>if</literal> statement reads and
checks the value of <literal>lock</literal>, rather than assuming it is still 1.
</para>
<para>A limited amount of optimization can be done, in principle, on
<literal>volatile</literal> variables and fields: multiple references between two
sequence points (see <link linkend="Sequence-Points">Sequence Points</link>) can be simplified together.
</para>
<para>Use of <literal>volatile</literal> does not eliminate the flexibility in ordering
the computation of the operands of most operators.  For instance, in
<literal>lock + foo ()</literal>, the order of accessing <literal>lock</literal> and calling
<literal>foo</literal> is not specified, so they may be done in either order; the
fact that <literal>lock</literal> is <literal>volatile</literal> has no effect on that.
</para>
</sect1>
<sect1 label="21.3" id="restrict-Pointers">
<title><literal>restrict</literal>-Qualified Pointers</title>
<indexterm role="cp"><primary><literal>restrict</literal> pointers</primary></indexterm>
<indexterm role="cp"><primary>pointers, <literal>restrict</literal>-qualified</primary></indexterm>
<indexterm role="fn"><primary>restrict</primary></indexterm>

<para>You can declare a pointer as &#8220;restricted&#8221; using the <literal>restrict</literal>
type qualifier, like this:
</para>
<screen>int *restrict p = x;
</screen>
<para>This enables better optimization of code that uses the pointer.
</para>
<para>If <literal>p</literal> is declared with <literal>restrict</literal>, and then the code
references the object that <literal>p</literal> points to (using <literal>*p</literal> or
<literal>p[<replaceable>i</replaceable>]</literal>), the <literal>restrict</literal> declaration promises that the
code will not access that object in any other way&#8212;only through
<literal>p</literal>.
</para>
<para>For instance, it means the code must not use another pointer
to access the same space, as shown here:
</para>
<screen>int *restrict p = <replaceable>whatever</replaceable>;
int *q = p;
foo (*p, *q);
</screen>
<para>That contradicts the <literal>restrict</literal> promise by accessing the object
that <literal>p</literal> points to using <literal>q</literal>, which bypasses <literal>p</literal>.
Likewise, it must not do this:
</para>
<screen>int *restrict p = <replaceable>whatever</replaceable>;
struct { int *a, *b; } s;
s.a = p;
foo (*p, *s.a);
</screen>
<para>This example uses a structure field instead of the variable <literal>q</literal>
to hold the other pointer, and that contradicts the promise just the
same.
</para>
<para>The keyword <literal>restrict</literal> also promises that <literal>p</literal> won&#8217;t point to
the allocated space of any automatic or static variable.  So the code
must not do this:
</para>
<screen>int a;
int *restrict p = &amp;a;
foo (*p, a);
</screen>
<para>because that does direct access to the object (<literal>a</literal>) that <literal>p</literal>
points to, which bypasses <literal>p</literal>.
</para>
<para>If the code makes such promises with <literal>restrict</literal> then breaks them,
execution is unpredictable.
</para>
</sect1>
<sect1 label="21.4" id="restrict-Pointer-Example">
<title><literal>restrict</literal> Pointer Example</title>

<para>Here are examples where <literal>restrict</literal> enables real optimization.
</para>
<para>In this example, <literal>restrict</literal> assures GCC that the array <literal>out</literal>
points to does not overlap with the array <literal>in</literal> points to.
</para>
<screen>void
process_data (const char *in,
              char * restrict out,
              size_t size)
{
  for (i = 0; i &lt; size; i++)
    out[i] = in[i] + in[i + 1];
}
</screen>
<para>Here&#8217;s a simple tree structure, where each tree node holds data of
type <literal>PAYLOAD</literal> plus two subtrees.
</para>
<screen>struct foo
  {
    PAYLOAD payload;
    struct foo *left;
    struct foo *right;
  };
</screen>
<para>Now here&#8217;s a function to null out both pointers in the <literal>left</literal>
subtree.
</para>
<screen>void
null_left (struct foo *a)
{
  a-&gt;left-&gt;left = NULL;
  a-&gt;left-&gt;right = NULL;
}
</screen>
<para>Since <literal>*a</literal> and <literal>*a-&gt;left</literal> have the same data type,
they could legitimately alias (see <link linkend="Aliasing">Aliasing</link>).  Therefore,
the compiled code for <literal>null_left</literal> must read <literal>a-&gt;left</literal>
again from memory when executing the second assignment statement.
</para>
<para>We can enable optimization, so that it does not need to read
<literal>a-&gt;left</literal> again, by writing <literal>null_left</literal> this in a less
obvious way.
</para>
<screen>void
null_left (struct foo *a)
{
  struct foo *b = a-&gt;left;
  b-&gt;left = NULL;
  b-&gt;right = NULL;
}
</screen>
<para>A more elegant way to fix this is with <literal>restrict</literal>.
</para>
<screen>void
null_left (struct foo *restrict a)
{
  a-&gt;left-&gt;left = NULL;
  a-&gt;left-&gt;right = NULL;
}
</screen>
<para>Declaring <literal>a</literal> as <literal>restrict</literal> asserts that other pointers such
as <literal>a-&gt;left</literal> will not point to the same memory space as <literal>a</literal>.
Therefore, the memory location <literal>a-&gt;left-&gt;left</literal> cannot be the same
memory as <literal>a-&gt;left</literal>.  Knowing this, the compiled code may avoid
reloading <literal>a-&gt;left</literal> for the second statement.
</para>
</sect1>
</chapter>
<chapter label="22" id="Functions">
<title>Functions</title>
<indexterm role="cp"><primary>functions</primary></indexterm>

<para>We have already presented many examples of functions, so if you&#8217;ve
read this far, you basically understand the concept of a function.  It
is vital, nonetheless, to have a chapter in the manual that collects
all the information about functions.
</para>

<sect1 label="22.1" id="Function-Definitions">
<title>Function Definitions</title>
<indexterm role="cp"><primary>function definitions</primary></indexterm>
<indexterm role="cp"><primary>defining functions</primary></indexterm>

<para>We have already presented many examples of function definitions.  To
summarize the rules, a function definition looks like this:
</para>
<screen><replaceable>returntype</replaceable>
<replaceable>functionname</replaceable> (<replaceable>parm_declarations</replaceable>&#8230;)
{
  <replaceable>body</replaceable>
}
</screen>
<para>The part before the open-brace is called the <firstterm>function header</firstterm>.
</para>
<para>Write <literal>void</literal> as the <replaceable>returntype</replaceable> if the function does
not return a value.
</para>

<sect2 label="22.1.1" id="Function-Parameter-Variables">
<title>Function Parameter Variables</title>
<indexterm role="cp"><primary>function parameter variables</primary></indexterm>
<indexterm role="cp"><primary>parameter variables in functions</primary></indexterm>
<indexterm role="cp"><primary>parameter list</primary></indexterm>

<para>A function parameter variable is a local variable (see <link linkend="Local-Variables">Local
Variables</link>) used within the function to store the value passed as an
argument in a call to the function.  Usually we say &#8220;function
parameter&#8221; or &#8220;parameter&#8221; for short, not mentioning the fact that
it&#8217;s a variable.
</para>
<para>We declare these variables in the beginning of the function
definition, in the <firstterm>parameter list</firstterm>.  For example,
</para>
<screen>fib (int n)
</screen>
<para>has a parameter list with one function parameter <literal>n</literal>, which has
type <literal>int</literal>.
</para>
<para>Function parameter declarations differ from ordinary variable
declarations in several ways:
</para>
<itemizedlist><listitem><para>Inside the function definition header, commas separate parameter
declarations, and each parameter needs a complete declaration
including the type.  For instance, if a function <literal>foo</literal> has two
<literal>int</literal> parameters, write this:
</para>
<screen>foo (int a, int b)
</screen>
<para>You can&#8217;t share the common <literal>int</literal> between the two declarations:
</para>
<screen>foo (int a, b)      /* Invalid! */
</screen>
</listitem><listitem><para>A function parameter variable is initialized to whatever value is
passed in the function call, so its declaration cannot specify an
initial value.
</para>
</listitem><listitem><para>Writing an array type in a function parameter declaration has the
effect of declaring it as a pointer.  The size specified for the array
has no effect at all, and we normally omit the size.  Thus,
</para>
<screen>foo (int a[5])
foo (int a[])
foo (int *a)
</screen>
<para>are equivalent.
</para>
</listitem><listitem><para>The scope of the parameter variables is the entire function body,
notwithstanding the fact that they are written in the function header,
which is just outside the function body.
</para></listitem></itemizedlist>
<para>If a function has no parameters, it would be most natural for the
list of parameters in its definition to be empty.  But that, in C, has
a special meaning for historical reasons: &#8220;Do not check that calls to
this function have the right number of arguments.&#8221;  Thus,
</para>
<screen>int
foo ()
{
  return 5;
}

int
bar (int x)
{
  return foo (x);
}
</screen>
<para>would not report a compilation error in passing <literal>x</literal> as an
argument to <literal>foo</literal>.  By contrast,
</para>
<screen>int
foo (void)
{
  return 5;
}

int
bar (int x)
{
  return foo (x);
}
</screen>
<para>would report an error because <literal>foo</literal> is supposed to receive
no arguments.
</para>
</sect2>
<sect2 label="22.1.2" id="Forward-Function-Declarations">
<title>Forward Function Declarations</title>
<indexterm role="cp"><primary>forward function declarations</primary></indexterm>
<indexterm role="cp"><primary>function declarations, forward</primary></indexterm>

<para>The order of the function definitions in the source code makes no
difference, except that each function needs to be defined or declared
before code uses it.
</para>
<para>The definition of a function also declares its name for the rest of
the containing scope.  But what if you want to call the function
before its definition?  To permit that, write a compatible declaration
of the same function, before the first call.  A declaration that
prefigures a subsequent definition in this way is called a
<firstterm>forward declaration</firstterm>.  The function declaration can be at top
<!-- ??? file scope -->
level or within a block, and it applies until the end of the containing
scope.
</para>
<para>See <link linkend="Function-Declarations">Function Declarations</link>, for more information about these
declarations.
</para>
</sect2>
<sect2 label="22.1.3" id="Static-Functions">
<title>Static Functions</title>
<indexterm role="cp"><primary>static functions</primary></indexterm>
<indexterm role="cp"><primary>functions, static</primary></indexterm>
<indexterm role="fn"><primary>static</primary></indexterm>

<para>The keyword <literal>static</literal> in a function definition limits the
visibility of the name to the current compilation module.  (That&#8217;s the
same thing <literal>static</literal> does in variable declarations;
see <link linkend="File_002dScope-Variables">File-Scope Variables</link>.)  For instance, if one compilation module
contains this code:
</para>
<screen>static int
foo (void)
{
  &#8230;
}
</screen>
<para>then the code of that compilation module can call <literal>foo</literal> anywhere
after the definition, but other compilation modules cannot refer to it
at all.
</para>
<indexterm role="cp"><primary>forward declaration</primary></indexterm>
<indexterm role="cp"><primary>static function, declaration</primary></indexterm>
<para>To call <literal>foo</literal> before its definition, it needs a forward
declaration, which should use <literal>static</literal> since the function
definition does.  For this function, it looks like this:
</para>
<screen>static int foo (void);
</screen>
<para>It is generally wise to use <literal>static</literal> on the definitions of
functions that won&#8217;t be called from outside the same compilation
module.  This makes sure that calls are not added in other modules.
If programmers decide to change the function&#8217;s calling convention, or
understand all the consequences of its use, they will only have to
check for calls in the same compilation module.
</para>
</sect2>
<sect2 label="22.1.4" id="Arrays-as-Parameters">
<title>Arrays as Parameters</title>
<indexterm role="cp"><primary>array as parameters</primary></indexterm>
<indexterm role="cp"><primary>functions with array parameters</primary></indexterm>

<para>Arrays in C are not first-class objects: it is impossible to copy
them.  So they cannot be passed as arguments like other values.
See <link linkend="Limitations-of-C-Arrays">Limitations of C Arrays</link>.  Rather, array parameters work in
a special way.
</para>

<sect3 label="22.1.4.1" id="Array-Parm-Pointer">
<title>Array parameters are pointers</title>

<para>Declaring a function parameter variable as an array really gives it a
pointer type.  C does this because an expression with array type, if
used as an argument in a function call, is converted automatically to
a pointer (to the zeroth element of the array).  If you declare the
corresponding parameter as an &#8220;array&#8221;, it will work correctly with
the pointer value that really gets passed.
</para>
<para>This relates to the fact that C does not check array bounds in access
to elements of the array (see <link linkend="Accessing-Array-Elements">Accessing Array Elements</link>).
</para>
<para>For example, in this function,
</para>
<screen>void
clobber4 (int array[20])
{
  array[4] = 0;
}
</screen>
<para>the parameter <literal>array</literal>&#8217;s real type is <literal>int *</literal>; the specified
length, 20, has no effect on the program.  You can leave out the length
and write this:
</para>
<screen>void
clobber4 (int array[])
{
  array[4] = 0;
}
</screen>
<para>or write the parameter declaration explicitly as a pointer:
</para>
<screen>void
clobber4 (int *array)
{
  array[4] = 0;
}
</screen>
<para>They are all equivalent.
</para>
</sect3>
<sect3 label="22.1.4.2" id="Passing-Array-Args">
<title>Passing array arguments</title>

<para>The function call passes this pointer by
value, like all argument values in C.  However, the result is
paradoxical in that the array itself is passed by reference: its
contents are treated as shared memory&#8212;shared between the caller and
the called function, that is.  When <literal>clobber4</literal> assigns to element
4 of <literal>array</literal>, the effect is to alter element 4 of the array
specified in the call.
</para>
<screen>#include &lt;stddef.h&gt;  /* Defines <literal>NULL</literal>. */
#include &lt;stdlib.h&gt;  /* Declares <literal>malloc</literal>, */
                     /* Defines <literal>EXIT_SUCCESS</literal>. */

int
main (void)
{
  int data[] = {1, 2, 3, 4, 5, 6};
  int i;

  /* Show the initial value of element 4. */
  for (i = 0; i &lt; 6; i++)
    printf (&quot;data[%d] = %d\n&quot;, i, data[i]);

  printf (&quot;\n&quot;);

  clobber4 (data);

  /* Show that element 4 has been changed. */
  for (i = 0; i &lt; 6; i++)
    printf (&quot;data[%d] = %d\n&quot;, i, data[i]);

  printf (&quot;\n&quot;);

  return EXIT_SUCCESS;
}
</screen>
<para>shows that <literal>data[4]</literal> has become zero after the call to
<literal>clobber4</literal>.
</para>
<para>The array <literal>data</literal> has 6 elements, but passing it to a function
whose argument type is written as <literal>int [20]</literal> is not an error,
because that really stands for <literal>int *</literal>.  The pointer that is the
real argument carries no indication of the length of the array it
points into.  It is not required to point to the beginning of the
array, either.  For instance,
</para>
<screen>clobber4 (data+1);
</screen>
<para>passes an &#8220;array&#8221; that starts at element 1 of <literal>data</literal>, and the
effect is to zero <literal>data[5]</literal> instead of <literal>data[4]</literal>.
</para>
<para>If all calls to the function will provide an array of a particular
size, you can specify the size of the array to be <literal>static</literal>:
</para>
<screen>void
clobber4 (int array[static 20])
&#8230;
</screen>
<para>This is a promise to the compiler that the function will always be
called with an array of 20 elements, so that the compiler can optimize
code accordingly.  If the code breaks this promise and calls the
function with, for example, a shorter array, unpredictable things may
happen.
</para>
</sect3>
<sect3 label="22.1.4.3" id="Array-Parm-Qualifiers">
<title>Type qualifiers on array parameters</title>

<para>You can use the type qualifiers <literal>const</literal>, <literal>restrict</literal>, and
<literal>volatile</literal> with array parameters; for example:
</para>
<screen>void
clobber4 (volatile int array[20])
&#8230;
</screen>
<para>denotes that <literal>array</literal> is equivalent to a pointer to a volatile
<literal>int</literal>.  Alternatively:
</para>
<screen>void
clobber4 (int array[const 20])
&#8230;
</screen>
<para>makes the array parameter equivalent to a constant pointer to an
<literal>int</literal>.  If we want the <literal>clobber4</literal> function to succeed, it
would not make sense to write
</para>
<screen>void
clobber4 (const int array[20])
&#8230;
</screen>
<para>as this would tell the compiler that the parameter should point to an
array of constant <literal>int</literal> values, and then we would not be able to
store zeros in them.
</para>
<para>In a function with multiple array parameters, you can use <literal>restrict</literal>
to tell the compiler that each array parameter passed in will be distinct:
</para>
<screen>void
foo (int array1[restrict 10], int array2[restrict 10])
&#8230;
</screen>
<para>Using <literal>restrict</literal> promises the compiler that callers will
not pass in the same array for more than one <literal>restrict</literal> array
parameter.  Knowing this enables the compiler to perform better code
optimization. This is the same effect as using <literal>restrict</literal>
pointers (see <link linkend="restrict-Pointers">restrict Pointers</link>), but makes it clear when reading
the code that an array of a specific size is expected.
</para>
</sect3>
</sect2>
<sect2 label="22.1.5" id="Structs-as-Parameters">
<title>Functions That Accept Structure Arguments</title>

<para>Structures in GNU C are first-class objects, so using them as function
parameters and arguments works in the natural way.  This function
<literal>swapfoo</literal> takes a <literal>struct foo</literal> with two fields as argument,
and returns a structure of the same type but with the fields
exchanged.
</para>
<screen>struct foo { int a, b; };

struct foo x;

struct foo
swapfoo (struct foo inval)
{
  struct foo outval;
  outval.a = inval.b;
  outval.b = inval.a;
  return outval;
}
</screen>
<para>This simpler definition of <literal>swapfoo</literal> avoids using a local
variable to hold the result about to be return, by using a structure
constructor (see <link linkend="Structure-Constructors">Structure Constructors</link>), like this:
</para>
<screen>struct foo
swapfoo (struct foo inval)
{
  return (struct foo) { inval.b, inval.a };
}
</screen>
<para>It is valid to define a structure type in a function&#8217;s parameter list,
as in
</para>
<screen>int
frob_bar (struct bar { int a, b; } inval)
{
  <replaceable>body</replaceable>
}
</screen>
<para>and <replaceable>body</replaceable> can access the fields of <replaceable>inval</replaceable> since the
structure type <literal>struct bar</literal> is defined for the whole function
body.  However, there is no way to create a <literal>struct bar</literal> argument
to pass to <literal>frob_bar</literal>, except with kludges.  As a result,
defining a structure type in a parameter list is useless in practice.
</para>
</sect2>
</sect1>
<sect1 label="22.2" id="Function-Declarations">
<title>Function Declarations</title>
<indexterm role="cp"><primary>function declarations</primary></indexterm>
<indexterm role="cp"><primary>declararing functions</primary></indexterm>

<para>To call a function, or use its name as a pointer, a <firstterm>function
declaration</firstterm> for the function name must be in effect at that point in
the code.  The function&#8217;s definition serves as a declaration of that
function for the rest of the containing scope, but to use the function
in code before the definition, or from another compilation module, a
separate function declaration must precede the use.
</para>
<para>A function declaration looks like the start of a function definition.
It begins with the return value type (<literal>void</literal> if none) and the
function name, followed by argument declarations in parentheses
(though these can sometimes be omitted).  But that&#8217;s as far as the
similarity goes: instead of the function body, the declaration uses a
semicolon.
</para>
<indexterm role="cp"><primary>function prototype</primary></indexterm>
<indexterm role="cp"><primary>prototype of a function</primary></indexterm>
<para>A declaration that specifies argument types is called a <firstterm>function
prototype</firstterm>.  You can include the argument names or omit them.  The
names, if included in the declaration, have no effect, but they may
serve as documentation.
</para>
<para>This form of prototype specifies fixed argument types:
</para>
<screen><replaceable>rettype</replaceable> <replaceable>function</replaceable> (<replaceable>argtypes</replaceable>&#8230;);
</screen>
<para>This form says the function takes no arguments:
</para>
<screen><replaceable>rettype</replaceable> <replaceable>function</replaceable> (void);
</screen>
<para>This form declares types for some arguments, and allows additional
arguments whose types are not specified:
</para>
<screen><replaceable>rettype</replaceable> <replaceable>function</replaceable> (<replaceable>argtypes</replaceable>&#8230;, ...);
</screen>
<para>For a parameter that&#8217;s an array of variable length, you can write
its declaration with &#8216;<literal>*</literal>&#8217; where the &#8220;length&#8221; of the array would
normally go; for example, these are all equivalent.
</para>
<screen>double maximum (int n, int m, double a[n][m]);
double maximum (int n, int m, double a[*][*]);
double maximum (int n, int m, double a[ ][*]);
double maximum (int n, int m, double a[ ][m]);
</screen>
<para>The old-fashioned form of declaration, which is not a prototype, says
nothing about the types of arguments or how many they should be:
</para>
<screen><replaceable>rettype</replaceable> <replaceable>function</replaceable> ();
</screen>
<para><emphasis role="bold">Warning:</emphasis> Arguments passed to a function declared without a
prototype are converted with the default argument promotions
(see <link linkend="Argument-Promotions">Argument Promotions</link>.  Likewise for additional arguments whose
types are unspecified.
</para>
<para>Function declarations are usually written at the top level in a source file,
but you can also put them inside code blocks.  Then the function name
is visible for the rest of the containing scope.  For example:
</para>
<screen>void
foo (char *file_name)
{
  void save_file (char *);
  save_file (file_name);
}
</screen>
<para>If another part of the code tries to call the function
<literal>save_file</literal>, this declaration won&#8217;t be in effect there.  So the
function will get an implicit declaration of the form <literal>extern int
save_file ();</literal>.   That conflicts with the explicit declaration
here, and the discrepancy generates a warning.
</para>
<para>The syntax of C traditionally allows omitting the data type in a
function declaration if it specifies a storage class or a qualifier.
Then the type defaults to <literal>int</literal>.  For example:
</para>
<screen>static foo (double x);
</screen>
<para>defaults the return type to <literal>int</literal>.
This is bad practice; if you see it, fix it.
</para>
<para>Calling a function that is undeclared has the effect of an creating
<firstterm>implicit</firstterm> declaration in the innermost containing scope,
equivalent to this:
</para>
<screen>extern int <firstterm>function</firstterm> ();
</screen>
<para>This declaration says that the function returns <literal>int</literal> but leaves
its argument types unspecified.  If that does not accurately fit the
function, then the program <emphasis role="bold">needs</emphasis> an explicit declaration of
the function with argument types in order to call it correctly.
</para>
<para>Implicit declarations are deprecated, and a function call that creates one
causes a warning.
</para>
</sect1>
<sect1 label="22.3" id="Function-Calls">
<title>Function Calls</title>
<indexterm role="cp"><primary>function calls</primary></indexterm>
<indexterm role="cp"><primary>calling functions</primary></indexterm>

<para>Starting a program automatically calls the function named <literal>main</literal>
(see <link linkend="The-main-Function">The main Function</link>).  Aside from that, a function does nothing
except when it is <firstterm>called</firstterm>.  That occurs during the execution of a
function-call expression specifying that function.
</para>
<para>A function-call expression looks like this:
</para>
<screen><replaceable>function</replaceable> (<replaceable>arguments</replaceable>&#8230;)
</screen>
<para>Most of the time, <replaceable>function</replaceable> is a function name.  However, it can
also be an expression with a function pointer value; that way, the
program can determine at run time which function to call.
</para>
<para>The <replaceable>arguments</replaceable> are a series of expressions separated by commas.
Each expression specifies one argument to pass to the function.
</para>
<para>The list of arguments in a function call looks just like use of the
comma operator (see <link linkend="Comma-Operator">Comma Operator</link>), but the fact that it fills
the parentheses of a function call gives it a different meaning.
</para>
<para>Here&#8217;s an example of a function call, taken from an example near the
beginning (see <link linkend="Complete-Program">Complete Program</link>).
</para>
<screen>printf (&quot;Fibonacci series item %d is %d\n&quot;,
        19, fib (19));
</screen>
<para>The three arguments given to <literal>printf</literal> are a constant string, the
integer 19, and the integer returned by <literal>fib (19)</literal>.
</para>
</sect1>
<sect1 label="22.4" id="Function-Call-Semantics">
<title>Function Call Semantics</title>
<indexterm role="cp"><primary>function call semantics</primary></indexterm>
<indexterm role="cp"><primary>semantics of function calls</primary></indexterm>
<indexterm role="cp"><primary>call-by-value</primary></indexterm>

<para>The meaning of a function call is to compute the specified argument
expressions, convert their values according to the function&#8217;s
declaration, then run the function giving it copies of the converted
values.  (This method of argument passing is known as
<firstterm>call-by-value</firstterm>.)  When the function finishes, the value it
returns becomes the value of the function-call expression.
</para>
<para>Call-by-value implies that an assignment to the function argument
variable has no direct effect on the caller.  For instance,
</para>
<screen>#include &lt;stdlib.h&gt;  /* Defines <literal>EXIT_SUCCESS</literal>. */
#include &lt;stdio.h&gt;   /* Declares <literal>printf</literal>. */

void
subroutine (int x)
{
  x = 5;
}

void
main (void)
{
  int y = 20;
  subroutine (y);
  printf (&quot;y is %d\n&quot;, y);
  return EXIT_SUCCESS;
}
</screen>
<para>prints &#8216;<literal>y is 20</literal>&#8217;.  Calling <literal>subroutine</literal> initializes <literal>x</literal>
from the value of <literal>y</literal>, but this does not establish any other
relationship between the two variables.  Thus, the assignment to
<literal>x</literal>, inside <literal>subroutine</literal>, changes only <emphasis>that</emphasis> <literal>x</literal>.
</para>
<para>If an argument&#8217;s type is specified by the function&#8217;s declaration, the
function call converts the argument expression to that type if
possible.  If the conversion is impossible, that is an error.
</para>
<para>If the function&#8217;s declaration doesn&#8217;t specify the type of that
argument, then the <emphasis>default argument promotions</emphasis> apply.
See <link linkend="Argument-Promotions">Argument Promotions</link>.
</para>
</sect1>
<sect1 label="22.5" id="Function-Pointers">
<title>Function Pointers</title>
<indexterm role="cp"><primary>function pointers</primary></indexterm>
<indexterm role="cp"><primary>pointers to functions</primary></indexterm>

<para>A function name refers to a fixed function.  Sometimes it is useful to
call a function to be determined at run time; to do this, you can use
a <firstterm>function pointer value</firstterm> that points to the chosen function
(see <link linkend="Pointers">Pointers</link>).
</para>
<para>Pointer-to-function types can be used to declare variables and other
data, including array elements, structure fields, and union
alternatives.  They can also be used for function arguments and return
values.  These types have the peculiarity that they are never
converted automatically to <literal>void *</literal> or vice versa.  However, you
can do that conversion with a cast.
</para>

<sect2 label="22.5.1" id="Declaring-Function-Pointers">
<title>Declaring Function Pointers</title>
<indexterm role="cp"><primary>declaring function pointers</primary></indexterm>
<indexterm role="cp"><primary>function pointers, declaring</primary></indexterm>

<para>The declaration of a function pointer variable (or structure field)
looks almost like a function declaration, except it has an additional
&#8216;<literal>*</literal>&#8217; just before the variable name.  Proper nesting requires a
pair of parentheses around the two of them.  For instance, <literal>int
(*a) ();</literal> says, &#8220;Declare <literal>a</literal> as a pointer such that <literal>*a</literal> is
an <literal>int</literal>-returning function.&#8221;
</para>
<para>Contrast these three declarations:
</para>
<screen>/* Declare a function returning <literal>char *</literal>.  */
char *a (char *);
/* Declare a pointer to a function returning <literal>char</literal>.  */
char (*a) (char *);
/* Declare a pointer to a function returning <literal>char *</literal>.  */
char *(*a) (char *);
</screen>
<para>The possible argument types of the function pointed to are the same
as in a function declaration.  You can write a prototype
that specifies all the argument types:
</para>
<screen><replaceable>rettype</replaceable> (*<replaceable>function</replaceable>) (<replaceable>arguments</replaceable>&#8230;);
</screen>
<para>or one that specifies some and leaves the rest unspecified:
</para>
<screen><replaceable>rettype</replaceable> (*<replaceable>function</replaceable>) (<replaceable>arguments</replaceable>&#8230;, ...);
</screen>
<para>or one that says there are no arguments:
</para>
<screen><replaceable>rettype</replaceable> (*<replaceable>function</replaceable>) (void);
</screen>
<para>You can also write a non-prototype declaration that says
nothing about the argument types:
</para>
<screen><replaceable>rettype</replaceable> (*<replaceable>function</replaceable>) ();
</screen>
<para>For example, here&#8217;s a declaration for a variable that should
point to some arithmetic function that operates on two <literal>double</literal>s:
</para>
<screen>double (*binary_op) (double, double);
</screen>
<para>Structure fields, union alternatives, and array elements can be
function pointers; so can parameter variables.  The function pointer
declaration construct can also be combined with other operators
allowed in declarations.  For instance,
</para>
<screen>int **(*foo)();
</screen>
<para>declares <literal>foo</literal> as a pointer to a function that returns
type <literal>int **</literal>, and
</para>
<screen>int **(*foo[30])();
</screen>
<para>declares <literal>foo</literal> as an array of 30 pointers to functions that
return type <literal>int **</literal>.
</para>
<screen>int **(**foo)();
</screen>
<para>declares <literal>foo</literal> as a pointer to a pointer to a function that
returns type <literal>int **</literal>.
</para>
</sect2>
<sect2 label="22.5.2" id="Assigning-Function-Pointers">
<title>Assigning Function Pointers</title>
<indexterm role="cp"><primary>assigning function pointers</primary></indexterm>
<indexterm role="cp"><primary>function pointers, assigning</primary></indexterm>

<para>Assuming we have declared the variable <literal>binary_op</literal> as in the
previous section, giving it a value requires a suitable function to
use.  So let&#8217;s define a function suitable for the variable to point
to.  Here&#8217;s one:
</para>
<screen>double
double_add (double a, double b)
{
  return a+b;
}
</screen>
<para>Now we can give it a value:
</para>
<screen>binary_op = double_add;
</screen>
<para>The target type of the function pointer must be upward compatible with
the type of the function (see <link linkend="Compatible-Types">Compatible Types</link>).
</para>
<para>There is no need for &#8216;<literal>&amp;</literal>&#8217; in front of <literal>double_add</literal>.
Using a function name such as <literal>double_add</literal> as an expression
automatically converts it to the function&#8217;s address, with the
appropriate function pointer type.  However, it is ok to use
&#8216;<literal>&amp;</literal>&#8217; if you feel that is clearer:
</para>
<screen>binary_op = &amp;double_add;
</screen>
</sect2>
<sect2 label="22.5.3" id="Calling-Function-Pointers">
<title>Calling Function Pointers</title>
<indexterm role="cp"><primary>calling function pointers</primary></indexterm>
<indexterm role="cp"><primary>function pointers, calling</primary></indexterm>

<para>To call the function specified by a function pointer, just write the
function pointer value in a function call.  For instance, here&#8217;s a
call to the function <literal>binary_op</literal> points to:
</para>
<screen>binary_op (x, 5)
</screen>
<para>Since the data type of <literal>binary_op</literal> explicitly specifies type
<literal>double</literal> for the arguments, the call converts <literal>x</literal> and 5 to
<literal>double</literal>.
</para>
<para>The call conceptually dereferences the pointer <literal>binary_op</literal> to
&#8220;get&#8221; the function it points to, and calls that function.  If you
wish, you can explicitly represent the derefence by writing the
<literal>*</literal> operator:
</para>
<screen>(*binary_op) (x, 5)
</screen>
<para>The &#8216;<literal>*</literal>&#8217; reminds people reading the code that <literal>binary_op</literal> is
a function pointer rather than the name of a specific function.
</para>
</sect2>
</sect1>
<sect1 label="22.6" id="The-main-Function">
<title>The <literal>main</literal> Function</title>
<indexterm role="cp"><primary><literal>main</literal> function</primary></indexterm>
<indexterm role="fn"><primary>main</primary></indexterm>

<para>Every complete executable program requires at least one function,
called <literal>main</literal>, which is where execution begins.  You do not have
to explicitly declare <literal>main</literal>, though GNU C permits you to do so.
Conventionally, <literal>main</literal> should be defined to follow one of these
calling conventions:
</para>
<screen>int main (void) {&#8230;}
int main (int argc, char *argv[]) {&#8230;}
int main (int argc, char *argv[], char *envp[]) {&#8230;}
</screen>
<para>Using <literal>void</literal> as the parameter list means that <literal>main</literal> does
not use the arguments.  You can write <literal>char **argv</literal> instead of
<literal>char *argv[]</literal>, and likewise for <literal>envp</literal>, as the two
constructs are equivalent.
</para>

<para>You can call <literal>main</literal> from C code, as you can call any other
function, though that is an unusual thing to do.  When you do that,
you must write the call to pass arguments that match the parameters in
the definition of <literal>main</literal>.
</para>
<para>The <literal>main</literal> function is not actually the first code that runs when
a program starts.  In fact, the first code that runs is system code
from the file <filename>crt0.o</filename>.  In Unix, this was hand-written assembler
code, but in GNU we replaced it with C code.  Its job is to find
the arguments for <literal>main</literal> and call that.
</para>

<sect2 label="22.6.1" id="Values-from-main">
<title>Returning Values from <literal>main</literal></title>
<indexterm role="cp"><primary>returning values from <literal>main</literal></primary></indexterm>
<indexterm role="cp"><primary>success</primary></indexterm>
<indexterm role="cp"><primary>failure</primary></indexterm>
<indexterm role="cp"><primary>exit status</primary></indexterm>

<para>When <literal>main</literal> returns, the process terminates.  Whatever value
<literal>main</literal> returns becomes the exit status which is reported to the
parent process.  While nominally the return value is of type
<literal>int</literal>, in fact the exit status gets truncated to eight bits; if
<literal>main</literal> returns the value 256, the exit status is 0.
</para>
<para>Normally, programs return only one of two values: 0 for success,
and 1 for failure. For maximum portability, use the macro
values <literal>EXIT_SUCCESS</literal> and <literal>EXIT_FAILURE</literal> defined in
<literal>stdlib.h</literal>.  Here&#8217;s an example:
</para>
<indexterm role="cp"><primary><literal>EXIT_FAILURE</literal></primary></indexterm>
<indexterm role="cp"><primary><literal>EXIT_SUCCESS</literal></primary></indexterm>
<screen>#include &lt;stdlib.h&gt;  /* Defines <literal>EXIT_SUCCESS</literal> */
                     /* and <literal>EXIT_FAILURE</literal>. */

int
main (void)
{
  &#8230;
  if (foo)
    return EXIT_SUCCESS;
  else
    return EXIT_FAILURE;
}
</screen>
<para>Some types of programs maintain special conventions for various return
values; for example, comparison programs including <literal>cmp</literal> and
<literal>diff</literal> return 1 to indicate a mismatch, and 2 to indicate that
the comparison couldn&#8217;t be performed.
</para>
</sect2>
<sect2 label="22.6.2" id="Command_002dline-Parameters">
<title>Accessing Command-line Parameters</title>
<indexterm role="cp"><primary>command-line parameters</primary></indexterm>
<indexterm role="cp"><primary>parameters, command-line</primary></indexterm>

<para>If the program was invoked with any command-line arguments, it can
access them through the arguments of <literal>main</literal>, <literal>argc</literal> and
<literal>argv</literal>.  (You can give these arguments any names, but the names
<literal>argc</literal> and <literal>argv</literal> are customary.)
</para>
<para>The value of <literal>argv</literal> is an array containing all of the
command-line arguments as strings, with the name of the command
invoked as the first string.  <literal>argc</literal> is an integer that says how
many strings <literal>argv</literal> contains.  Here is an example of accessing
the command-line parameters, retrieving the program&#8217;s name and
checking for the standard <option>--version</option> and <option>--help</option> options:
</para>
<screen>#include &lt;string.h&gt; /* Declare <literal>strcmp</literal>. */

int
main (int argc, char *argv[])
{
  char *program_name = argv[0];

  for (int i = 1; i &lt; argc; i++)
    {
      if (!strcmp (argv[i], &quot;--version&quot;))
        {
          /* Print version information and exit. */
          &#8230;
        }
      else if (!strcmp (argv[i], &quot;--help&quot;))
        {
          /* Print help information and exit. */
          &#8230;
        }
    }
  &#8230;
}
</screen>
</sect2>
<sect2 label="22.6.3" id="Environment-Variables">
<title>Accessing Environment Variables</title>
<indexterm role="cp"><primary>environment variables</primary></indexterm>

<para>You can optionally include a third parameter to <literal>main</literal>, another
array of strings, to capture the environment variables available to
the program.  Unlike what happens with <literal>argv</literal>, there is no
additional parameter for the count of environment variables; rather,
the array of environment variables concludes with a null pointer.
</para>
<screen>#include &lt;stdio.h&gt;   /* Declares <literal>printf</literal>. */

int
main (int argc, char *argv[], char *envp[])
{
  /* Print out all environment variables. */
  int i = 0;
  while (envp[i])
    {
      printf (&quot;%s\n&quot;, envp[i]);
      i++;
    }
}
</screen>
<para>Another method of retrieving environment variables is to use the
library function <literal>getenv</literal>, which is defined in <literal>stdlib.h</literal>.
Using <literal>getenv</literal> does not require defining <literal>main</literal> to accept the
<literal>envp</literal> pointer.  For example, here is a program that fetches and prints
the user&#8217;s home directory (if defined):
</para>
<screen>#include &lt;stdlib.h&gt;  /* Declares <literal>getenv</literal>. */
#include &lt;stdio.h&gt;   /* Declares <literal>printf</literal>. */

int
main (void)
{
  char *home_directory = getenv (&quot;HOME&quot;);
  if (home_directory)
    printf (&quot;My home directory is: %s\n&quot;, home_directory);
  else
    printf (&quot;My home directory is not defined!\n&quot;);
}
</screen>
</sect2>
</sect1>
<sect1 label="22.7" id="Advanced-Definitions">
<title>Advanced Function Features</title>

<para>This section describes some advanced or obscure features for GNU C
function definitions.  If you are just learning C, you can skip the
rest of this chapter.
</para>

<sect2 label="22.7.1" id="Variable_002dLength-Array-Parameters">
<title>Variable-Length Array Parameters</title>
<indexterm role="cp"><primary>variable-length array parameters</primary></indexterm>
<indexterm role="cp"><primary>array parameters, variable-length</primary></indexterm>
<indexterm role="cp"><primary>functions that accept variable-length arrays</primary></indexterm>

<para>An array parameter can have variable length: simply declare the array
type with a size that isn&#8217;t constant.  In a nested function, the
length can refer to a variable defined in a containing scope.  In any
function, it can refer to a previous parameter, like this:
</para>
<screen>struct entry
tester (int len, char data[len][len])
{
  &#8230;
}
</screen>
<para>Alternatively, in function declarations (but not in function
definitions), you can use <literal>[*]</literal> to denote that the array
parameter is of a variable length, such that these two declarations
mean the same thing:
</para>
<screen>struct entry
tester (int len, char data[len][len]);
</screen>
<screen>struct entry
tester (int len, char data[*][*]);
</screen>
<para>The two forms of input are equivalent in GNU C, but emphasizing that
the array parameter is variable-length may be helpful to those
studying the code.
</para>
<para>You can also omit the length parameter, and instead use some other
in-scope variable for the length in the function definition:
</para>
<screen>struct entry
tester (char data[*][*]);
&#8230;
int dataLength = 20;
&#8230;
struct entry
tester (char data[dataLength][dataLength])
{
  &#8230;
}
</screen>
<!-- ??? check text above -->

<indexterm role="cp"><primary>parameter forward declaration</primary></indexterm>
<para>In GNU C, to pass the array first and the length afterward, you can
use a <firstterm>parameter forward declaration</firstterm>, like this:
</para>
<screen>struct entry
tester (int len; char data[len][len], int len)
{
  &#8230;
}
</screen>
<para>The &#8216;<literal>int len</literal>&#8217; before the semicolon is the parameter forward
declaration; it serves the purpose of making the name <literal>len</literal> known
when the declaration of <literal>data</literal> is parsed.
</para>
<para>You can write any number of such parameter forward declarations in the
parameter list.  They can be separated by commas or semicolons, but
the last one must end with a semicolon, which is followed by the
&#8220;real&#8221; parameter declarations.  Each forward declaration must match
a subsequent &#8220;real&#8221; declaration in parameter name and data type.
</para>
<para>Standard C does not support parameter forward declarations.
</para>
</sect2>
<sect2 label="22.7.2" id="Variable-Number-of-Arguments">
<title>Variable-Length Parameter Lists</title>
<indexterm role="cp"><primary>variable-length parameter lists</primary></indexterm>
<indexterm role="cp"><primary>parameters lists, variable length</primary></indexterm>
<indexterm role="cp"><primary>function parameter lists, variable length</primary></indexterm>

<indexterm role="cp"><primary>variadic function</primary></indexterm>
<para>A function that takes a variable number of arguments is called a
<firstterm>variadic function</firstterm>.  In C, a variadic function must specify at
least one fixed argument with an explicitly declared data type.
Additional arguments can follow, and can vary in both quantity and
data type.
</para>
<para>In the function header, declare the fixed parameters in the normal
way, then write a comma and an ellipsis: &#8216;<literal>, ...</literal>&#8217;.  Here is an
example of a variadic function header:
</para>
<screen>int add_multiple_values (int number, ...)
</screen>
<indexterm role="cp"><primary><literal>va_list</literal></primary></indexterm>
<indexterm role="cp"><primary><literal>va_start</literal></primary></indexterm>
<indexterm role="cp"><primary><literal>va_end</literal></primary></indexterm>
<para>The function body can refer to fixed arguments by their parameter
names, but the additional arguments have no names.  Accessing them in
the function body uses certain standard macros.  They are defined in
the library header file <filename>stdarg.h</filename>, so the code must
<literal>#include</literal> that file.
</para>
<para>In the body, write
</para>
<screen>va_list ap;
va_start (ap, <replaceable>last_fixed_parameter</replaceable>);
</screen>
<para>This declares the variable <literal>ap</literal> (you can use any name for it)
and then sets it up to point before the first additional argument.
</para>
<para>Then, to fetch the next consecutive additional argument, write this:
</para>
<screen>va_arg (ap, <replaceable>type</replaceable>)
</screen>
<para>After fetching all the additional arguments (or as many as need to be
used), write this:
</para>
<screen>va_end (ap);
</screen>
<para>Here&#8217;s an example of a variadic function definition that adds any
number of <literal>int</literal> arguments.  The first (fixed) argument says how
many more arguments follow.
</para>
<screen>#include &lt;stdarg.h&gt; /* Defines <literal>va</literal>&#8230; macros. */
&#8230;

int
add_multiple_values (int argcount, ...)
{
  int counter, total = 0;

  /* Declare a variable of type <literal>va_list</literal>. */
  va_list argptr;

  /* Initialize that variable.. */
  va_start (argptr, argcount);

  for (counter = 0; counter &lt; argcount; counter++)
    {
      /* Get the next additional argument. */
      total += va_arg (argptr, int);
    }

  /* End use of the <literal>argptr</literal> variable. */
  va_end (argptr);

  return total;
}
</screen>
<para>With GNU C, <literal>va_end</literal> is superfluous, but some other compilers
might make <literal>va_start</literal> allocate memory so that calling
<literal>va_end</literal> is necessary to avoid a memory leak.  Before doing
<literal>va_start</literal> again with the same variable, do <literal>va_end</literal>
first.
</para>
<indexterm role="cp"><primary><literal>va_copy</literal></primary></indexterm>
<para>Because of this possible memory allocation, it is risky (in principle)
to copy one <literal>va_list</literal> variable to another with assignment.
Instead, use <literal>va_copy</literal>, which copies the substance but allocates
separate memory in the variable you copy to.  The call looks like
<literal>va_copy (<replaceable>to</replaceable>, <replaceable>from</replaceable>)</literal>, where both <replaceable>to</replaceable> and
<replaceable>from</replaceable> should be variables of type <literal>va_list</literal>.  In principle,
do <literal>va_end</literal> on each of these variables before its scope ends.
</para>
<para>Since the additional arguments&#8217; types are not specified in the
function&#8217;s definition, the default argument promotions
(see <link linkend="Argument-Promotions">Argument Promotions</link>) apply to them in function calls.  The
function definition must take account of this; thus, if an argument
was passed as <literal>short</literal>, the function should get it as <literal>int</literal>.
If an argument was passed as <literal>float</literal>, the function should get it
as <literal>double</literal>.
</para>
<para>C has no mechanism to tell the variadic function how many arguments
were passed to it, so its calling convention must give it a way to
determine this.  That&#8217;s why <literal>add_multiple_values</literal> takes a fixed
argument that says how many more arguments follow.  Thus, you can
call the function like this:
</para>
<screen>sum = add_multiple_values (3, 12, 34, 190);
/* Value is 12+34+190. */
</screen>
<para>In GNU C, there is no actual need to use the <literal>va_end</literal> function.
In fact, it does nothing.  It&#8217;s used for compatibility with other
compilers, when that matters.
</para>
<para>It is a mistake to access variables declared as <literal>va_list</literal> except
in the specific ways described here.  Just what that type consists of
is an implementation detail, which could vary from one platform to
another.
</para>
</sect2>
<sect2 label="22.7.3" id="Nested-Functions">
<title>Nested Functions</title>
<indexterm role="cp"><primary>nested functions</primary></indexterm>
<indexterm role="cp"><primary>functions, nested</primary></indexterm>
<indexterm role="cp"><primary>downward funargs</primary></indexterm>
<indexterm role="cp"><primary>thunks</primary></indexterm>

<para>A <firstterm>nested function</firstterm> is a function defined inside another function.
The nested function&#8217;s name is local to the block where it is defined.
For example, here we define a nested function named <literal>square</literal>, and
call it twice:
</para>
<screen>foo (double a, double b)
{
  double square (double z) { return z * z; }

  return square (a) + square (b);
}
</screen>
<para>The nested function can access all the variables of the containing
function that are visible at the point of its definition.  This is
called <firstterm>lexical scoping</firstterm>.  For example, here we show a nested
function that uses an inherited variable named <literal>offset</literal>:
</para>
<screen>bar (int *array, int offset, int size)
{
  int access (int *array, int index)
    { return array[index + offset]; }
  int i;
  &#8230;
  for (i = 0; i &lt; size; i++)
    &#8230; access (array, i) &#8230;
}
</screen>
<para>Nested function definitions can appear wherever automatic variable
declarations are allowed; that is, in any block, interspersed with the
other declarations and statements in the block.
</para>
<para>The nested function&#8217;s name is visible only within the parent block;
the name&#8217;s scope starts from its definition and continues to the end
of the containing block.  If the nested function&#8217;s name
is the same as the parent function&#8217;s name, there wil be
no way to refer to the parent function inside the scope of the
name of the nested function.
</para>
<para>Using <literal>extern</literal> or <literal>static</literal> on a nested function definition
is an error.
</para>
<para>It is possible to call the nested function from outside the scope of its
name by storing its address or passing the address to another function.
You can do this safely, but you must be careful:
</para>
<screen>hack (int *array, int size, int addition)
{
  void store (int index, int value)
    { array[index] = value + addition; }

  intermediate (store, size);
}
</screen>
<para>Here, the function <literal>intermediate</literal> receives the address of
<literal>store</literal> as an argument.  If <literal>intermediate</literal> calls <literal>store</literal>,
the arguments given to <literal>store</literal> are used to store into <literal>array</literal>.
<literal>store</literal> also accesses <literal>hack</literal>&#8217;s local variable <literal>addition</literal>.
</para>
<para>It is safe for <literal>intermediate</literal> to call <literal>store</literal> because
<literal>hack</literal>&#8217;s stack frame, with its arguments and local variables,
continues to exist during the call to <literal>intermediate</literal>.
</para>
<para>Calling the nested function through its address after the containing
function has exited is asking for trouble.  If it is called after a
containing scope level has exited, and if it refers to some of the
variables that are no longer in scope, it will refer to memory
containing junk or other data.  It&#8217;s not wise to take the risk.
</para>
<para>The GNU C Compiler implements taking the address of a nested function
using a technique called <firstterm>trampolines</firstterm>.  This technique was
described in <citetitle>Lexical Closures for C<literal>++</literal></citetitle> (Thomas M. Breuel,
USENIX C<literal>++</literal> Conference Proceedings, October 17&#8211;21, 1988).
</para>
<para>A nested function can jump to a label inherited from a containing
function, provided the label was explicitly declared in the containing
function (see <link linkend="Local-Labels">Local Labels</link>).  Such a jump returns instantly to the
containing function, exiting the nested function that did the
<literal>goto</literal> and any intermediate function invocations as well.  Here
is an example:
</para>
<screen>bar (int *array, int offset, int size)
{
  /* Explicitly declare the label <literal>failure</literal>. */
  __label__ failure;
  int access (int *array, int index)
    {
      if (index &gt; size)
        /* Exit this function,
           and return to <literal>bar</literal>. */
        goto failure;
      return array[index + offset];
    }
</screen><screen>
</screen><screen>  int i;
  &#8230;
  for (i = 0; i &lt; size; i++)
    &#8230; access (array, i) &#8230;
  &#8230;
  return 0;

 /* Control comes here from <literal>access</literal>
    if it does the <literal>goto</literal>.  */
 failure:
  return -1;
}
</screen>
<para>To declare the nested function before its definition, use
<literal>auto</literal> (which is otherwise meaningless for function declarations;
see <link linkend="auto-and-register">auto and register</link>).  For example,
</para>
<screen>bar (int *array, int offset, int size)
{
  auto int access (int *, int);
  &#8230;
  &#8230; access (array, i) &#8230;
  &#8230;
  int access (int *array, int index)
    {
      &#8230;
    }
  &#8230;
}
</screen>
</sect2>
<sect2 label="22.7.4" id="Inline-Function-Definitions">
<title>Inline Function Definitions</title>
<indexterm role="cp"><primary>inline function definitions</primary></indexterm>
<indexterm role="cp"><primary>function definitions, inline</primary></indexterm>
<indexterm role="fn"><primary>inline</primary></indexterm>

<para>To declare a function inline, use the <literal>inline</literal> keyword in its
definition.  Here&#8217;s a simple function that takes a pointer-to-<literal>int</literal>
and increments the integer stored there&#8212;declared inline.
</para>
<screen>struct list
{
  struct list *first, *second;
};

inline struct list *
list_first (struct list *p)
{
  return p-&gt;first;  
}

inline struct list *
list_second (struct list *p)
{
  return p-&gt;second;  
}
</screen>
<para>optimized compilation can substitute the inline function&#8217;s body for
any call to it.  This is called <emphasis>inlining</emphasis> the function.  It
makes the code that contains the call run faster, significantly so if
the inline function is small.
</para>
<para>Here&#8217;s a function that uses <literal>pair_second</literal>:
</para>
<screen>int
pairlist_length (struct list *l)
{
  int length = 0;
  while (l)
    {
      length++;
      l = pair_second (l);
    }
  return length;
}
</screen>
<para>Substituting the code of <literal>pair_second</literal> into the definition of
<literal>pairlist_length</literal> results in this code, in effect:
</para>
<screen>int
pairlist_length (struct list *l)
{
  int length = 0;
  while (l)
    {
      length++;
      l = l-&gt;second;
    }
  return length;
}
</screen>
<para>Since the definition of <literal>pair_second</literal> does not say <literal>extern</literal>
or <literal>static</literal>, that definition is used only for inlining.  It
doesn&#8217;t generate code that can be called at run time.  If not all the
calls to the function are inlined, there must be a definition of the
same function name in another module for them to call.
</para>
<indexterm role="cp"><primary>inline functions, omission of</primary></indexterm>
<!-- @opindex fkeep-inline-functions -->
<para>Adding <literal>static</literal> to an inline function definition means the
function definition is limited to this compilation module.  Also, it
generates run-time code if necessary for the sake of any calls that
were not inlined.  If all calls are inlined then the function
definition does not generate run-time code, but you can force
generation of run-time code with the option
<option>-fkeep-inline-functions</option>.
</para>
<indexterm role="cp"><primary>extern inline function</primary></indexterm>
<para>Specifying <literal>extern</literal> along with <literal>inline</literal> means the function is
external and generates run-time code to be called from other
separately compiled modules, as well as inlined.  You can define the
function as <literal>inline</literal> without <literal>extern</literal> in other modules so as
to inline calls to the same function in those modules.
</para>
<para>Why are some calls not inlined?  First of all, inlining is an
optimization, so non-optimized compilation does not inline.
</para>
<para>Some calls cannot be inlined for technical reasons.  Also, certain
usages in a function definition can make it unsuitable for inline
substitution.  Among these usages are: variadic functions, use of
<literal>alloca</literal>, use of computed goto (see <link linkend="Labels-as-Values">Labels as Values</link>), and
use of nonlocal goto.  The option <option>-Winline</option> requests a warning
when a function marked <literal>inline</literal> is unsuitable to be inlined.  The
warning explains what obstacle makes it unsuitable.
</para>
<para>Just because a call <emphasis>can</emphasis> be inlined does not mean it
<emphasis>should</emphasis> be inlined.  The GNU C compiler weighs costs and
benefits to decide whether inlining a particular call is advantageous.
</para>
<para>You can force inlining of all calls to a given function that can be
inlined, even in a non-optimized compilation. by specifying the
&#8216;<literal>always_inline</literal>&#8217; attribute for the function, like this:
</para>
<screen>/* Prototype.  */
inline void foo (const char) __attribute__((always_inline));
</screen>
<para>This is a GNU C extension.  See <link linkend="Attributes">Attributes</link>.
</para>
<para>A function call may be inlined even if not declared <literal>inline</literal> in
special cases where the compiler can determine this is correct and
desirable.  For instance, when a static function is called only once,
it will very likely be inlined.  With <option>-flto</option>, link-time
optimization, any function might be inlined.  To absolutely prevent
inlining of a specific function, specify
<literal>__attribute__((__noinline__))</literal> in the function&#8217;s definition.
</para>
</sect2>
</sect1>
<sect1 label="22.8" id="Obsolete-Definitions">
<title>Obsolete Function Features</title>

<para>These features of function definitions are still used in old
programs, but you shouldn&#8217;t write code this way today.
If you are just learning C, you can skip this section.
</para>

<sect2 label="22.8.1" id="Old-GNU-Inlining">
<title>Older GNU C Inlining</title>

<para>The GNU C spec for inline functions, before GCC version 5, defined
<literal>extern inline</literal> on a function definition to mean to inline calls
to it but <emphasis>not</emphasis> generate code for the function that could be
called at run time.  By contrast, <literal>inline</literal> without <literal>extern</literal>
specified to generate run-time code for the function.  In effect, ISO
incompatibly flipped the meanings of these two cases.  We changed GCC
in version 5 to adopt the ISO specification.
</para>
<para>Many programs still use these cases with the previous GNU C meanings.
You can specify use of those meanings with the option
<option>-fgnu89-inline</option>.  You can also specify this for a single
function with <literal>__attribute__ ((gnu_inline))</literal>.  Here&#8217;s an example:
</para>
<screen>inline __attribute__ ((gnu_inline))
int
inc (int *a)
{
  (*a)++;
}
</screen>
</sect2>
<sect2 label="22.8.2" id="Old_002dStyle-Function-Definitions">
<title>Old-Style Function Definitions</title>
<indexterm role="cp"><primary>old-style function definitions</primary></indexterm>
<indexterm role="cp"><primary>function definitions, old-style</primary></indexterm>
<indexterm role="cp"><primary>K&amp;R-style function definitions</primary></indexterm>

<para>The syntax of C traditionally allows omitting the data type in a
function declaration if it specifies a storage class or a qualifier.
Then the type defaults to <literal>int</literal>.  For example:
</para>
<screen>static foo (double x);
</screen>
<para>defaults the return type to <literal>int</literal>.  This is bad practice; if you
see it, fix it.
</para>
<para>An <firstterm>old-style</firstterm> (or &#8220;K&amp;R&#8221;) function definition is the way
function definitions were written in the 1980s.  It looks like this:
</para>
<screen><replaceable>rettype</replaceable>
<replaceable>function</replaceable> (<replaceable>parmnames</replaceable>)
  <replaceable>parm_declarations</replaceable>
{
  <replaceable>body</replaceable>
}
</screen>
<para>In <replaceable>parmnames</replaceable>, only the parameter names are listed, separated by
commas.  Then <replaceable>parm_declarations</replaceable> declares their data types; these
declarations look just like variable declarations.  If a parameter is
listed in <replaceable>parmnames</replaceable> but has no declaration, it is implicitly
declared <literal>int</literal>.
</para>
<para>There is no reason to write a definition this way nowadays, but they
can still be seen in older GNU programs.
</para>
<para>An old-style variadic function definition looks like this:
</para>
<screen>#include &lt;varargs.h&gt;

int
add_multiple_values (va_alist)
    va_dcl
{
  int argcount;
  int counter, total = 0;

  /* Declare a variable of type <literal>va_list</literal>. */
  va_list argptr;

  /* Initialize that variable. */
  va_start (argptr);

  /* Get the first argument (fixed). */
  argcount = va_arg (int);

  for (counter = 0; counter &lt; argcount; counter++)
    {
      /* Get the next additional argument. */
      total += va_arg (argptr, int);
    }

  /* End use of the <literal>argptr</literal> variable. */
  va_end (argptr);

  return total;
}
</screen>
<para>Note that the old-style variadic function definition has no fixed
parameter variables; all arguments must be obtained with
<literal>va_arg</literal>.
</para>
</sect2>
</sect1>
</chapter>
<chapter label="23" id="Compatible-Types">
<title>Compatible Types</title>
<indexterm role="cp"><primary>compatible types</primary></indexterm>
<indexterm role="cp"><primary>types, compatible</primary></indexterm>

<para>Declaring a function or variable twice is valid in C only if the two
declarations specify <firstterm>compatible</firstterm> types.  In addition, some
operations on pointers require operands to have compatible target
types.
</para>
<para>In C, two different primitive types are never compatible.  Likewise for
the defined types <literal>struct</literal>, <literal>union</literal> and <literal>enum</literal>: two
separately defined types are incompatible unless they are defined
exactly the same way.
</para>
<para>However, there are a few cases where different types can be
compatible:
</para>
<itemizedlist><listitem><para>Every enumeration type is compatible with some integer type.  In GNU
C, the choice of integer type depends on the largest enumeration
value.
</para>
<!-- ??? Which one, in GCC? -->
<!-- ??? ... it varies, depending on the enum values. Testing on -->
<!-- ??? fencepost, it appears to use a 4-byte signed integer first, -->
<!-- ??? then moves on to an 8-byte signed integer. These details -->
<!-- ??? might be platform-dependent, as the C standard says that even -->
<!-- ??? char could be used as an enum type, but it's at least true -->
<!-- ??? that GCC chooses a type that is at least large enough to -->
<!-- ??? hold the largest enum value. -->

</listitem><listitem><para>Array types are compatible if the element types are compatible
and the sizes (when specified) match.
</para>
</listitem><listitem><para>Pointer types are compatible if the pointer target types are
compatible.
</para>
</listitem><listitem><para>Function types that specify argument types are compatible if the
return types are compatible and the argument types are compatible,
argument by argument.  In addition, they must all agree in whether
they use <literal>...</literal> to allow additional arguments.
</para>
</listitem><listitem><para>Function types that don&#8217;t specify argument types are compatible if the
return types are.
</para>
</listitem><listitem><para>Function types that specify the argument types are compatible with
function types that omit them, if the return types are compatible and
the specified argument types are unaltered by the argument promotions
(see <link linkend="Argument-Promotions">Argument Promotions</link>).
</para></listitem></itemizedlist>
<para>In order for types to be compatible, they must agree in their type
qualifiers.  Thus, <literal>const int</literal> and <literal>int</literal> are incompatible.
It follows that <literal>const int *</literal> and <literal>int *</literal> are incompatible
too (they are pointers to types that are not compatible).
</para>
<para>If two types are compatible ignoring the qualifiers, we call them
<firstterm>nearly compatible</firstterm>.  (If they are array types, we ignore
qualifiers on the element types.<footnote><para>This is a GNU C extension.</para></footnote>)
Comparison of pointers is valid if the pointers&#8217; target types are
nearly compatible.  Likewise, the two branches of a conditional
expression may be pointers to nearly compatible target types.
</para>
<para>If two types are compatible ignoring the qualifiers, and the first
type has all the qualifiers of the second type, we say the first is
<firstterm>upward compatible</firstterm> with the second.  Assignment of pointers
requires the assigned pointer&#8217;s target type to be upward compatible
with the right operand (the new value)&#8217;s target type.
</para>
</chapter>
<chapter label="24" id="Type-Conversions">
<title>Type Conversions</title>
<indexterm role="cp"><primary>type conversions</primary></indexterm>
<indexterm role="cp"><primary>conversions, type</primary></indexterm>

<para>C converts between data types automatically when that seems clearly
necessary.  In addition, you can convert explicitly with a <firstterm>cast</firstterm>.
</para>

<sect1 label="24.1" id="Explicit-Type-Conversion">
<title>Explicit Type Conversion</title>
<indexterm role="cp"><primary>cast</primary></indexterm>
<indexterm role="cp"><primary>explicit type conversion</primary></indexterm>

<para>You can do explicit conversions using the unary <firstterm>cast</firstterm> operator,
which is written as a type designator (see <link linkend="Type-Designators">Type Designators</link>) in
parentheses.  For example, <literal>(int)</literal> is the operator to cast to
type <literal>int</literal>.  Here&#8217;s an example of using it:
</para>
<screen>{
  double d = 5.5;

  printf (&quot;Floating point value: %f\n&quot;, d);
  printf (&quot;Rounded to integer: %d\n&quot;, (int) d);
}
</screen>
<para>Using <literal>(int) d</literal> passes an <literal>int</literal> value as argument to
<literal>printf</literal>, so you can print it with &#8216;<literal>%d</literal>&#8217;.  Using just
<literal>d</literal> without the cast would pass the value as <literal>double</literal>.
That won&#8217;t work at all with &#8216;<literal>%d</literal>&#8217;; the results would be gibberish.
</para>
<para>To divide one integer by another without rounding,
cast either of the integers to <literal>double</literal> first:
</para>
<screen>(double) <replaceable>dividend</replaceable> / <replaceable>divisor</replaceable>
<replaceable>dividend</replaceable> / (double) <replaceable>divisor</replaceable>
</screen>
<para>It is enough to cast one of them, because that forces the common type
to <literal>double</literal> so the other will be converted automatically.
</para>
<para>The valid cast conversions are:
</para>
<itemizedlist><listitem><para>One numerical type to another.
</para>
</listitem><listitem><para>One pointer type to another.
(Converting between pointers that point to functions
and pointers that point to data is not standard C.)
</para>
</listitem><listitem><para>A pointer type to an integer type.
</para>
</listitem><listitem><para>An integer type to a pointer type.
</para>
</listitem><listitem><para>To a union type, from the type of any alternative in the union
(see <link linkend="Unions">Unions</link>).  (This is a GNU extension.)
</para>
</listitem><listitem><para>Anything, to <literal>void</literal>.
</para></listitem></itemizedlist>
</sect1>
<sect1 label="24.2" id="Assignment-Type-Conversions">
<title>Assignment Type Conversions</title>
<indexterm role="cp"><primary>assignment type conversions</primary></indexterm>

<para>Certain type conversions occur automatically in assignments
and certain other contexts.  These are the conversions
assignments can do:
</para>
<itemizedlist><listitem><para>Converting any numeric type to any other numeric type.
</para>
</listitem><listitem><para>Converting <literal>void *</literal> to any other pointer type
(except pointer-to-function types).
</para>
</listitem><listitem><para>Converting any other pointer type to <literal>void *</literal>.
(except pointer-to-function types).
</para>
</listitem><listitem><para>Converting 0 (a null pointer constant) to any pointer type.
</para>
</listitem><listitem><para>Converting any pointer type to <literal>bool</literal>.  (The result is
1 if the pointer is not null.)
</para>
</listitem><listitem><para>Converting between pointer types when the left-hand target type is
upward compatible with the right-hand target type.  See <link linkend="Compatible-Types">Compatible
Types</link>.
</para></listitem></itemizedlist>
<para>These type conversions occur automatically in certain contexts,
which are:
</para>
<itemizedlist><listitem><para>An assignment converts the type of the right-hand expression
to the type wanted by the left-hand expression.  For example,
</para>
<screen>double i;
i = 5;
</screen>
<para>converts 5 to <literal>double</literal>.
</para>
</listitem><listitem><para>A function call, when the function specifies the type for that
argument, converts the argument value to that type.  For example,
</para>
<screen>void foo (double);
foo (5);
</screen>
<para>converts 5 to <literal>double</literal>.
</para>
</listitem><listitem><para>A <literal>return</literal> statement converts the specified value to the type
that the function is declared to return.  For example,
</para>
<screen>double
foo ()
{
  return 5;
}
</screen>
<para>also converts 5 to <literal>double</literal>.
</para></listitem></itemizedlist>
<para>In all three contexts, if the conversion is impossible, that
constitutes an error.
</para>
</sect1>
<sect1 label="24.3" id="Argument-Promotions">
<title>Argument Promotions</title>
<indexterm role="cp"><primary>argument promotions</primary></indexterm>
<indexterm role="cp"><primary>promotion of arguments</primary></indexterm>

<para>When a function&#8217;s definition or declaration does not specify the type
of an argument, that argument is passed without conversion in whatever
type it has, with these exceptions:
</para>
<itemizedlist><listitem><para>Some narrow numeric values are <firstterm>promoted</firstterm> to a wider type.  If the
expression is a narrow integer, such as <literal>char</literal> or <literal>short</literal>,
the call converts it automatically to <literal>int</literal> (see <link linkend="Integer-Types">Integer
Types</link>).<footnote><para>On an embedded controller where <literal>char</literal>
or <literal>short</literal> is the same width as <literal>int</literal>, <literal>unsigned char</literal>
or <literal>unsigned short</literal> promotes to <literal>unsigned int</literal>, but that
never occurs in GNU C on real computers.</para></footnote>
</para>
<para>In this example, the expression <literal>c</literal> is passed as an <literal>int</literal>:
</para>
<screen>char c = '$';

printf (&quot;Character c is '%c'\n&quot;, c);
</screen>
</listitem><listitem><para>If the expression
has type <literal>float</literal>, the call converts it automatically to
<literal>double</literal>.
</para>
</listitem><listitem><para>An array as argument is converted to a pointer to its zeroth element.
</para>
</listitem><listitem><para>A function name as argument is converted to a pointer to that function.
</para></listitem></itemizedlist>
</sect1>
<sect1 label="24.4" id="Operand-Promotions">
<title>Operand Promotions</title>
<indexterm role="cp"><primary>operand promotions</primary></indexterm>

<para>The operands in arithmetic operations undergo type conversion automatically.
These <firstterm>operand promotions</firstterm> are the same as the argument promotions
except without converting <literal>float</literal> to <literal>double</literal>.  In other words,
the operand promotions convert
</para>
<itemizedlist><listitem><para><literal>char</literal> or <literal>short</literal> (whether signed or not) to <literal>int</literal>.
</para>
</listitem><listitem><para>an array to a pointer to its zeroth element, and
</para>
</listitem><listitem><para>a function name to a pointer to that function.
</para></listitem></itemizedlist>
</sect1>
<sect1 label="24.5" id="Common-Type">
<title>Common Type</title>
<indexterm role="cp"><primary>common type</primary></indexterm>

<para>Arithmetic binary operators (except the shift operators) convert their
operands to the <firstterm>common type</firstterm> before operating on them.
Conditional expressions also convert the two possible results to their
common type.  Here are the rules for determining the common type.
</para>
<para>If one of the numbers has a floating-point type and the other is an
integer, the common type is that floating-point type.  For instance,
</para>
<screen>5.6 * 2   &#8658; 11.2 /* a <literal>double</literal> value */
</screen>
<para>If both are floating point, the type with the larger range is the
common type.
</para>
<para>If both are integers but of different widths, the common type
is the wider of the two.
</para>
<para>If they are integer types of the same width, the common type is
unsigned if either operand is unsigned, and it&#8217;s <literal>long</literal> if either
operand is <literal>long</literal>.  It&#8217;s <literal>long long</literal> if either operand is
<literal>long long</literal>.
</para>
<para>These rules apply to addition, subtraction, multiplication, division,
remainder, comparisons, and bitwise operations.  They also apply to
the two branches of a conditional expression, and to the arithmetic
done in a modifying assignment operation.
</para>
</sect1>
</chapter>
<chapter label="25" id="Scope">
<title>Scope</title>
<indexterm role="cp"><primary>scope</primary></indexterm>
<indexterm role="cp"><primary>block scope</primary></indexterm>
<indexterm role="cp"><primary>function scope</primary></indexterm>
<indexterm role="cp"><primary>function prototype scope</primary></indexterm>

<para>Each definition or declaration of an identifier is visible
in certain parts of the program, which is typically less than the whole
of the program.  The parts where it is visible are called its <firstterm>scope</firstterm>.
</para>
<para>Normally, declarations made at the top-level in the source &#8211; that is,
not within any blocks and function definitions &#8211; are visible for the
entire contents of the source file after that point.  This is called
<firstterm>file scope</firstterm> (see <link linkend="File_002dScope-Variables">File-Scope Variables</link>).
</para>
<para>Declarations made within blocks of code, including within function
definitions, are visible only within those blocks.  This is called
<firstterm>block scope</firstterm>.  Here is an example:
</para>
<screen>void
foo (void)
{
  int x = 42;
}
</screen>
<para>In this example, the variable <literal>x</literal> has block scope; it is visible
only within the <literal>foo</literal> function definition block.  Thus, other
blocks could have their own variables, also named <literal>x</literal>, without
any conflict between those variables.
</para>
<para>A variable declared inside a subblock has a scope limited to
that subblock, 
</para>
<screen>void
foo (void)
{
  {
    int x = 42;
  }
  // <literal>x</literal> is out of scope here.
}
</screen>
<para>If a variable declared within a block has the same name as a variable
declared outside of that block, the definition within the block
takes precedence during its scope:
</para>
<screen>int x = 42;

void
foo (void)
{
  int x = 17;
  printf (&quot;%d\n&quot;, x);
}
</screen>
<para>This prints 17, the value of the variable <literal>x</literal> declared in the
function body block, rather than the value of the variable <literal>x</literal> at
file scope.  We say that the inner declaration of <literal>x</literal>
<firstterm>shadows</firstterm> the outer declaration, for the extent of the inner
declaration&#8217;s scope.
</para>
<para>A declaration with block scope can be shadowed by another declaration
with the same name in a subblock.
</para>
<screen>void
foo (void)
{
  char *x = &quot;foo&quot;;
  {
    int x = 42;
    &#8230;
    exit (x / 6);
  }
}
</screen>
<para>A function parameter&#8217;s scope is the entire function body, but it can
be shadowed.  For example:
</para>
<screen>int x = 42;

void
foo (int x)
{
  printf (&quot;%d\n&quot;, x);
}
</screen>
<para>This prints the value of <literal>x</literal> the function parameter, rather than
the value of the file-scope variable <literal>x</literal>.  However, 
</para>
<para>Labels (see <link linkend="goto-Statement">goto Statement</link>) have <firstterm>function</firstterm> scope: each label
is visible for the whole of the containing function body, both before
and after the label declaration:
</para>
<screen>void
foo (void)
{
  &#8230;
  goto bar;
  &#8230;
  {  // Subblock does not affect labels.
    bar:
    &#8230;
  }
  goto bar;
}
</screen>
<para>Except for labels, a declared identifier is not
visible to code before its declaration.  For example:
</para>
<screen>int x = 5;
int y = x + 10;
</screen>
<para>will work, but:
</para>
<screen>int x = y + 10;
int y = 5;
</screen>
<para>cannot refer to the variable <literal>y</literal> before its declaration.
</para>


</chapter>
<chapter label="26" id="Preprocessing">
<title>Preprocessing</title>
<!-- man begin DESCRIPTION -->
<indexterm role="cp"><primary>preprocessing</primary></indexterm>
<para>As the first stage of compiling a C source module, GCC transforms the
text with text substitutions and file inclusions.  This is called
<firstterm>preprocessing</firstterm>.
</para>

<sect1 label="26.1" id="Preproc-Overview">
<title>Preprocessing Overview</title>

<para>GNU C performs preprocessing on each line of a C program as the first
stage of compilation.  Preprocessing operates on a line only when it
contains a <firstterm>preprocessing directive</firstterm> or uses a <firstterm>macro</firstterm>&#8212;all
other lines pass through preprocessing unchanged.
</para>
<para>Here are some jobs that preprocessing does.  The rest of
this chapter gives the details.
</para>
<itemizedlist><listitem><para>Inclusion of header files.  These are files (usually containing
declarations and macro definitions) that can be substituted into your
program.
</para>
</listitem><listitem><para>Macro expansion.  You can define <firstterm>macros</firstterm>, which are abbreviations
for arbitrary fragments of C code.  Preprocessing replaces the macros
with their definitions.  Some macros are automatically predefined.
</para>
</listitem><listitem><para>Conditional compilation.  You can include or exclude parts of the
program according to various conditions.
</para>
</listitem><listitem><para>Line control.  If you use a program to combine or rearrange source files
into an intermediate file that is then compiled, you can use line
control to inform the compiler where each source line originally came
from.
</para>
</listitem><listitem><para>Compilation control.  <literal>#pragma</literal> and <literal>_Pragma</literal> invoke
some special compiler features in how to handle certain constructs.
</para>
</listitem><listitem><para>Diagnostics.  You can detect problems at compile time and issue errors
or warnings.
</para></listitem></itemizedlist>
<para>Except for expansion of predefined macros, all these operations happen
only if you use preprocessing directives to request them.
</para>
</sect1>
<sect1 label="26.2" id="Directives">
<title>Directives</title>
<indexterm role="cp"><primary>directives</primary></indexterm>
<indexterm role="cp"><primary>preprocessing directives</primary></indexterm>
<indexterm role="cp"><primary>directive line</primary></indexterm>
<indexterm role="cp"><primary>directive name</primary></indexterm>

<para><firstterm>Preprocessing directives</firstterm> are lines in the program that start
with &#8216;<literal>#</literal>&#8217;.  Whitespace is allowed before and after the &#8216;<literal>#</literal>&#8217;.
The &#8216;<literal>#</literal>&#8217; is followed by an identifier, the <firstterm>directive name</firstterm>.
It specifies the operation to perform.  Here are a couple of examples:
</para>
<screen>#define LIMIT 51
  #   undef LIMIT
# error You screwed up!
</screen>
<para>We usually refer to a directive as <literal>#<replaceable>name</replaceable></literal> where <replaceable>name</replaceable>
is the directive name.  For example, <literal>#define</literal> means the
directive that defines a macro.
</para>
<para>The &#8216;<literal>#</literal>&#8217; that begins a directive cannot come from a macro
expansion.  Also, the directive name is not macro expanded.  Thus, if
<literal>foo</literal> is defined as a macro expanding to <literal>define</literal>, that does
not make <literal>#foo</literal> a valid preprocessing directive.
</para>
<para>The set of valid directive names is fixed.  Programs cannot define new
preprocessing directives.
</para>
<para>Some directives require arguments; these make up the rest of the
directive line and must be separated from the directive name by
whitespace.  For example, <literal>#define</literal> must be followed by a macro
name and the intended expansion of the macro.
</para>
<para>A preprocessing directive cannot cover more than one line.  The line
can, however, be continued with backslash-newline, or by a
&#8216;<literal>/*&#8230;*/</literal>&#8217;-style comment that extends past the end of the
line.  These will be replaced (by nothing, or by whitespace) before
the directive is processed.
</para>
</sect1>
<sect1 label="26.3" id="Preprocessing-Tokens">
<title>Preprocessing Tokens</title>

<indexterm role="cp"><primary>preprocessing tokens</primary></indexterm>
<para>Preprocessing divides C code (minus its comments) into
<firstterm>tokens</firstterm> that are similar to C tokens, but not exactly the same.
Here are the quirks of preprocessing tokens.
</para>
<para>The main classes of preprocessing tokens are identifiers,
preprocessing numbers, string constants, character constants, and
punctuators; there are a few others too.
</para>
<variablelist><varlistentry><term>identifier
</term><listitem><indexterm role="cp"><primary>identifiers</primary></indexterm>
<para>An <firstterm>identifier</firstterm> preprocessing token is syntactically like an
identifier in C: any sequence of letters, digits, or underscores, as
well as non-ASCII characters represented using &#8216;<literal>\U</literal>&#8217; or &#8216;<literal>\u</literal>&#8217;,
that doesn&#8217;t begin with a digit.
</para>
<para>During preprocessing, the keywords of C have no special significance;
at that stage, they are simply identifiers.  Thus, you can define a
macro whose name is a keyword.  The only identifier that is special
during preprocessing is <literal>defined</literal> (see <link linkend="defined">defined</link>).
</para>
</listitem></varlistentry><varlistentry><term>preprocessing number
</term><listitem><indexterm role="cp"><primary>numbers, preprocessing</primary></indexterm>
<indexterm role="cp"><primary>preprocessing numbers</primary></indexterm>
<para>A <firstterm>preprocessing number</firstterm> is something that preprocessing treats
textually as a number, including C numeric constants, and other
sequences of characters which resemble numeric constants.
Preprocessing does not try to verify that a preprocessing number is a
valid number in C, and indeed it need not be one.
</para>
<para>More precisely, preprocessing numbers begin with an optional period, a
required decimal digit, and then continue with any sequence of
letters, digits, underscores, periods, and exponents.  Exponents are
the two-character sequences &#8216;<literal>e+</literal>&#8217;, &#8216;<literal>e-</literal>&#8217;, &#8216;<literal>E+</literal>&#8217;,
&#8216;<literal>E-</literal>&#8217;, &#8216;<literal>p+</literal>&#8217;, &#8216;<literal>p-</literal>&#8217;, &#8216;<literal>P+</literal>&#8217;, and &#8216;<literal>P-</literal>&#8217;.  (The
exponents that begin with &#8216;<literal>p</literal>&#8217; or &#8216;<literal>P</literal>&#8217; are new to C99.  They
are used for hexadecimal floating-point constants.)
</para>
<para>The reason behind this unusual syntactic class is that the full
complexity of numeric constants is irrelevant during preprocessing.
The distinction between lexically valid and invalid floating-point
numbers, for example, doesn&#8217;t matter at this stage.  The use of
preprocessing numbers makes it possible to split an identifier at any
position and get exactly two tokens, and reliably paste them together
using the <literal>##</literal> operator (see <link linkend="Concatenation">Concatenation</link>).
</para>
</listitem></varlistentry><varlistentry><term>punctuator
</term><listitem><para>A <firstterm>punctuator</firstterm> is syntactically like an operator.
These are the valid punctuators:
</para>
<screen>[  ]   (  )  {  }  .  -&gt;
++ --  &amp;  *  +  -  ~  !
/  %   &lt;&lt; &gt;&gt; &lt;  &gt;  &lt;= &gt;=  ==  !=  ^  |  &amp;&amp;  ||
?  :   ;  ...
=  *=  /=  %=  +=  -=  &lt;&lt;=  &gt;&gt;=  &amp;=  ^=  |=
,  #   ##
&lt;: :&gt;  &lt;% %&gt;  %:  %:%:
</screen>
</listitem></varlistentry><varlistentry><term>string constant
</term><listitem><para>A string constant in the source code is recognized by preprocessing as
a single preprocessing token.
</para>
</listitem></varlistentry><varlistentry><term>character constant
</term><listitem><para>A character constant in the source code is recognized by preprocessing
as a single preprocessing token.
</para>
</listitem></varlistentry><varlistentry><term>header name
</term><listitem><para>Within the <literal>#include</literal> directive, preprocessing recognizes a
<firstterm>header name</firstterm> token.  It consists of &#8216;<literal>&quot;<replaceable>name</replaceable>&quot;</literal>&#8217;, where
<replaceable>name</replaceable> is a sequence of source characters other than newline and
&#8216;<literal>&quot;</literal>&#8217;, or &#8216;<literal>&lt;<replaceable>name</replaceable>&gt;</literal>&#8217;, where <replaceable>name</replaceable> is a sequence of
source characters other than newline and &#8216;<literal>&gt;</literal>&#8217;.
</para>
<para>In practice, it is more convenient to think that the <literal>#include</literal> line
is exempt from tokenization.
</para>
</listitem></varlistentry><varlistentry><term>other
</term><listitem><para>Any other character that&#8217;s valid in a C source program
is treated as a separate preprocessing token.
</para></listitem></varlistentry></variablelist>
<para>Once the program is broken into preprocessing tokens, they remain
separate until the end of preprocessing.  Macros that generate two
consecutive tokens insert whitespace to keep them separate, if
necessary.  For example,
</para>
<screen>#define foo() bar
foo()baz
     &#8614; bar baz
<emphasis>not</emphasis>
     &#8614; barbaz
</screen>
<para>The only exception is with the <literal>##</literal> preprocessing operator, which
pastes tokens together (see <link linkend="Concatenation">Concatenation</link>).
</para>
<para>Preprocessing treats the null character (code 0) as whitespace, but
generates a warning for it because it may be invisible to the user
(many terminals do not display it at all) and its presence in the file
is probably a mistake.
</para>
</sect1>
<sect1 label="26.4" id="Header-Files">
<title>Header Files</title>

<indexterm role="cp"><primary>header file</primary></indexterm>
<para>A header file is a file of C code, typically containing C declarations
and macro definitions (see <link linkend="Macros">Macros</link>), to be shared between several
source files.  You request the use of a header file in your program by
<firstterm>including</firstterm> it, with the C preprocessing directive
<literal>#include</literal>.
</para>
<para>Header files serve two purposes.
</para>
<itemizedlist><listitem><indexterm role="cp"><primary>system header files</primary></indexterm>
<para>System header files declare the interfaces to parts of the operating
system.  You include them in your program to supply the definitions and
declarations that you need to invoke system calls and libraries.
</para>
</listitem><listitem><para>Program-specific header files contain declarations for interfaces between the
source files of a particular program.  It is a good idea to create a header
file for related declarations and macro definitions if all or most of them
are needed in several different source files.
</para></listitem></itemizedlist>
<para>Including a header file produces the same results as copying the header
file into each source file that needs it.  Such copying would be
time-consuming and error-prone.  With a header file, the related
declarations appear in only one place.  If they need to be changed, you
can change them in one place, and programs that include the header file
will then automatically use the new version when next recompiled.  The header
file eliminates the labor of finding and changing all the copies as well
as the risk that a failure to change one copy will result in
inconsistencies within a program.
</para>
<para>In C, the usual convention is to give header files names that end with
<filename>.h</filename>.  It is most portable to use only letters, digits, dashes, and
underscores in header file names, and at most one dot.
</para>

<sect2 label="26.4.1" id="include-Syntax">
<title><literal>#include</literal> Syntax</title>

<indexterm role="fn"><primary>#include</primary></indexterm>
<para>You can specify inclusion of user and system header files with the
preprocessing directive <literal>#include</literal>.  It has two variants:
</para>
<variablelist><varlistentry><term><literal>#include &lt;<replaceable>file</replaceable>&gt;</literal>
</term><listitem><para>This variant is used for system header files.  It searches for a file
named <replaceable>file</replaceable> in a standard list of system directories.  You can
prepend directories to this list with the <option>-I</option> option
(see section &#8220;Invoking GCC&#8221; in <citetitle>Using the GNU
Compiler Collection</citetitle>).
</para>
</listitem></varlistentry><varlistentry><term><literal>#include &quot;<replaceable>file</replaceable>&quot;</literal>
</term><listitem><para>This variant is used for header files of your own program.  It
searches for a file named <replaceable>file</replaceable> first in the directory containing
the current file, then in the quote directories, then the same
directories used for <literal>&lt;<replaceable>file</replaceable>&gt;</literal>.  You can prepend directories
to the list of quote directories with the <option>-iquote</option> option.
</para></listitem></varlistentry></variablelist>
<para>The argument of <literal>#include</literal>, whether delimited with quote marks or
angle brackets, behaves like a string constant in that comments are not
recognized, and macro names are not expanded.  Thus, <literal>#include
&lt;x/*y&gt;<!-- /@w --></literal> specifies inclusion of a system header file named <filename>x/*y</filename>.
</para>
<para>However, if backslashes occur within <replaceable>file</replaceable>, they are considered
ordinary text characters, not escape characters: character escape
sequences such as used in string constants in C are not meaningful
here.  Thus, <literal>#include &quot;x\n\\y&quot;<!-- /@w --></literal> specifies a filename
containing three backslashes.  By the same token, there is no way to
escape &#8216;<literal>&quot;</literal>&#8217; or &#8216;<literal>&gt;</literal>&#8217; to include it in the header file name if
it would instead end the file name.
</para>
<para>Some systems interpret &#8216;<literal>\</literal>&#8217; as a file name component separator.
All these systems also interpret &#8216;<literal>/</literal>&#8217; the same way.  It is most
portable to use only &#8216;<literal>/</literal>&#8217;.
</para>
<para>It is an error to put anything other than comments on the
<literal>#include</literal> line after the file name.
</para>
</sect2>
<sect2 label="26.4.2" id="include-Operation">
<title><literal>#include</literal> Operation</title>

<para>The <literal>#include</literal> directive works by scanning the specified header
file as input before continuing with the rest of the current file.
The result of preprocessing consists of the text already generated,
followed by the result of preprocessing the included file, followed by
whatever results from the text after the <literal>#include</literal> directive.
For example, if you have a header file <filename>header.h</filename> as follows,
</para>
<screen>char *test (void);
</screen>
<para>and a main program called <filename>program.c</filename> that uses the header file,
like this,
</para>
<screen>int x;
#include &quot;header.h&quot;

int
main (void)
{
  puts (test ());
}
</screen>
<para>the result is equivalent to putting this text in <filename>program.c</filename>:
</para>
<screen>int x;
char *test (void);

int
main (void)
{
  puts (test ());
}
</screen>
<para>Included files are not limited to declarations and macro definitions;
those are merely the typical uses.  Any fragment of a C program can be
included from another file.  The include file could even contain the
beginning of a statement that is concluded in the containing file, or
the end of a statement that was started in the including file.  However,
an included file must consist of complete tokens.  Comments and string
literals that have not been closed by the end of an included file are
invalid.  For error recovery, the compiler terminates them at the end of
the file.
</para>
<para>To avoid confusion, it is best if header files contain only complete
syntactic units&#8212;function declarations or definitions, type
declarations, etc.
</para>
<para>The line following the <literal>#include</literal> directive is always treated as
a separate line, even if the included file lacks a final newline.
There is no problem putting a preprocessing directive there.
</para>
</sect2>
<sect2 label="26.4.3" id="Search-Path">
<title>Search Path</title>

<para>GCC looks in several different places for header files to be included.
On the GNU system, and Unix systems, the default directories for
system header files are:
</para>
<screen><replaceable>libdir</replaceable>/gcc/<replaceable>target</replaceable>/<replaceable>version</replaceable>/include
/usr/local/include
<replaceable>libdir</replaceable>/gcc/<replaceable>target</replaceable>/<replaceable>version</replaceable>/include-fixed
<replaceable>libdir</replaceable>/<replaceable>target</replaceable>/include
/usr/include/<replaceable>target</replaceable>
/usr/include
</screen>
<para>The list may be different in some operating systems.  Other
directories are added for C++.
</para>
<para>In the above, <replaceable>target</replaceable> is the canonical name of the system GCC was
configured to compile code for; often but not always the same as the
canonical name of the system it runs on.  <replaceable>version</replaceable> is the version
of GCC in use.
</para>
<para>You can add to this list with the <option>-I<replaceable>dir</replaceable></option> command-line
option.  All the directories named by <option>-I</option> are searched, in
left-to-right order, <emphasis>before</emphasis> the default directories.  The only
exception is when <filename>dir</filename> is already searched by default.  In
this case, the option is ignored and the search order for system
directories remains unchanged.
</para>
<para>Duplicate directories are removed from the quote and bracket search
chains before the two chains are merged to make the final search chain.
Thus, it is possible for a directory to occur twice in the final search
chain if it was specified in both the quote and bracket chains.
</para>
<para>You can prevent GCC from searching any of the default directories with
the <option>-nostdinc</option> option.  This is useful when you are compiling an
operating system kernel or some other program that does not use the
standard C library facilities, or the standard C library itself.
<option>-I</option> options are not ignored as described above when
<option>-nostdinc</option> is in effect.
</para>
<para>GCC looks for headers requested with <literal>#include &quot;<replaceable>file</replaceable>&quot;<!-- /@w --></literal>
first in the directory containing the current file, then in the
<firstterm>quote directories</firstterm> specified by <option>-iquote</option> options, then in
the same places it looks for a system header.  For example, if
<filename>/usr/include/sys/stat.h</filename> contains <literal>#include &quot;types.h&quot;<!-- /@w --></literal>,
GCC looks for <filename>types.h</filename> first in <filename>/usr/include/sys</filename>, then in
the quote directories and then in its usual search path.
</para>
<para><literal>#line</literal> (see <link linkend="Line-Control">Line Control</link>) does not change GCC&#8217;s idea of the
directory containing the current file.
</para>
<indexterm role="cp"><primary>quote directories</primary></indexterm>
<para>The <option>-I-</option> is an old-fashioned, deprecated way to specify the
quote directories.  To look for headers in a directory named <filename>-</filename>,
specify <option>-I./-</option>.  There are several more ways to adjust the
header search path.  See section &#8220;Invoking GCC&#8221; in <citetitle>Using the GNU Compiler Collection</citetitle>.
</para>
</sect2>
<sect2 label="26.4.4" id="Once_002dOnly-Headers">
<title>Once-Only Headers</title>
<indexterm role="cp"><primary>repeated inclusion</primary></indexterm>
<indexterm role="cp"><primary>including just once</primary></indexterm>
<indexterm role="cp"><primary>wrapper <literal>#ifndef</literal></primary></indexterm>

<para>If a header file happens to be included twice, the compiler will process
its contents twice.  This is very likely to cause an error, e.g. when the
compiler sees the same structure definition twice.
</para>
<para>The standard way to prevent this is to enclose the entire real contents
of the file in a conditional, like this:
</para>
<screen>/* File foo.  */
#ifndef FILE_FOO_SEEN
#define FILE_FOO_SEEN

<replaceable>the entire file</replaceable>

#endif /* !FILE_FOO_SEEN */
</screen>
<para>This construct is commonly known as a <firstterm>wrapper #ifndef</firstterm>.  When the
header is included again, the conditional will be false, because
<literal>FILE_FOO_SEEN</literal> is defined.  Preprocessing skips over the entire
contents of the file, so that compilation will never &#8220;see&#8221; the file
contents twice in one module.
</para>
<para>GCC optimizes this case even further.  It remembers when a header file
has a wrapper <literal>#ifndef</literal>.  If a subsequent <literal>#include</literal>
specifies that header, and the macro in the <literal>#ifndef</literal> is still
defined, it does not bother to rescan the file at all.
</para>
<para>You can put comments in the header file outside the wrapper.  They
do not interfere with this optimization.
</para>
<indexterm role="cp"><primary>controlling macro</primary></indexterm>
<indexterm role="cp"><primary>guard macro</primary></indexterm>
<para>The macro <literal>FILE_FOO_SEEN</literal> is called the <firstterm>controlling macro</firstterm>
or <firstterm>guard macro</firstterm>.  In a user header file, the macro name should
not begin with &#8216;<literal>_</literal>&#8217;.  In a system header file, it should begin
with &#8216;<literal>__</literal>&#8217; (or &#8216;<literal>_</literal>&#8217; followed by an upper-case letter) to avoid
conflicts with user programs.  In any kind of header file, the macro
name should contain the name of the file and some additional text, to
avoid conflicts with other header files.
</para>
</sect2>
<sect2 label="26.4.5" id="Computed-Includes">
<title>Computed Includes</title>
<indexterm role="cp"><primary>computed includes</primary></indexterm>
<indexterm role="cp"><primary>macros in include</primary></indexterm>

<para>Sometimes it is necessary to select one of several different header
files to be included into your program.  They might specify
configuration parameters to be used on different sorts of operating
systems, for instance.  You could do this with a series of conditionals,
</para>
<screen>#if SYSTEM_1
# include &quot;system_1.h&quot;
#elif SYSTEM_2
# include &quot;system_2.h&quot;
#elif SYSTEM_3
/* &#8230; */
#endif
</screen>
<para>That rapidly becomes tedious.  Instead, GNU C offers the ability to use
a macro for the header name.  This is called a <firstterm>computed include</firstterm>.
Instead of writing a header name as the direct argument of
<literal>#include</literal>, you simply put a macro name there instead:
</para>
<screen>#define SYSTEM_H &quot;system_1.h&quot;
/* &#8230; */
#include SYSTEM_H
</screen>
<para><literal>SYSTEM_H</literal> is expanded, then <filename>system_1.h</filename> is included as if
the <literal>#include</literal> had been written with that name.  <literal>SYSTEM_H</literal>
could be defined by your Makefile with a <option>-D</option> option.
</para>
<para>You must be careful when you define such a macro.  <literal>#define</literal>
saves tokens, not text.  GCC has no way of knowing that the macro will
be used as the argument of <literal>#include</literal>, so it generates ordinary
tokens, not a header name.  This is unlikely to cause problems if you
use double-quote includes, which are syntactically similar to string
constants.  If you use angle brackets, however, you may have trouble.
</para>
<para>The syntax of a computed include is actually a bit more general than the
above.  If the first non-whitespace character after <literal>#include</literal> is
not &#8216;<literal>&quot;</literal>&#8217; or &#8216;<literal>&lt;</literal>&#8217;, then the entire line is macro-expanded
like running text would be.
</para>
<para>If the line expands to a single string constant, the contents of that
string constant are the file to be included.  Preprocessing does not
re-examine the string for embedded quotes, but neither does it process
backslash escapes in the string.  Therefore
</para>
<screen>#define HEADER &quot;a\&quot;b&quot;
#include HEADER
</screen>
<para>looks for a file named <filename>a\&quot;b</filename>.  Preprocessing searches for the
file according to the rules for double-quoted includes.
</para>
<para>If the line expands to a token stream beginning with a &#8216;<literal>&lt;</literal>&#8217; token
and including a &#8216;<literal>&gt;</literal>&#8217; token, then the tokens between the &#8216;<literal>&lt;</literal>&#8217; and
the first &#8216;<literal>&gt;</literal>&#8217; are combined to form the filename to be included.
Any whitespace between tokens is reduced to a single space; then any
space after the initial &#8216;<literal>&lt;</literal>&#8217; is retained, but a trailing space
before the closing &#8216;<literal>&gt;</literal>&#8217; is ignored.  Preprocessing searches for the file
according to the rules for angle-bracket includes.
</para>
<para>In either case, if there are any tokens on the line after the file name,
an error occurs and the directive is not processed.  It is also an error
if the result of expansion does not match either of the two expected
forms.
</para>
<para>These rules are implementation-defined behavior according to the C
standard.  To minimize the risk of different compilers interpreting your
computed includes differently, we recommend you use only a single
object-like macro that expands to a string constant.  That also
makes it clear to people reading your program.
</para>
</sect2>
</sect1>
<sect1 label="26.5" id="Macros">
<title>Macros</title>
<indexterm role="cp"><primary>macros</primary></indexterm>

<para>A <firstterm>macro</firstterm> is a fragment of code that has been given a name.
Whenever the name is used, it is replaced by the contents of the macro.
There are two kinds of macros.  They differ mostly in what they look
like when they are used.  <firstterm>Object-like</firstterm> macros resemble data objects
when used, <firstterm>function-like</firstterm> macros resemble function calls.
</para>
<para>You may define any valid identifier as a macro, even if it is a C
keyword.  In the preprocessing stage, GCC does not know anything about
keywords.  This can be useful if you wish to hide a keyword such as
<literal>const</literal> from an older compiler that does not understand it.
However, the preprocessing operator <literal>defined</literal> (see <link linkend="defined">defined</link>)
can never be defined as a macro, and C<literal>++</literal>&#8217;s named operators
(see section &#8220;C++ Named Operators&#8221; in <citetitle>Using the GNU Compiler Collection</citetitle>) cannot be macros when
compiling C<literal>++</literal> code.
</para>
<para>The operator <literal>#</literal> is used in macros for stringification of an
argument (see <link linkend="Stringification">Stringification</link>), and <literal>##</literal> is used for
concatenation of arguments into larger tokens (see <link linkend="Concatenation">Concatenation</link>)
</para>

<sect2 label="26.5.1" id="Object_002dlike-Macros">
<title>Object-like Macros</title>
<indexterm role="cp"><primary>object-like macro</primary></indexterm>
<indexterm role="cp"><primary>symbolic constants</primary></indexterm>
<indexterm role="cp"><primary>manifest constants</primary></indexterm>

<para>An <firstterm>object-like macro</firstterm> is a simple identifier that will be
replaced by a code fragment.  It is called object-like because in most
cases the use of the macro looks like reference to a data object in
code that uses it.  These macros are most commonly used to give
symbolic names to numeric constants.
</para>
<indexterm role="fn"><primary>#define</primary></indexterm>
<para>The way to define macros with the <literal>#define</literal> directive.
<literal>#define</literal> is followed by the name of the macro and then the token
sequence it should be an abbreviation for, which is variously referred
to as the macro&#8217;s <firstterm>body</firstterm>, <firstterm>expansion</firstterm> or <firstterm>replacement
list</firstterm>.  For example,
</para>
<screen>#define BUFFER_SIZE 1024
</screen>
<para>defines a macro named <literal>BUFFER_SIZE</literal> as an abbreviation for the
token <literal>1024</literal>.  If somewhere after this <literal>#define</literal> directive
there comes a C statement of the form
</para>
<screen>foo = (char *) malloc (BUFFER_SIZE);
</screen>
<para>then preprocessing will recognize and <firstterm>expand</firstterm> the macro
<literal>BUFFER_SIZE</literal>, so that compilation will see the tokens:
</para>
<screen>foo = (char *) malloc (1024);
</screen>
<para>By convention, macro names are written in upper case.  Programs are
easier to read when it is possible to tell at a glance which names are
macros.  Macro names that start with &#8216;<literal>__</literal>&#8217; are reserved for
internal uses, and many of them are defined automatically, so don&#8217;t
define such macro names unless you really know what you&#8217;re doing.
Likewise for macro names that start with &#8216;<literal>_</literal>&#8217; and an upper-case letter.
</para>
<para>The macro&#8217;s body ends at the end of the <literal>#define</literal> line.  You may
continue the definition onto multiple lines, if necessary, using
backslash-newline.  When the macro is expanded, however, it will all
come out on one line.  For example,
</para>
<screen>#define NUMBERS 1, \
                2, \
                3
int x[] = { NUMBERS };
     &#8614; int x[] = { 1, 2, 3 };
</screen>
<para>The most common visible consequence of this is surprising line numbers
in error messages.
</para>
<para>There is no restriction on what can go in a macro body provided it
decomposes into valid preprocessing tokens.  Parentheses need not
balance, and the body need not resemble valid C code.  (If it does not,
you may get error messages from the C compiler when you use the macro.)
</para>
<para>Preprocessing scans the program sequentially.  A macro definition
takes effect right after its appearance.  Therefore, the following
input
</para>
<screen>foo = X;
#define X 4
bar = X;
</screen>
<para>produces
</para>
<screen>foo = X;
bar = 4;
</screen>
<para>When preprocessing expands a macro name, the macro&#8217;s expansion
replaces the macro invocation, then the expansion is examined for more
macros to expand.  For example,
</para>
<screen>#define TABLESIZE BUFSIZE
#define BUFSIZE 1024
TABLESIZE
     &#8614; BUFSIZE
     &#8614; 1024
</screen>
<para><literal>TABLESIZE</literal> is expanded first to produce <literal>BUFSIZE</literal>, then that
macro is expanded to produce the final result, <literal>1024</literal>.
</para>
<para>Notice that <literal>BUFSIZE</literal> was not defined when <literal>TABLESIZE</literal> was
defined.  The <literal>#define</literal> for <literal>TABLESIZE</literal> uses exactly the
expansion you specify&#8212;in this case, <literal>BUFSIZE</literal>&#8212;and does not
check to see whether it too contains macro names.  Only when you
<emphasis>use</emphasis> <literal>TABLESIZE</literal> is the result of its expansion scanned for
more macro names.
</para>
<para>This makes a difference if you change the definition of <literal>BUFSIZE</literal>
at some point in the source file.  <literal>TABLESIZE</literal>, defined as shown,
will always expand using the definition of <literal>BUFSIZE</literal> that is
currently in effect:
</para>
<screen>#define BUFSIZE 1020
#define TABLESIZE BUFSIZE
#undef BUFSIZE
#define BUFSIZE 37
</screen>
<para>Now <literal>TABLESIZE</literal> expands (in two stages) to <literal>37</literal>.
</para>
<para>If the expansion of a macro contains its own name, either directly or
via intermediate macros, it is not expanded again when the expansion is
examined for more macros.  This prevents infinite recursion.
See <link linkend="Self_002dReferential-Macros">Self-Referential Macros</link>, for the precise details.
</para>
</sect2>
<sect2 label="26.5.2" id="Function_002dlike-Macros">
<title>Function-like Macros</title>
<indexterm role="cp"><primary>function-like macros</primary></indexterm>

<para>You can also define macros whose use looks like a function call.
These are called <firstterm>function-like macros</firstterm>.  To define one, use the
<literal>#define</literal> directive with a pair of parentheses immediately after
the macro name.  For example,
</para>
<screen>#define lang_init()  c_init()
lang_init()
     &#8614; c_init()
</screen>
<para>A function-like macro is expanded only when its name appears with a
pair of parentheses after it.  If you write just the name, without
parentheses, it is left alone.  This can be useful when you have a
function and a macro of the same name, and you wish to use the
function sometimes.  Whitespace and line breaks before or between the
parentheses are ignored when the macro is called.
</para>
<screen>extern void foo(void);
#define foo() /* optimized inline version */
/* &#8230; */
  foo();
  funcptr = foo;
</screen>
<para>Here the call to <literal>foo()</literal> expands the macro, but the function
pointer <literal>funcptr</literal> gets the address of the real function
<literal>foo</literal>.  If the macro were to be expanded there, it would cause a
syntax error.
</para>
<para>If you put spaces between the macro name and the parentheses in the
macro definition, that does not define a function-like macro, it defines
an object-like macro whose expansion happens to begin with a pair of
parentheses.  Here is an example:
</para>
<screen>#define lang_init ()    c_init()
lang_init()
     &#8614; () c_init()()
</screen>
<para>The first two pairs of parentheses in this expansion come from the
macro.  The third is the pair that was originally after the macro
invocation.  Since <literal>lang_init</literal> is an object-like macro, it does not
consume those parentheses.
</para>
<para>Any name can have at most one macro definition at a time.  Thus,
you can&#8217;t define the same name as an object-like macro and a
function-like macro at once.
</para>
</sect2>
<sect2 label="26.5.3" id="Macro-Arguments">
<title>Macro Arguments</title>
<indexterm role="cp"><primary>arguments</primary></indexterm>
<indexterm role="cp"><primary>macros with arguments</primary></indexterm>
<indexterm role="cp"><primary>arguments in macro definitions</primary></indexterm>

<para>Function-like macros can take <firstterm>arguments</firstterm>, just like true functions.
To define a macro that uses arguments, you insert <firstterm>parameters</firstterm>
between the pair of parentheses in the macro definition that make the
macro function-like.  The parameters must be valid C identifiers,
separated by commas and optionally whitespace.
</para>
<para>To invoke a macro that takes arguments, you write the name of the macro
followed by a list of <firstterm>actual arguments</firstterm> in parentheses, separated
by commas.  The invocation of the macro need not be restricted to a
single logical line&#8212;it can cross as many lines in the source file as
you wish.  The number of arguments you give must match the number of
parameters in the macro definition.  When the macro is expanded, each
use of a parameter in its body is replaced by the tokens of the
corresponding argument.  (The macro body is not required to use all of the
parameters.)
</para>
<para>As an example, here is a macro that computes the minimum of two numeric
values, as it is defined in many C programs, and some uses.
</para>
<screen>#define min(X, Y)  ((X) &lt; (Y) ? (X) : (Y))
  x = min(a, b);      &#8614; x = ((a) &lt; (b) ? (a) : (b));
  y = min(1, 2);      &#8614; y = ((1) &lt; (2) ? (1) : (2));
  z = min(a+28, *p);  &#8614; z = ((a+28) &lt; (*p) ? (a+28) : (*p));
</screen>
<para>In this small example you can already see several of the dangers of
macro arguments.  See <link linkend="Macro-Pitfalls">Macro Pitfalls</link>, for detailed explanations.
</para>
<para>Leading and trailing whitespace in each argument is dropped, and all
whitespace between the tokens of an argument is reduced to a single
space.  Parentheses within each argument must balance; a comma within
such parentheses does not end the argument.  However, there is no
requirement for square brackets or braces to balance, and they do not
prevent a comma from separating arguments.  Thus,
</para>
<screen>macro (array[x = y, x + 1])
</screen>
<para>passes two arguments to <literal>macro</literal>: <literal>array[x = y</literal> and <literal>x +
1]</literal>.  If you want to supply <literal>array[x = y, x + 1]</literal> as an argument,
you can write it as <literal>array[(x = y, x + 1)]</literal>, which is equivalent C
code.  However, putting an assignment inside an array subscript
is to be avoided anyway.
</para>
<para>All arguments to a macro are completely macro-expanded before they are
substituted into the macro body.  After substitution, the complete text
is scanned again for macros to expand, including the arguments.  This rule
may seem strange, but it is carefully designed so you need not worry
about whether any function call is actually a macro invocation.  You can
run into trouble if you try to be too clever, though.  See <link linkend="Argument-Prescan">Argument
Prescan</link>, for detailed discussion.
</para>
<para>For example, <literal>min (min (a, b), c)</literal> is first expanded to
</para>
<screen>  min (((a) &lt; (b) ? (a) : (b)), (c))
</screen>
<para>and then to
</para>
<screen>((((a) &lt; (b) ? (a) : (b))) &lt; (c)
 ? (((a) &lt; (b) ? (a) : (b)))
 : (c))
</screen>
<para>(The line breaks shown here for clarity are not actually generated.)
</para>
<indexterm role="cp"><primary>empty macro arguments</primary></indexterm>
<para>You can leave macro arguments empty without error, but many macros
will then expand to invalid code.  You cannot leave out arguments
entirely; if a macro takes two arguments, there must be exactly one
comma at the top level of its argument list.  Here are some silly
examples using <literal>min</literal>:
</para>
<screen>min(, b)        &#8614; ((   ) &lt; (b) ? (   ) : (b))
min(a, )        &#8614; ((a  ) &lt; ( ) ? (a  ) : ( ))
min(,)          &#8614; ((   ) &lt; ( ) ? (   ) : ( ))
min((,),)       &#8614; (((,)) &lt; ( ) ? ((,)) : ( ))

min()      error&#8594; macro &quot;min&quot; requires 2 arguments, but only 1 given
min(,,)    error&#8594; macro &quot;min&quot; passed 3 arguments, but takes just 2
</screen>
<para>Whitespace is not a preprocessing token, so if a macro <literal>foo</literal> takes
one argument, <literal>foo ()<!-- /@w --></literal> and <literal>foo ( )<!-- /@w --></literal> both supply it an
empty argument.
</para>

<para>Macro parameters appearing inside string literals are not replaced by
their corresponding actual arguments.
</para>
<screen>#define foo(x) x, &quot;x&quot;
foo(bar)        &#8614; bar, &quot;x&quot;
</screen>
<para>See the next subsection for how to insert macro arguments
into a string literal.
</para>
<para>The token following the macro call and the last token of the macro
expansion do not become one token even if it looks like they could:
</para>
<screen>#define foo()  abc
foo()def        &#8614; abc def
</screen>
</sect2>
<sect2 label="26.5.4" id="Stringification">
<title>Stringification</title>
<indexterm role="cp"><primary>stringification</primary></indexterm>
<indexterm role="cp"><primary><literal>#</literal> operator</primary></indexterm>

<para>Sometimes you may want to convert a macro argument into a string
constant.  Parameters are not replaced inside string constants, but
you can use the <literal>#</literal> preprocessing operator instead.  When a macro
parameter is used with a leading <literal>#</literal>, preprocessing replaces it
with the literal text of the actual argument, converted to a string
constant.  Unlike normal parameter replacement, the argument is not
macro-expanded first.  This is called <firstterm>stringification</firstterm>.
</para>
<para>There is no way to combine an argument with surrounding text and
stringify it all together.  But you can write a series of string
constants and stringified arguments.  After preprocessing replaces the
stringified arguments with string constants, the consecutive string
constants will be concatenated into one long string constant
(see <link linkend="String-Constants">String Constants</link>).
</para>
<para>Here is an example that uses stringification and concatenation of
string constants:
</para>
<screen>#define WARN_IF(EXP) \
  do { if (EXP) \
          fprintf (stderr, &quot;Warning: &quot; #EXP &quot;\n&quot;); } \
  while (0)

WARN_IF (x == 0);
     &#8614;
  do { if (x == 0)
          fprintf (stderr, &quot;Warning: &quot; &quot;x == 0&quot; &quot;\n&quot;); }
  while (0);
</screen>
<para>The argument for <literal>EXP</literal> is substituted once, as is, into the
<literal>if</literal> statement, and once, stringified, into the argument to
<literal>fprintf</literal>.  If <literal>x</literal> were a macro, it would be expanded in the
<literal>if</literal> statement but not in the string.
</para>
<para>The <literal>do</literal> and <literal>while (0)</literal> are a kludge to make it possible to
write <literal>WARN_IF (<replaceable>arg</replaceable>);</literal>.  The resemblance of <literal>WARN_IF</literal>
to a function makes that a natural way to write it.
See <link linkend="Swallowing-the-Semicolon">Swallowing the Semicolon</link>.
</para>
<para>Stringification in C involves more than putting double-quote
characters around the fragment.  It also backslash-escapes the quotes
surrounding embedded string constants, and all backslashes within
string and character constants, in order to get a valid C string
constant with the proper contents.  Thus, stringifying <literal>p =
&quot;foo\n&quot;;<!-- /@w --></literal> results in <literal>&quot;p = \&quot;foo\\n\&quot;;&quot;<!-- /@w --></literal>.  However, backslashes
that are not inside string or character constants are not duplicated:
&#8216;<literal>\n</literal>&#8217; by itself stringifies to <literal>&quot;\n&quot;</literal>.
</para>
<para>All leading and trailing whitespace in text being stringified is
ignored.  Any sequence of whitespace in the middle of the text is
converted to a single space in the stringified result.  Comments are
replaced by whitespace long before stringification happens, so they
never appear in stringified text.
</para>
<para>There is no way to convert a macro argument into a character constant.
</para>
<para>To stringify the result of expansion of a macro argument, you have to
use two levels of macros, like this:
</para>
<screen>#define xstr(S) str(S)
#define str(s) #s
#define foo 4
str (foo)
     &#8614; &quot;foo&quot;
xstr (foo)
     &#8614; xstr (4)
     &#8614; str (4)
     &#8614; &quot;4&quot;
</screen>
<para><literal>s</literal> is stringified when it is used in <literal>str</literal>, so it is not
macro-expanded first.  But <literal>S</literal> is an ordinary argument to
<literal>xstr</literal>, so it is completely macro-expanded before <literal>xstr</literal>
itself is expanded (see <link linkend="Argument-Prescan">Argument Prescan</link>).  Therefore, by the time
<literal>str</literal> gets to its argument text, that text already been
macro-expanded.
</para>
</sect2>
<sect2 label="26.5.5" id="Concatenation">
<title>Concatenation</title>
<indexterm role="cp"><primary>concatenation</primary></indexterm>
<indexterm role="cp"><primary>token pasting</primary></indexterm>
<indexterm role="cp"><primary>token concatenation</primary></indexterm>
<indexterm role="cp"><primary><literal>##</literal> operator</primary></indexterm>

<para>It is often useful to merge two tokens into one while expanding macros.
This is called <firstterm>token pasting</firstterm> or <firstterm>token concatenation</firstterm>.  The
<literal>##</literal> preprocessing operator performs token pasting.  When a macro
is expanded, the two tokens on either side of each <literal>##</literal> operator
are combined into a single token, which then replaces the <literal>##</literal> and
the two original tokens in the macro expansion.  Usually both will be
identifiers, or one will be an identifier and the other a preprocessing
number.  When pasted, they make a longer identifier.
</para>
<para>Concatenation into an identifier isn&#8217;t the only valid case.  It is
also possible to concatenate two numbers (or a number and a name, such
as <literal>1.5</literal> and <literal>e3</literal>) into a number.  Also, multi-character
operators such as <literal>+=</literal> can be formed by token pasting.
</para>
<para>However, two tokens that don&#8217;t together form a valid token cannot be
pasted together.  For example, you cannot concatenate <literal>x</literal> with
<literal>+</literal>, not in either order.  Trying this issues a warning and keeps
the two tokens separate.  Whether it puts white space between the
tokens is undefined.  It is common to find unnecessary uses of
<literal>##</literal> in complex macros.  If you get this warning, it is likely
that you can simply remove the <literal>##</literal>.
</para>
<para>The tokens combined by <literal>##</literal> could both come from the macro body,
but then you could just as well write them as one token in the first place.
Token pasting is useful when one or both of the tokens comes from a
macro argument.  If either of the tokens next to an <literal>##</literal> is a
parameter name, it is replaced by its actual argument before <literal>##</literal>
executes.  As with stringification, the actual argument is not
macro-expanded first.  If the argument is empty, that <literal>##</literal> has no
effect.
</para>
<para>Keep in mind that preprocessing converts comments to whitespace before
it looks for uses of macros.  Therefore, you cannot create a comment
by concatenating &#8216;<literal>/</literal>&#8217; and &#8216;<literal>*</literal>&#8217;.  You can put as much
whitespace between <literal>##</literal> and its operands as you like, including
comments, and you can put comments in arguments that will be
concatenated.
</para>
<para>It is an error to use <literal>##</literal> at the beginning or end of a macro
body.
</para>
<para>Multiple <literal>##</literal> operators are handled left-to-right, so that
&#8216;<literal>1 ## e ## -2</literal>&#8217; pastes into &#8216;<literal>1e-2</literal>&#8217;.  (Right-to-left
processing would first generate &#8216;<literal>e-2</literal>&#8217;, which is an invalid token.)
When <literal>#</literal> and <literal>##</literal> are used together, they are all handled
left-to-right.
</para>
<para>Consider a C program that interprets named commands.  There probably
needs to be a table of commands, perhaps an array of structures declared
as follows:
</para>
<screen>struct command
{
  char *name;
  void (*function) (void);
};
</screen><screen>
</screen><screen>struct command commands[] =
{
  { &quot;quit&quot;, quit_command },
  { &quot;help&quot;, help_command },
  /* &#8230; */
};
</screen>
<para>It would be cleaner not to have to write each command name twice, once
in the string constant and once in the function name.  A macro that
takes the name of a command as an argument can make this unnecessary.
It can create the string constant with stringification, and the
function name by concatenating the argument with &#8216;<literal>_command</literal>&#8217;.
Here is how it is done:
</para>
<screen>#define COMMAND(NAME)  { #NAME, NAME ## _command }

struct command commands[] =
{
  COMMAND (quit),
  COMMAND (help),
  /* &#8230; */
};
</screen>
</sect2>
<sect2 label="26.5.6" id="Variadic-Macros">
<title>Variadic Macros</title>
<indexterm role="cp"><primary>variable number of arguments</primary></indexterm>
<indexterm role="cp"><primary>macros with variable arguments</primary></indexterm>
<indexterm role="cp"><primary>variadic macros</primary></indexterm>

<para>A macro can be declared to accept a variable number of arguments much as
a function can.  The syntax for defining the macro is similar to that of
a function.  Here is an example:
</para>
<screen>#define eprintf(&#8230;) fprintf (stderr, __VA_ARGS__)
</screen>
<para>This kind of macro is called <firstterm>variadic</firstterm>.  When the macro is invoked,
all the tokens in its argument list after the last named argument (this
macro has none), including any commas, become the <firstterm>variable
argument</firstterm>.  This sequence of tokens replaces the identifier
<literal>__VA_ARGS__<!-- /@w --></literal> in the macro body wherever it appears.  Thus, we
have this expansion:
</para>
<screen>eprintf (&quot;%s:%d: &quot;, input_file, lineno)
     &#8614;  fprintf (stderr, &quot;%s:%d: &quot;, input_file, lineno)
</screen>
<para>The variable argument is completely macro-expanded before it is inserted
into the macro expansion, just like an ordinary argument.  You may use
the <literal>#</literal> and <literal>##</literal> operators to stringify the variable argument
or to paste its leading or trailing token with another token.  (But see
below for an important special case for <literal>##</literal>.)
</para>
<para><emphasis role="bold">Warning:</emphasis> don&#8217;t use the identifier <literal>__VA_ARGS__<!-- /@w --></literal>
for anything other than this.
</para>
<para>If your macro is complicated, you may want a more descriptive name for
the variable argument than <literal>__VA_ARGS__<!-- /@w --></literal>.  You can write an
argument name immediately before the &#8216;<literal>&#8230;</literal>&#8217;; that name is used
for the variable argument.<footnote><para>GNU C extension.</para></footnote>  The
<literal>eprintf</literal> macro above could be written thus:
</para>
<screen>#define eprintf(args&#8230;) fprintf (stderr, args)
</screen>
<para>A variadic macro can have named arguments as well as variable
arguments, so <literal>eprintf</literal> can be defined like this, instead:
</para>
<screen>#define eprintf(format, &#8230;) \
  fprintf (stderr, format, __VA_ARGS__)
</screen>
<para>This formulation is more descriptive, but what if you want to specify
a format string that takes no arguments?  In GNU C, you can omit the
comma before the variable arguments if they are empty, but that puts
an extra comma in the expansion:
</para>
<screen>eprintf (&quot;success!\n&quot;)
     &#8614; fprintf(stderr, &quot;success!\n&quot;, );
</screen>
<para>That&#8217;s an error in the call to <literal>fprintf</literal>.
</para>
<para>To get rid of that comma, the <literal>##</literal> token paste operator has a
special meaning when placed between a comma and a variable
argument.<footnote><para>GNU C extension.</para></footnote>  If you write
</para>
<screen>#define eprintf(format, &#8230;) \
  fprintf (stderr, format, ##__VA_ARGS__)
</screen>
<para>then use the macro <literal>eprintf</literal> with empty variable arguments,
<literal>##</literal> deletes the preceding comma.
</para>
<screen>eprintf (&quot;success!\n&quot;)
     &#8614; fprintf(stderr, &quot;success!\n&quot;);
</screen>
<para>This does <emphasis>not</emphasis> happen if you pass an empty argument, nor does it
happen if the token preceding <literal>##</literal> is anything other than a
comma.
</para>
<para>When the only macro parameter is a variable arguments parameter, and
the macro call has no argument at all, it is not obvious whether that
means an empty argument or a missing argument.  Should the comma be
kept, or deleted?  The C standard says to keep the comma, but the
preexisting GNU C extension deleted the comma.  Nowadays, GNU C
retains the comma when implementing a specific C standard, and deletes
it otherwise.
</para>
<para>C99 mandates that the only place the identifier <literal>__VA_ARGS__<!-- /@w --></literal>
can appear is in the replacement list of a variadic macro.  It may not
be used as a macro name, macro parameter name, or within a different
type of macro.  It may also be forbidden in open text; the standard is
ambiguous.  We recommend you avoid using that name except for its
special purpose.
</para>
<para>Variadic macros where you specify the parameter name is a GNU C
feature that has been supported for a long time.  Standard C, as of
C99, supports only the form where the parameter is called
<literal>__VA_ARGS__<!-- /@w --></literal>.  For portability to previous versions of GNU C
you should use only named variable argument parameters.  On the other
hand, for portability to other C99 compilers, you should use only
<literal>__VA_ARGS__<!-- /@w --></literal>.
</para>
</sect2>
<sect2 label="26.5.7" id="Predefined-Macros">
<title>Predefined Macros</title>
<indexterm role="cp"><primary>predefined macros</primary></indexterm>

<para>Several object-like macros are predefined; you use them without
supplying their definitions.  Here we explain the ones user programs
often need to use.  Many other macro names starting with &#8216;<literal>__</literal>&#8217; are
predefined; in general, you should not define such macro names
yourself.
</para>
<variablelist><varlistentry><term><literal>__FILE__</literal>
</term><listitem><para>This macro expands to the name of the current input file, in the form
of a C string constant.  This is the full name by which the GCC opened
the file, not the short name specified in <literal>#include</literal> or as the
input file name argument.  For example,
<literal>&quot;/usr/local/include/myheader.h&quot;</literal> is a possible expansion of this
macro.
</para>
</listitem></varlistentry><varlistentry><term><literal>__LINE__</literal>
</term><listitem><para>This macro expands to the current input line number, in the form of a
decimal integer constant.  While we call it a predefined macro, it&#8217;s
a pretty strange macro, since its &#8220;definition&#8221; changes with each
new line of source code.
</para>
</listitem></varlistentry><varlistentry><term><literal>__func__</literal>
</term><term><literal>__FUNCTION__</literal>
</term><listitem><para>These names are like variables that have as value a string containing
the name of the current function definition.  They are not really
macros, but this is the best place to mention them.
</para>
<para><literal>__FUNCTION__</literal> is the name that has been defined in GNU C since
time immemorial; <literal>__func__</literal> is defined by the C standard.
With the following conditionals, you can use whichever one is defined.
</para>
<screen>#if __STDC_VERSION__ &lt; 199901L
# if __GNUC__ &gt;= 2
#  define __func__ __FUNCTION__
# else
#  define __func__ &quot;&lt;unknown&gt;&quot;
# endif
#endif
</screen>
</listitem></varlistentry><varlistentry><term><literal>__PRETTY_FUNCTION__</literal>
</term><listitem><para>This is equivalent to <literal>__FUNCTION__</literal> in C, but in C<literal>++</literal>
the string includes argument type information as well.
It is a GNU C extension.
</para></listitem></varlistentry></variablelist>
<para>Those features are useful in generating an error message to report an
inconsistency detected by the program; the message can state the
source line where the inconsistency was detected.  For example,
</para>
<screen>fprintf (stderr, &quot;Internal error: &quot;
                 &quot;negative string length &quot;
                 &quot;in function %s &quot;
                 &quot;%d at %s, line %d.&quot;,
         __func__, length, __FILE__, __LINE__);
</screen>
<para>A <literal>#line</literal> directive changes <literal>__LINE__</literal>, and may change
<literal>__FILE__</literal> as well.  See <link linkend="Line-Control">Line Control</link>.
</para>
<variablelist><varlistentry><term><literal>__DATE__</literal>
</term><listitem><para>This macro expands to a string constant that describes the date of
compilation.  The string constant contains eleven characters and looks
like <literal>&quot;Feb 12 1996&quot;<!-- /@w --></literal>.  If the day of the month is just one
digit, an extra space precedes it so that the date is always eleven
characters.
</para>
<para>If the compiler cannot determine the current date, it emits a warning messages
(once per compilation) and <literal>__DATE__</literal> expands to
<literal>&quot;??? ?? ????&quot;<!-- /@w --></literal>.
</para>
<para>We deprecate the use of <literal>__DATE__</literal> for the sake of reproducible
compilation.
</para>
</listitem></varlistentry><varlistentry><term><literal>__TIME__</literal>
</term><listitem><para>This macro expands to a string constant that describes the time of
compilation.  The string constant contains eight characters and looks
like <literal>&quot;23:59:01&quot;</literal>.
</para>
<para>If the compiler cannot determine the current time, it emits a warning
message (once per compilation) and <literal>__TIME__</literal> expands to
<literal>&quot;??:??:??&quot;</literal>.
</para>
<para>We deprecate the use of <literal>__TIME__</literal> for the sake of reproducible
compilation.
</para>
</listitem></varlistentry><varlistentry><term><literal>__STDC__</literal>
</term><listitem><para>In normal operation, this macro expands to the constant 1, to signify
that this compiler implements ISO Standard C.
</para>
</listitem></varlistentry><varlistentry><term><literal>__STDC_VERSION__</literal>
</term><listitem><para>This macro expands to the C Standard&#8217;s version number, a long integer
constant of the form <literal><replaceable>yyyy</replaceable><replaceable>mm</replaceable>L</literal> where <replaceable>yyyy</replaceable> and
<replaceable>mm</replaceable> are the year and month of the Standard version.  This states
which version of the C Standard the compiler implements.
</para>
<para>The current default value is <literal>201112L</literal>, which signifies the C
2011 standard.
</para>
</listitem></varlistentry><varlistentry><term><literal>__STDC_HOSTED__</literal>
</term><listitem><para>This macro is defined, with value 1, if the compiler&#8217;s target is a
<firstterm>hosted environment</firstterm>.  A hosted environment provides the full
facilities of the standard C library.
</para></listitem></varlistentry></variablelist>
<para>The rest of the predefined macros are GNU C extensions.
</para>
<variablelist><varlistentry><term><literal>__COUNTER__</literal>
</term><listitem><para>This macro expands to sequential integral values starting from 0.  In
other words, each time the program uses this acro, it generates the
next successive integer.  This, with the <literal>##</literal> operator, provides
a convenient means for macros to generate unique identifiers.
</para>
</listitem></varlistentry><varlistentry><term><literal>__GNUC__</literal>
</term><term><literal>__GNUC_MINOR__</literal>
</term><term><literal>__GNUC_PATCHLEVEL__</literal>
</term><listitem><para>These macros expand to the major version, minor version, and patch
level of the compiler, as integer constants.  For example, GCC 3.2.1
expands <literal>__GNUC__</literal> to 3, <literal>__GNUC_MINOR__</literal> to 2, and
<literal>__GNUC_PATCHLEVEL__</literal> to 1.
</para>
<para>If all you need to know is whether or not your program is being
compiled by GCC, or a non-GCC compiler that claims to accept the GNU C
extensions, you can simply test <literal>__GNUC__</literal>.  If you need to write
code that depends on a specific version, you must check more
carefully.  Each change in the minor version resets the patch level to
zero; each change in the major version (which happens rarely) resets
the minor version and the patch level to zero.  To use the predefined
macros directly in the conditional, write it like this:
</para>
<screen>/* Test for version 3.2.0 or later. */
#if __GNUC__ &gt; 3 || \
    (__GNUC__ == 3 &amp;&amp; (__GNUC_MINOR__ &gt; 2 || \
                       (__GNUC_MINOR__ == 2 &amp;&amp; \
                        __GNUC_PATCHLEVEL__ &gt; 0))
</screen>
<para>Another approach is to use the predefined macros to
calculate a single number, then compare that against a threshold:
</para>
<screen>#define GCC_VERSION (__GNUC__ * 10000 \
                     + __GNUC_MINOR__ * 100 \
                     + __GNUC_PATCHLEVEL__)
/* &#8230; */
/* Test for GCC &gt; 3.2.0 */
#if GCC_VERSION &gt; 30200
</screen>
<para>Many people find this form easier to understand.
</para>
</listitem></varlistentry><varlistentry><term><literal>__VERSION__</literal>
</term><listitem><para>This macro expands to a string constant that describes the version of
the compiler in use.  You should not rely on its contents&#8217; having any
particular form, but you can count on it to contain at least the
release number.
</para>
</listitem></varlistentry><varlistentry><term><literal>__TIMESTAMP__</literal>
</term><listitem><para>This macro expands to a string constant that describes the date and
time of the last modification of the current source file. The string
constant contains abbreviated day of the week, month, day of the
month, time in hh:mm:ss form, and the year, in the format
<literal>&quot;Sun Sep 16 01:03:52 1973&quot;<!-- /@w --></literal>.  If the day of the month is
less than 10, it is padded with a space on the left.
</para>
<para>If GCC cannot determine that information date, it emits a warning
message (once per compilation) and <literal>__TIMESTAMP__</literal> expands to
<literal>&quot;??? ??? ?? ??:??:?? ????&quot;<!-- /@w --></literal>.
</para>
<para>We deprecate the use of this macro for the sake of reproducible
compilation.
</para></listitem></varlistentry></variablelist>
</sect2>
<sect2 label="26.5.8" id="Undefining-and-Redefining-Macros">
<title>Undefining and Redefining Macros</title>
<indexterm role="cp"><primary>undefining macros</primary></indexterm>
<indexterm role="cp"><primary>redefining macros</primary></indexterm>
<indexterm role="fn"><primary>#undef</primary></indexterm>

<para>You can <firstterm>undefine</firstterm> a macro with the <literal>#undef</literal> directive.
<literal>#undef</literal> takes a single argument, the name of the macro to
undefine.  You use the bare macro name, even if the macro is
function-like.  It is an error if anything appears on the line after
the macro name.  <literal>#undef</literal> has no effect if the name is not a
macro.
</para>
<screen>#define FOO 4
x = FOO;        &#8614; x = 4;
#undef FOO
x = FOO;        &#8614; x = FOO;
</screen>
<para>Once a macro has been undefined, that identifier may be <firstterm>redefined</firstterm>
as a macro by a subsequent <literal>#define</literal> directive.  The new definition
need not have any resemblance to the old definition.
</para>
<para>You can define a macro again without first undefining it only if
the new definition is <firstterm>effectively the same</firstterm> as the old one.
Two macro definitions are effectively the same if:
</para>
<itemizedlist><listitem><para>Both are the same type of macro (object- or function-like).
</para></listitem><listitem><para>All the tokens of the replacement list are the same.
</para></listitem><listitem><para>If there are any parameters, they are the same.
</para></listitem><listitem><para>Whitespace appears in the same places in both.  It need not be
exactly the same amount of whitespace, though.  Remember that comments
count as whitespace.
</para></listitem></itemizedlist>
<para>These definitions are effectively the same:
</para><screen>#define FOUR (2 + 2)
#define FOUR         (2    +    2)
#define FOUR (2 /* two */ + 2)
</screen><para>but these are not:
</para><screen>#define FOUR (2 + 2)
#define FOUR ( 2+2 )
#define FOUR (2 * 2)
#define FOUR(score,and,seven,years,ago) (2 + 2)
</screen>
<para>This allows two different header files to define a common macro.
</para>
<para>You can redefine an existing macro with #define, but redefining an
existing macro name with a different definition results in a warning.
</para>
</sect2>
<sect2 label="26.5.9" id="Directives-Within-Macro-Arguments">
<title>Directives Within Macro Arguments</title>
<indexterm role="cp"><primary>macro arguments and directives</primary></indexterm>

<para>GNU C permits and handles preprocessing directives in the text provided
as arguments for a macro.  That case is undefined in the C standard.
but in GNU C&#160;conditional directives in macro arguments
are clear and valid.
</para>
<para>A paradoxical case is to redefine a macro within the call to that same
macro.  What happens is, the new definition takes effect in time for
pre-expansion of <emphasis>all</emphasis> the arguments, then the original
definition is expanded to replace the call.  Here is a pathological
example:
</para>
<screen>#define f(x) x x
f (first f second
#undef f
#define f 2
f)
</screen>
<para>which expands to
</para>
<screen>first 2 second 2 first 2 second 2
</screen>
<para>with the semantics described above.  We suggest you avoid writing code
which does this sort of thing.
</para>
</sect2>
<sect2 label="26.5.10" id="Macro-Pitfalls">
<title>Macro Pitfalls</title>
<indexterm role="cp"><primary>problems with macros</primary></indexterm>
<indexterm role="cp"><primary>pitfalls of macros</primary></indexterm>

<para>In this section we describe some special rules that apply to macros and
macro expansion, and point out certain cases in which the rules have
counter-intuitive consequences that you must watch out for.
</para>

<sect3 label="26.5.10.1" id="Misnesting">
<title>Misnesting</title>

<para>When a macro is called with arguments, the arguments are substituted
into the macro body and the result is checked, together with the rest of
the input file, for more macro calls.  It is possible to piece together
a macro call coming partially from the macro body and partially from the
arguments.  For example,
</para>
<screen>#define twice(x) (2*(x))
#define call_with_1(x) x(1)
call_with_1 (twice)
     &#8614; twice(1)
     &#8614; (2*(1))
</screen>
<para>Macro definitions do not have to have balanced parentheses.  By writing
an unbalanced open parenthesis in a macro body, it is possible to create
a macro call that begins inside the macro body but ends outside of it.
For example,
</para>
<screen>#define strange(file) fprintf (file, &quot;%s %d&quot;,
/* &#8230; */
strange(stderr) p, 35)
     &#8614; fprintf (stderr, &quot;%s %d&quot;, p, 35)
</screen>
<para>The ability to piece together a macro call can be useful, but the use of
unbalanced open parentheses in a macro body is just confusing, and
should be avoided.
</para>
</sect3>
<sect3 label="26.5.10.2" id="Operator-Precedence-Problems">
<title>Operator Precedence Problems</title>
<indexterm role="cp"><primary>parentheses in macro bodies</primary></indexterm>

<para>You may have noticed that in most of the macro definition examples shown
above, each occurrence of a macro parameter name had parentheses around
it.  In addition, another pair of parentheses usually surrounds the
entire macro definition.  Here is why it is best to write macros that
way.
</para>
<para>Suppose you define a macro as follows,
</para>
<screen>#define ceil_div(x, y) (x + y - 1) / y
</screen>
<para>whose purpose is to divide, rounding up.  (One use for this operation is
to compute how many <literal>int</literal> objects are needed to hold a certain
number of <literal>char</literal> objects.)  Then suppose it is used as follows:
</para>
<screen>a = ceil_div (b &amp; c, sizeof (int));
     &#8614; a = (b &amp; c + sizeof (int) - 1) / sizeof (int);
</screen>
<para>This does not do what is intended.  The operator-precedence rules of
C make it equivalent to this:
</para>
<screen>a = (b &amp; (c + sizeof (int) - 1)) / sizeof (int);
</screen>
<para>What we want is this:
</para>
<screen>a = ((b &amp; c) + sizeof (int) - 1)) / sizeof (int);
</screen>
<para>Defining the macro as
</para>
<screen>#define ceil_div(x, y) ((x) + (y) - 1) / (y)
</screen>
<para>provides the desired result.
</para>
<para>Unintended grouping can result in another way.  Consider <literal>sizeof
ceil_div(1, 2)</literal>.  That has the appearance of a C expression that would
compute the size of the type of <literal>ceil_div (1, 2)</literal>, but in fact it
means something very different.  Here is what it expands to:
</para>
<screen>sizeof ((1) + (2) - 1) / (2)
</screen>
<para>This would take the size of an integer and divide it by two.  The
precedence rules have put the division outside the <literal>sizeof</literal> when it
was intended to be inside.
</para>
<para>Parentheses around the entire macro definition prevent such problems.
Here, then, is the recommended way to define <literal>ceil_div</literal>:
</para>
<screen>#define ceil_div(x, y) (((x) + (y) - 1) / (y))
</screen>
</sect3>
<sect3 label="26.5.10.3" id="Swallowing-the-Semicolon">
<title>Swallowing the Semicolon</title>
<indexterm role="cp"><primary>semicolons (after macro calls)</primary></indexterm>

<para>Often it is desirable to define a macro that expands into a compound
statement.  Consider, for example, the following macro, that advances a
pointer (the parameter <literal>p</literal> says where to find it) across whitespace
characters:
</para>
<screen>#define SKIP_SPACES(p, limit)  \
{ char *lim = (limit);         \
  while (p &lt; lim) {            \
    if (*p++ != ' ') {         \
      p--; break; }}}
</screen>
<para>Here backslash-newline is used to split the macro definition, which must
be a single logical line, so that it resembles the way such code would
be laid out if not part of a macro definition.
</para>
<para>A call to this macro might be <literal>SKIP_SPACES (p, lim)</literal>.  Strictly
speaking, the call expands to a compound statement, which is a complete
statement with no need for a semicolon to end it.  However, since it
looks like a function call, it minimizes confusion if you can use it
like a function call, writing a semicolon afterward, as in
<literal>SKIP_SPACES (p, lim);</literal>
</para>
<para>This can cause trouble before <literal>else</literal> statements, because the
semicolon is actually a null statement.  Suppose you write
</para>
<screen>if (*p != 0)
  SKIP_SPACES (p, lim);
else /* &#8230; */
</screen>
<para>The presence of two statements&#8212;the compound statement and a null
statement&#8212;in between the <literal>if</literal> condition and the <literal>else</literal>
makes invalid C code.
</para>
<para>The definition of the macro <literal>SKIP_SPACES</literal> can be altered to solve
this problem, using a <literal>do &#8230; while</literal> statement.  Here is how:
</para>
<screen>#define SKIP_SPACES(p, limit)     \
do { char *lim = (limit);         \
     while (p &lt; lim) {            \
       if (*p++ != ' ') {         \
         p--; break; }}}          \
while (0)
</screen>
<para>Now <literal>SKIP_SPACES (p, lim);</literal> expands into
</para>
<screen>do { /* &#8230; */ } while (0);
</screen>
<para>which is one statement.  The loop executes exactly once; most compilers
generate no extra code for it.
</para>
</sect3>
<sect3 label="26.5.10.4" id="Duplication-of-Side-Effects">
<title>Duplication of Side Effects</title>

<indexterm role="cp"><primary>side effects (in macro arguments)</primary></indexterm>
<indexterm role="cp"><primary>unsafe macros</primary></indexterm>
<para>Many C programs define a macro <literal>min</literal>, for &#8220;minimum&#8221;, like this:
</para>
<screen>#define min(X, Y)  ((X) &lt; (Y) ? (X) : (Y))
</screen>
<para>When you use this macro with an argument containing a side effect,
as shown here,
</para>
<screen>next = min (x + y, foo (z));
</screen>
<para>it expands as follows:
</para>
<screen>next = ((x + y) &lt; (foo (z)) ? (x + y) : (foo (z)));
</screen>
<para>where <literal>x + y</literal> has been substituted for <literal>X</literal> and <literal>foo (z)</literal>
for <literal>Y</literal>.
</para>
<para>The function <literal>foo</literal> is used only once in the statement as it
appears in the program, but the expression <literal>foo (z)</literal> has been
substituted twice into the macro expansion.  As a result, <literal>foo</literal>
might be called twice when the statement is executed.  If it has side
effects or if it takes a long time to compute, that may be
undesirable.  We say that <literal>min</literal> is an <firstterm>unsafe</firstterm> macro.
</para>
<para>The best solution to this problem is to define <literal>min</literal> in a way that
computes the value of <literal>foo (z)</literal> only once.  In general, that requires
using <literal>__auto_type</literal> (see <link linkend="Auto-Type">Auto Type</link>).  How to use it for this
is described in the following section.  See <link linkend="Macros-and-Auto-Type">Macros and Auto Type</link>.
</para>
<para>Otherwise, you will need to be careful when <emphasis>using</emphasis> the macro
<literal>min</literal>.  For example, you can calculate the value of <literal>foo
(z)</literal>, save it in a variable, and use that variable in <literal>min</literal>:
</para>
<screen>#define min(X, Y)  ((X) &lt; (Y) ? (X) : (Y))
/* &#8230; */
{
  int tem = foo (z);
  next = min (x + y, tem);
}
</screen>
<para>(where we assume that <literal>foo</literal> returns type <literal>int</literal>).
</para>
<para>When the repeated value appears as the condition of the <literal>?:</literal>
operator and again as its <replaceable>iftrue</replaceable> expression, you can avoid
repeated execution by omitting the <replaceable>iftrue</replaceable> expression, like this:
</para>
<screen>#define x_or_y(X, Y)  ((X) ? : (Y))
</screen>
<para>In GNU C, this expands to use the first macro argument&#8217;s value if that
isn&#8217;t zero.  If that&#8217;s zero, it compiles the second argument and uses
that value.  See <link linkend="Conditional-Expression">Conditional Expression</link>.
</para>
</sect3>
<sect3 label="26.5.10.5" id="Macros-and-Auto-Type">
<title>Using <literal>__auto_type</literal> for Local Variables</title>
<indexterm role="cp"><primary>local variables in macros</primary></indexterm>
<indexterm role="cp"><primary>variables, local, in macros</primary></indexterm>
<indexterm role="cp"><primary>macros, local variables in</primary></indexterm>

<para>The operator <literal>__auto_type</literal> makes it possible to
define macros that can work on any data type even though they need to
generate local variable declarations.  See <link linkend="Auto-Type">Auto Type</link>.
</para>
<para>For instance, here&#8217;s how to define a safe &#8220;maximum&#8221; macro that
operates on any arithmetic type and computes each of its arguments
exactly once:
</para>
<screen>#define max(a,b) \
  ({ __auto_type _a = (a); \
      __auto_type _b = (b); \
    _a &gt; _b ? _a : _b; })
</screen>
<para>The &#8216;<literal>({ &#8230; })</literal>&#8217; notation produces <firstterm>statement
expression</firstterm>&#8212;a statement that can be used as an expression
(see <link linkend="Statement-Exprs">Statement Exprs</link>).  Its value is the value of its last
statement.  This permits us to define local variables and store each
argument value into one.
</para>
<indexterm role="cp"><primary>underscores in variables in macros</primary></indexterm>
<indexterm role="cp"><primary>&#8216;<literal>_</literal>&#8217; in variables in macros</primary></indexterm>

<para>The reason for using names that start with underscores for the local
variables is to avoid conflicts with variable names that occur within
the expressions that are substituted for <literal>a</literal> and <literal>b</literal>.
Underscore followed by a lower case letter won&#8217;t be predefined by the
system in any way.
</para>
<!-- We hope someday to extend C with a new form of declaration syntax  -->
<!-- which all the newly declared variables' scopes would begin at the end -->
<!-- of the entire declaration, rather than as soon as each variable's -->
<!-- declaration begins.  This way, all the variables' initializers would -->
<!-- be interpreted in the context before the declaration.  Then we could -->
<!-- use any names whatsoever for the local variables and always get correct -->
<!-- behavior for the macro. -->

</sect3>
<sect3 label="26.5.10.6" id="Self_002dReferential-Macros">
<title>Self-Referential Macros</title>
<indexterm role="cp"><primary>self-reference</primary></indexterm>

<para>A <firstterm>self-referential</firstterm> macro is one whose name appears in its
definition.  Recall that all macro definitions are rescanned for more
macros to replace.  If the self-reference were considered a use of the
macro, it would produce an infinitely large expansion.  To prevent
this, the self-reference is not considered a macro call: preprocessing
leaves it unchanged.  Consider an example:
</para>
<screen>#define foo (4 + foo)
</screen>
<para>where <literal>foo</literal> is also a variable in your program.
</para>
<para>Following the ordinary rules, each reference to <literal>foo</literal> will expand
into <literal>(4 + foo)</literal>; then this will be rescanned and will expand into
<literal>(4 + (4 + foo))</literal>; and so on until the computer runs out of memory.
</para>
<para>The self-reference rule cuts this process short after one step, at
<literal>(4 + foo)</literal>.  Therefore, this macro definition has the possibly
useful effect of causing the program to add 4 to the value of <literal>foo</literal>
wherever <literal>foo</literal> is referred to.
</para>
<para>In most cases, it is a bad idea to take advantage of this feature.  A
person reading the program who sees that <literal>foo</literal> is a variable will
not expect that it is a macro as well.  The reader will come across the
identifier <literal>foo</literal> in the program and think its value should be that
of the variable <literal>foo</literal>, whereas in fact the value is four greater.
</para>
<para>It is useful to make a macro definition that expands to the macro
name itself.  If you write
</para>
<screen>#define EPERM EPERM
</screen>
<para>then the macro <literal>EPERM</literal> expands to <literal>EPERM</literal>.  Effectively,
preprocessing leaves it unchanged in the source code.  You can tell
that it&#8217;s a macro with <literal>#ifdef</literal>.  You might do this if you want
to define numeric constants with an <literal>enum</literal>, but have
<literal>#ifdef</literal> be true for each constant.
</para>
<para>If a macro <literal>x</literal> expands to use a macro <literal>y</literal>, and the expansion of
<literal>y</literal> refers to the macro <literal>x</literal>, that is an <firstterm>indirect
self-reference</firstterm> of <literal>x</literal>.  <literal>x</literal> is not expanded in this case
either.  Thus, if we have
</para>
<screen>#define x (4 + y)
#define y (2 * x)
</screen>
<para>then <literal>x</literal> and <literal>y</literal> expand as follows:
</para>
<screen>x    &#8614; (4 + y)
     &#8614; (4 + (2 * x))

y    &#8614; (2 * x)
     &#8614; (2 * (4 + y))
</screen>
<para>Each macro is expanded when it appears in the definition of the other
macro, but not when it indirectly appears in its own definition.
</para>
</sect3>
<sect3 label="26.5.10.7" id="Argument-Prescan">
<title>Argument Prescan</title>
<indexterm role="cp"><primary>expansion of arguments</primary></indexterm>
<indexterm role="cp"><primary>macro argument expansion</primary></indexterm>
<indexterm role="cp"><primary>prescan of macro arguments</primary></indexterm>

<para>Macro arguments are completely macro-expanded before they are
substituted into a macro body, unless they are stringified or pasted
with other tokens.  After substitution, the entire macro body, including
the substituted arguments, is scanned again for macros to be expanded.
The result is that the arguments are scanned <emphasis>twice</emphasis> to expand
macro calls in them.
</para>
<para>Most of the time, this has no effect.  If the argument contained any
macro calls, they were expanded during the first scan.  The result
therefore contains no macro calls, so the second scan does not change
it.  If the argument were substituted as given, with no prescan, the
single remaining scan would find the same macro calls and produce the
same results.
</para>
<para>You might expect the double scan to change the results when a
self-referential macro is used in an argument of another macro
(see <link linkend="Self_002dReferential-Macros">Self-Referential Macros</link>): the self-referential macro would be
expanded once in the first scan, and a second time in the second scan.
However, this is not what happens.  The self-references that do not
expand in the first scan are marked so that they will not expand in the
second scan either.
</para>
<para>You might wonder, &#8220;Why mention the prescan, if it makes no difference?
And why not skip it and make preprocessing go faster?&#8221;  The answer is
that the prescan does make a difference in three special cases:
</para>
<itemizedlist><listitem><para>Nested calls to a macro.
</para>
<para>We say that <firstterm>nested</firstterm> calls to a macro occur when a macro&#8217;s argument
contains a call to that very macro.  For example, if <literal>f</literal> is a macro
that expects one argument, <literal>f (f (1))</literal> is a nested pair of calls to
<literal>f</literal>.  The desired expansion is made by expanding <literal>f (1)</literal> and
substituting that into the definition of <literal>f</literal>.  The prescan causes
the expected result to happen.  Without the prescan, <literal>f (1)</literal> itself
would be substituted as an argument, and the inner use of <literal>f</literal> would
appear during the main scan as an indirect self-reference and would not
be expanded.
</para>
</listitem><listitem><para>Macros that call other macros that stringify or concatenate.
</para>
<para>If an argument is stringified or concatenated, the prescan does not
occur.  If you <emphasis>want</emphasis> to expand a macro, then stringify or
concatenate its expansion, you can do that by causing one macro to call
another macro that does the stringification or concatenation.  For
instance, if you have
</para>
<screen>#define AFTERX(x) X_ ## x
#define XAFTERX(x) AFTERX(x)
#define TABLESIZE 1024
#define BUFSIZE TABLESIZE
</screen>
<para>then <literal>AFTERX(BUFSIZE)</literal> expands to <literal>X_BUFSIZE</literal>, and
<literal>XAFTERX(BUFSIZE)</literal> expands to <literal>X_1024</literal>.  (Not to
<literal>X_TABLESIZE</literal>.  Prescan always does a complete expansion.)
</para>
</listitem><listitem><para>Macros used in arguments, whose expansions contain unshielded commas.
</para>
<para>This can cause a macro expanded on the second scan to be called with the
wrong number of arguments.  Here is an example:
</para>
<screen>#define foo  a,b
#define bar(x) lose(x)
#define lose(x) (1 + (x))
</screen>
<para>We would like <literal>bar(foo)</literal> to turn into <literal>(1 + (foo))</literal>, which
would then turn into <literal>(1 + (a,b))</literal>.  Instead, <literal>bar(foo)</literal>
expands into <literal>lose(a,b)</literal>, which gives an error because <literal>lose</literal>
requires a single argument.  In this case, the problem is easily solved
by the same parentheses that ought to be used to prevent misnesting of
arithmetic operations:
</para>
<screen>#define foo (a,b)
</screen><simpara>or</simpara>
<screen>#define bar(x) lose((x))
</screen>
<para>The extra pair of parentheses prevents the comma in <literal>foo</literal>&#8217;s
definition from being interpreted as an argument separator.
</para></listitem></itemizedlist>

</sect3>
</sect2>
</sect1>
<sect1 label="26.6" id="Conditionals">
<title>Conditionals</title>
<indexterm role="cp"><primary>conditionals</primary></indexterm>

<para>A <firstterm>conditional</firstterm> is a preprocessing directive that controls whether
or not to include a chunk of code in the final token stream that is
compiled.  Preprocessing conditionals can test arithmetic expressions,
or whether a name is defined as a macro, or both together using the
special <literal>defined</literal> operator.
</para>
<para>A preprocessing conditional in C resembles in some ways an <literal>if</literal>
statement in C, but it is important to understand the difference between
them.  The condition in an <literal>if</literal> statement is tested during the
execution of your program.  Its purpose is to allow your program to
behave differently from run to run, depending on the data it is
operating on.  The condition in a preprocessing conditional directive is
tested when your program is compiled.  Its purpose is to allow different
code to be included in the program depending on the situation at the
time of compilation.
</para>
<para>Sometimes this distinction makes no practical difference.  GCC and
other modern compilers often
do test <literal>if</literal> statements when a program is compiled, if their
conditions are known not to vary at run time, and eliminate code that
can never be executed.  If you can count on your compiler to do this,
you may find that your program is more readable if you use <literal>if</literal>
statements with constant conditions (perhaps determined by macros).  Of
course, you can only use this to exclude code, not type definitions or
other preprocessing directives, and you can only do it if the file
remains syntactically valid when that code is not used.
</para>

<sect2 label="26.6.1" id="Conditional-Uses">
<title>Uses of Conditional Directives</title>

<para>There are three usual reasons to use a preprocessing conditional.
</para>
<itemizedlist><listitem><para>A program may need to use different code depending on the machine or
operating system it is to run on.  In some cases the code for one
operating system may be erroneous on another operating system; for
example, it might refer to data types or constants that do not exist on
the other system.  When this happens, it is not enough to avoid
executing the invalid code.  Its mere presence will cause the compiler
to reject the program.  With a preprocessing conditional, the offending
code can be effectively excised from the program when it is not valid.
</para>
</listitem><listitem><para>You may want to be able to compile the same source file into two
different programs.  One version might make frequent time-consuming
consistency checks on its intermediate data, or print the values of
those data for debugging, and the other not.
</para>
</listitem><listitem><para>A conditional whose condition is always false is one way to exclude code
from the program but keep it as a sort of comment for future reference.
</para></listitem></itemizedlist>
<para>Simple programs that do not need system-specific logic or complex
debugging hooks generally will not need to use preprocessing
conditionals.
</para>
</sect2>
<sect2 label="26.6.2" id="Conditional-Syntax">
<title>Syntax of Preprocessing Conditionals</title>

<indexterm role="fn"><primary>#if</primary></indexterm>
<para>A preprocessing conditional begins with a <firstterm>conditional
directive</firstterm>: <literal>#if</literal>, <literal>#ifdef</literal> or <literal>#ifndef</literal>.
</para>

<sect3 label="26.6.2.1" id="ifdef">
<title>The <literal>#ifdef</literal> directive</title>
<indexterm role="fn"><primary>#ifdef</primary></indexterm>
<indexterm role="fn"><primary>#endif</primary></indexterm>

<para>The simplest sort of conditional is
</para>
<screen>#ifdef <replaceable>MACRO</replaceable>

<replaceable>controlled text</replaceable>

#endif /* <replaceable>MACRO</replaceable> */
</screen>
<indexterm role="cp"><primary>conditional group</primary></indexterm>
<para>This block is called a <firstterm>conditional group</firstterm>.  The body,
<replaceable>controlled text</replaceable>, will be included in compilation if
and only if <replaceable>MACRO</replaceable> is defined.  We say that the conditional
<firstterm>succeeds</firstterm> if <replaceable>MACRO</replaceable> is defined, <firstterm>fails</firstterm> if it is not.
</para>
<para>The <replaceable>controlled text</replaceable> inside a conditional can include
preprocessing directives.  They are executed only if the conditional
succeeds.  You can nest conditional groups inside other conditional
groups, but they must be completely nested.  In other words,
<literal>#endif</literal> always matches the nearest <literal>#ifdef</literal> (or
<literal>#ifndef</literal>, or <literal>#if</literal>).  Also, you cannot start a conditional
group in one file and end it in another.
</para>
<para>Even if a conditional fails, the <replaceable>controlled text</replaceable> inside it is
still run through initial transformations and tokenization.  Therefore,
it must all be lexically valid C.  Normally the only way this matters is
that all comments and string literals inside a failing conditional group
must still be properly ended.
</para>
<para>The comment following the <literal>#endif</literal> is not required, but it is a
good practice if there is a lot of <replaceable>controlled text</replaceable>, because it
helps people match the <literal>#endif</literal> to the corresponding <literal>#ifdef</literal>.
</para>
<para>Older programs sometimes put <replaceable>macro</replaceable> directly after the
<literal>#endif</literal> without enclosing it in a comment.  This is invalid code
according to the C standard, but it only causes a warning in GNU C.
It never affects which <literal>#ifndef</literal> the <literal>#endif</literal> matches.
</para>
<indexterm role="fn"><primary>#ifndef</primary></indexterm>
<para>Sometimes you wish to use some code if a macro is <emphasis>not</emphasis> defined.
You can do this by writing <literal>#ifndef</literal> instead of <literal>#ifdef</literal>.
One common use of <literal>#ifndef</literal> is to include code only the first
time a header file is included.  See <link linkend="Once_002dOnly-Headers">Once-Only Headers</link>.
</para>
<para>Macro definitions can vary between compilations for several reasons.
Here are some samples.
</para>
<itemizedlist><listitem><para>Some macros are predefined on each kind of machine
(see section &#8220;System-specific Predefined Macros&#8221; in <citetitle>Using the GNU Compiler
Collection</citetitle>).  This allows you to provide code specially tuned for a
particular machine.
</para>
</listitem><listitem><para>System header files define more macros, associated with the features
they implement.  You can test these macros with conditionals to avoid
using a system feature on a machine where it is not implemented.
</para>
</listitem><listitem><para>Macros can be defined or undefined with the <option>-D</option> and <option>-U</option>
command-line options when you compile the program.  You can arrange to
compile the same source file into two different programs by choosing a
macro name to specify which program you want, writing conditionals to
test whether or how this macro is defined, and then controlling the
state of the macro with command-line options, perhaps set in the
file <filename>Makefile</filename>.  See section &#8220;Invoking GCC&#8221; in <citetitle>Using the GNU Compiler Collection</citetitle>.
</para>
</listitem><listitem><para>Your program might have a special header file (often called
<filename>config.h</filename>) that is adjusted when the program is compiled.  It can
define or not define macros depending on the features of the system and
the desired capabilities of the program.  The adjustment can be
automated by a tool such as <command>autoconf</command>, or done by hand.
</para></listitem></itemizedlist>
</sect3>
<sect3 label="26.6.2.2" id="if">
<title>The <literal>#if</literal> directive</title>

<para>The <literal>#if</literal> directive allows you to test the value of an integer arithmetic
expression, rather than the mere existence of one macro.  Its syntax is
</para>
<screen>#if <replaceable>expression</replaceable>

<replaceable>controlled text</replaceable>

#endif /* <replaceable>expression</replaceable> */
</screen>
<para><replaceable>expression</replaceable> is a C expression of integer type, subject to
stringent restrictions so its value can be computed at compile time.
It may contain
</para>
<itemizedlist><listitem><para>Integer constants.
</para>
</listitem><listitem><para>Character constants, which are interpreted as they would be in normal
code.
</para>
</listitem><listitem><para>Arithmetic operators for addition, subtraction, multiplication,
division, bitwise operations, shifts, comparisons, and logical
operations (<literal>&amp;&amp;</literal> and <literal>||</literal>).  The latter two obey the usual
short-circuiting rules of standard C.
</para>
</listitem><listitem><para>Macros.  All macros in the expression are expanded before actual
computation of the expression&#8217;s value begins.
</para>
</listitem><listitem><para>Uses of the <literal>defined</literal> operator, which lets you check whether macros
are defined in the middle of an <literal>#if</literal>.
</para>
</listitem><listitem><para>Identifiers that are not macros, which are all considered to be the
number zero.  This allows you to write <literal>#if MACRO<!-- /@w --></literal> instead of
<literal>#ifdef MACRO<!-- /@w --></literal>, if you know that MACRO, when defined, will
always have a nonzero value.  Function-like macros used without their
function call parentheses are also treated as zero.
</para>
<para>In some contexts this shortcut is undesirable.  The <option>-Wundef</option>
requests warnings for any identifier in an <literal>#if</literal> that is not
defined as a macro.
</para></listitem></itemizedlist>
<para>Preprocessing does not know anything about the data types of C.
Therefore, <literal>sizeof</literal> operators are not recognized in <literal>#if</literal>;
<literal>sizeof</literal> is simply an identifier, and if it is not a macro, it
stands for zero.  This is likely to make the expression invalid.
Preprocessing does not recognize <literal>enum</literal> constants; they too are
simply identifiers, so if they are not macros, they stand for zero.
</para>
<para>Preprocessing calculates the value of <replaceable>expression</replaceable>, and carries
out all calculations in the widest integer type known to the compiler;
on most machines supported by GNU C this is 64 bits.  This is not the
same rule as the compiler uses to calculate the value of a constant
expression, and may give different results in some cases.  If the
value comes out to be nonzero, the <literal>#if</literal> succeeds and the
<replaceable>controlled text</replaceable> is compiled; otherwise it is skipped.
</para>
</sect3>
<sect3 label="26.6.2.3" id="defined">
<title>The <literal>defined</literal> test</title>

<indexterm role="cp"><primary><literal>defined</literal></primary></indexterm>
<para>The special operator <literal>defined</literal> is used in <literal>#if</literal> and
<literal>#elif</literal> expressions to test whether a certain name is defined as a
macro.  <literal>defined <replaceable>name</replaceable></literal> and <literal>defined (<replaceable>name</replaceable>)</literal> are
both expressions whose value is 1 if <replaceable>name</replaceable> is defined as a macro at
the current point in the program, and 0 otherwise.  Thus,  <literal>#if
defined MACRO<!-- /@w --></literal> is precisely equivalent to <literal>#ifdef MACRO<!-- /@w --></literal>.
</para>
<para><literal>defined</literal> is useful when you wish to test more than one macro for
existence at once.  For example,
</para>
<screen>#if defined (__arm__) || defined (__PPC__)
</screen>
<para>would succeed if either of the names <literal>__arm__</literal> or
<literal>__PPC__</literal> is defined as a macro&#8212;in other words,
when compiling for ARM processors or PowerPC processors.
</para>
<para>Conditionals written like this:
</para>
<screen>#if defined BUFSIZE &amp;&amp; BUFSIZE &gt;= 1024
</screen>
<para>can generally be simplified to just <literal>#if BUFSIZE &gt;= 1024<!-- /@w --></literal>,
since if <literal>BUFSIZE</literal> is not defined, it will be interpreted as having
the value zero.
</para>
<para>In GCC, you can include <literal>defined</literal> as part of another macro definition,
like this:
</para>
<screen>#define MACRO_DEFINED(X) defined X

#if MACRO_DEFINED(BUFSIZE)
</screen>
<para>which would expand the <literal>#if</literal> expression to:
</para>
<screen>#if defined BUFSIZE
</screen>
<para>Generating <literal>defined</literal> in this way is a GNU C extension.
</para>
</sect3>
<sect3 label="26.6.2.4" id="else">
<title>The <literal>#else</literal> directive</title>

<indexterm role="fn"><primary>#else</primary></indexterm>
<para>The <literal>#else</literal> directive can be added to a conditional to provide
alternative text to be used if the condition fails.  This is what it
looks like:
</para>
<screen>#if <replaceable>expression</replaceable>
<replaceable>text-if-true</replaceable>
#else /* Not <replaceable>expression</replaceable> */
<replaceable>text-if-false</replaceable>
#endif /* Not <replaceable>expression</replaceable> */
</screen>
<para>If <replaceable>expression</replaceable> is nonzero, the <replaceable>text-if-true</replaceable> is included and
the <replaceable>text-if-false</replaceable> is skipped.  If <replaceable>expression</replaceable> is zero, the
opposite happens.
</para>
<para>You can use <literal>#else</literal> with <literal>#ifdef</literal> and <literal>#ifndef</literal>, too.
</para>
</sect3>
<sect3 label="26.6.2.5" id="elif">
<title>The <literal>#elif</literal> directive</title>

<indexterm role="fn"><primary>#elif</primary></indexterm>
<para>One common case of nested conditionals is used to check for more than two
possible alternatives.  For example, you might have
</para>
<screen>#if X == 1
/* &#8230; */
#else /* X != 1 */
#if X == 2
/* &#8230; */
#else /* X != 2 */
/* &#8230; */
#endif /* X != 2 */
#endif /* X != 1 */
</screen>
<para>Another conditional directive, <literal>#elif</literal>, allows this to be
abbreviated as follows:
</para>
<screen>#if X == 1
/* &#8230; */
#elif X == 2
/* &#8230; */
#else /* X != 2 and X != 1*/
/* &#8230; */
#endif /* X != 2 and X != 1*/
</screen>
<para><literal>#elif</literal> stands for &#8220;else if&#8221;.  Like <literal>#else</literal>, it goes in the
middle of a conditional group and subdivides it; it does not require a
matching <literal>#endif</literal> of its own.  Like <literal>#if</literal>, the <literal>#elif</literal>
directive includes an expression to be tested.  The text following the
<literal>#elif</literal> is processed only if the original <literal>#if</literal>-condition
failed and the <literal>#elif</literal> condition succeeds.
</para>
<para>More than one <literal>#elif</literal> can go in the same conditional group.  Then
the text after each <literal>#elif</literal> is processed only if the <literal>#elif</literal>
condition succeeds after the original <literal>#if</literal> and all previous
<literal>#elif</literal> directives within it have failed.
</para>
<para><literal>#else</literal> is allowed after any number of <literal>#elif</literal> directives, but
<literal>#elif</literal> may not follow <literal>#else</literal>.
</para>
</sect3>
</sect2>
<sect2 label="26.6.3" id="Deleted-Code">
<title>Deleted Code</title>
<indexterm role="cp"><primary>commenting out code</primary></indexterm>

<para>If you replace or delete a part of the program but want to keep the
old code in the file for future reference, commenting it out is not so
straightforward in C.  Block comments do not nest, so the first
comment inside the old code will end the commenting-out.  The probable
result is a flood of syntax errors.
</para>
<para>One way to avoid this problem is to use an always-false conditional
instead.  For instance, put <literal>#if 0</literal> before the deleted code and
<literal>#endif</literal> after it.  This works even if the code being turned
off contains conditionals, but they must be entire conditionals
(balanced <literal>#if</literal> and <literal>#endif</literal>).
</para>
<para>Some people use <literal>#ifdef notdef</literal> instead.  This is risky, because
<literal>notdef</literal> might be accidentally defined as a macro, and then the
conditional would succeed.  <literal>#if 0</literal> can be counted on to fail.
</para>
<para>Do not use <literal>#if 0</literal> around text that is not C code.  Use a real
comment, instead.  The interior of <literal>#if 0</literal> must consist of complete
tokens; in particular, single-quote characters must balance.  Comments
often contain unbalanced single-quote characters (known in English as
apostrophes).  These confuse <literal>#if 0</literal>.  They don&#8217;t confuse
&#8216;<literal>/*</literal>&#8217;.
</para>
</sect2>
</sect1>
<sect1 label="26.7" id="Diagnostics">
<title>Diagnostics</title>
<indexterm role="cp"><primary>diagnostic</primary></indexterm>
<indexterm role="cp"><primary>reporting errors</primary></indexterm>
<indexterm role="cp"><primary>reporting warnings</primary></indexterm>

<indexterm role="fn"><primary>#error</primary></indexterm>
<para>The directive <literal>#error</literal> reports a fatal error.  The
tokens forming the rest of the line following <literal>#error</literal> are used
as the error message.
</para>
<para>The usual place to use <literal>#error</literal> is inside a conditional that
detects a combination of parameters that you know the program does not
properly support.  For example,
</para>
<screen>#if !defined(UNALIGNED_INT_ASM_OP) &amp;&amp; defined(DWARF2_DEBUGGING_INFO)
#error &quot;DWARF2_DEBUGGING_INFO requires UNALIGNED_INT_ASM_OP.&quot;
#endif
</screen>
<indexterm role="fn"><primary>#warning</primary></indexterm>
<para>The directive <literal>#warning</literal> is like <literal>#error</literal>, but it reports a
warning instead of an error.  The tokens following <literal>#warning</literal> are
used as the warning message.
</para>
<para>You might use <literal>#warning</literal> in obsolete header files, with a message
saying which header file to use instead.
</para>
<para>Neither <literal>#error</literal> nor <literal>#warning</literal> macro-expands its argument.
Internal whitespace sequences are each replaced with a single space.
The line must consist of complete tokens.  It is wisest to make the
argument of these directives be a single string constant; this avoids
problems with apostrophes and the like.
</para>
</sect1>
<sect1 label="26.8" id="Line-Control">
<title>Line Control</title>
<indexterm role="cp"><primary>line control</primary></indexterm>

<para>Due to C&#8217;s widespread availability and low-level nature, it is often
used as the target language for translation of other languages, or for
the output of lexical analyzers and parsers (e.g., lex/flex and
yacc/bison).  Line control enables the user to track diagnostics back
to the location in the original language.
</para>
<para>The C compiler knows the location in the source file where each token
came from: file name, starting line and column, and final line and column.
(Column numbers are used only for error messages.)
</para>
<para>When a program generates C source code, as the Bison parser generator
does, often it copies some of that C code from another file.  For
instance parts of the output from Bison are generated from scratch or
come from a standard parser file, but Bison copies the rest from
Bison&#8217;s input file.  Errors in that code, at compile time or run time,
should refer to that file, which is the real source code.  To make that happen,
Bison generates line-control directives that the C compiler understands.
</para>
<indexterm role="fn"><primary>#line</primary></indexterm>
<para><literal>#line</literal> is a directive that specifies the original line number
and source file name for subsequent code.  <literal>#line</literal> has three
variants:
</para>
<variablelist><varlistentry><term><literal>#line <replaceable>linenum</replaceable></literal>
</term><listitem><para><replaceable>linenum</replaceable> is a non-negative decimal integer constant.  It specifies
the line number that should be reported for the following line of
input.  Subsequent lines are counted from <replaceable>linenum</replaceable>.
</para>
</listitem></varlistentry><varlistentry><term><literal>#line <replaceable>linenum</replaceable> <replaceable>filename</replaceable></literal>
</term><listitem><para><replaceable>linenum</replaceable> is the same as for the first form, and has the same
effect.  In addition, <replaceable>filename</replaceable> is a string constant that
specifies the source file name.  Subsequent source lines are recorded
as coming from that file, until something else happens to change that.
<replaceable>filename</replaceable> is interpreted according to the normal rules for a
string constant.  Backslash escapes are interpreted, in contrast to
<literal>#include</literal>.
</para>
</listitem></varlistentry><varlistentry><term><literal>#line <replaceable>anything else</replaceable></literal>
</term><listitem><para><replaceable>anything else</replaceable> is checked for macro calls, which are expanded.
The result should match one of the above two forms.
</para></listitem></varlistentry></variablelist>
<para><literal>#line</literal> directives alter the results of the <literal>__FILE__</literal> and
<literal>__LINE__</literal> symbols from that point on.  See <link linkend="Predefined-Macros">Predefined Macros</link>.
</para>
</sect1>
<sect1 label="26.9" id="Null-Directive">
<title>Null Directive</title>

<indexterm role="cp"><primary>null directive</primary></indexterm>
<para>The <firstterm>null directive</firstterm> consists of a <literal>#</literal> followed by a newline,
with only whitespace and comments in between.  It has no
effect on the output of the compiler.
</para>


</sect1>
</chapter>
<chapter label="27" id="Integers-in-Depth">
<title>Integers in Depth</title>

<para>This chapter explains the machine-level details of integer types: how
they are represented as bits in memory, and the range of possible
values for each integer type.
</para>

<sect1 label="27.1" id="Integer-Representations">
<title>Integer Representations</title>

<indexterm role="cp"><primary>integer representations</primary></indexterm>
<indexterm role="cp"><primary>representation of integers</primary></indexterm>

<para>Modern computers store integer values as binary (base-2) numbers that
occupy a single unit of storage, typically either as an 8-bit
<literal>char</literal>, a 16-bit <literal>short int</literal>, a 32-bit <literal>int</literal>, or
possibly, a 64-bit <literal>long long int</literal>.  Whether a <literal>long int</literal> is
a 32-bit or a 64-bit value is system dependent.<footnote><para>In theory,
any of these types could have some other size, bit it&#8217;s not worth even
a minute to cater to that possibility.  It never happens on
GNU/Linux.</para></footnote>
</para>
<indexterm role="cp"><primary><literal>CHAR_BIT</literal></primary></indexterm>
<para>The macro <literal>CHAR_BIT</literal>, defined in <filename>limits.h</filename>, gives the number
of bits in type <literal>char</literal>.  On any real operating system, the value
is 8.
</para>
<para>The fixed sizes of numeric types necessarily limits their <firstterm>range
of values</firstterm>, and the particular encoding of integers decides what that
range is.
</para>
<indexterm role="cp"><primary>two&#8217;s-complement representation</primary></indexterm>
<para>For unsigned integers, the entire space is used to represent a
nonnegative value.  Signed integers are stored using
<firstterm>two&#8217;s-complement representation</firstterm>: a signed integer with <replaceable>n</replaceable>
bits has a range from <inlineequation><mathphrase>-2<superscript>(<replaceable>n</replaceable> - 1)</superscript></mathphrase></inlineequation> to &#8722;1 to 0
to 1 to <inlineequation><mathphrase>+2<superscript>(<replaceable>n</replaceable> - 1)</superscript> - 1</mathphrase></inlineequation>, inclusive.  The leftmost, or
high-order, bit is called the <firstterm>sign bit</firstterm>.
</para>
<!-- ??? Needs correcting -->

<para>There is only one value that means zero, and the most negative number
lacks a positive counterpart.  As a result, negating that number
causes overflow; in practice, its result is that number back again.
For example, a two&#8217;s-complement signed 8-bit integer can represent all
decimal numbers from &#8722;128 to +127.  We will revisit that
peculiarity shortly.
</para>
<para>Decades ago, there were computers that didn&#8217;t use two&#8217;s-complement
representation for integers (see <link linkend="Integers-in-Depth">Integers in Depth</link>), but they are
long gone and not worth any effort to support.
</para>
<!-- ??? Is this duplicate? -->

<para>When an arithmetic operation produces a value that is too big to
represent, the operation is said to <firstterm>overflow</firstterm>.  In C, integer
overflow does not interrupt the control flow or signal an error.
What it does depends on signedness.
</para>
<para>For unsigned arithmetic, the result of an operation that overflows is
the <replaceable>n</replaceable> low-order bits of the correct value.  If the correct value
is representable in <replaceable>n</replaceable> bits, that is always the result;
thus we often say that &#8220;integer arithmetic is exact,&#8221; omitting the
crucial qualifying phrase &#8220;as long as the exact result is
representable.&#8221;
</para>
<para>In principle, a C program should be written so that overflow never
occurs for signed integers, but in GNU C you can specify various ways
of handling such overflow (see <link linkend="Integer-Overflow">Integer Overflow</link>).
</para>
<para>Integer representations are best understood by looking at a table for
a tiny integer size; here are the possible values for an integer with
three bits:
</para>
<informaltable><tgroup cols="4"><colspec colwidth="25*"></colspec><colspec colwidth="25*"></colspec><colspec colwidth="25*"></colspec><colspec colwidth="25*"></colspec><thead><row><entry><para>Unsigned </para></entry><entry><para>Signed </para></entry><entry><para>Bits </para></entry><entry><para>2s Complement
</para></entry></row></thead><tbody><row><entry><para>0 </para></entry><entry><para>0 </para></entry><entry><para>000 </para></entry><entry><para>000 (0)
</para></entry></row><row><entry><para>1 </para></entry><entry><para>1 </para></entry><entry><para>001 </para></entry><entry><para>111 (-1)
</para></entry></row><row><entry><para>2 </para></entry><entry><para>2 </para></entry><entry><para>010 </para></entry><entry><para>110 (-2)
</para></entry></row><row><entry><para>3 </para></entry><entry><para>3 </para></entry><entry><para>011 </para></entry><entry><para>101 (-3)
</para></entry></row><row><entry><para>4 </para></entry><entry><para>-4 </para></entry><entry><para>100 </para></entry><entry><para>100 (-4)
</para></entry></row><row><entry><para>5 </para></entry><entry><para>-3 </para></entry><entry><para>101 </para></entry><entry><para>011 (3)
</para></entry></row><row><entry><para>6 </para></entry><entry><para>-2 </para></entry><entry><para>110 </para></entry><entry><para>010 (2)
</para></entry></row><row><entry><para>7 </para></entry><entry><para>-1 </para></entry><entry><para>111 </para></entry><entry><para>001 (1)
</para></entry></row></tbody></tgroup></informaltable>
<para>The parenthesized decimal numbers in the last column represent the
signed meanings of the two&#8217;s-complement of the line&#8217;s value.  Recall
that, in two&#8217;s-complement encoding, the high-order bit is 0 when
the number is nonnegative.
</para>
<para>We can now understand the peculiar behavior of negation of the
most negative two&#8217;s-complement integer: start with 0b100,
invert the bits to get 0b011, and add 1: we get
0b100, the value we started with.
</para>
<para>We can also see overflow behavior in two&#8217;s-complement:
</para>
<screen>3 + 1 = 0b011 + 0b001 = 0b100 = (-4)
3 + 2 = 0b011 + 0b010 = 0b101 = (-3)
3 + 3 = 0b011 + 0b011 = 0b110 = (-2)
</screen>
<para>A sum of two nonnegative signed values that overflows has a 1 in the
sign bit, so the exact positive result is truncated to a negative
value.
</para>
<!-- ===================================================================== -->

</sect1>
<sect1 label="27.2" id="Maximum-and-Minimum-Values">
<title>Maximum and Minimum Values</title>
<indexterm role="cp"><primary>maximum integer values</primary></indexterm>
<indexterm role="cp"><primary>minimum integer values</primary></indexterm>
<indexterm role="cp"><primary>integer ranges</primary></indexterm>
<indexterm role="cp"><primary>ranges of integer types</primary></indexterm>
<indexterm role="fn"><primary>INT_MAX</primary></indexterm>
<indexterm role="fn"><primary>UINT_MAX</primary></indexterm>
<indexterm role="fn"><primary>SHRT_MAX</primary></indexterm>
<indexterm role="fn"><primary>LONG_MAX</primary></indexterm>
<indexterm role="fn"><primary>LLONG_MAX</primary></indexterm>
<indexterm role="fn"><primary>USHRT_MAX</primary></indexterm>
<indexterm role="fn"><primary>ULONG_MAX</primary></indexterm>
<indexterm role="fn"><primary>ULLONG_MAX</primary></indexterm>
<indexterm role="fn"><primary>CHAR_MAX</primary></indexterm>
<indexterm role="fn"><primary>SCHAR_MAX</primary></indexterm>
<indexterm role="fn"><primary>UCHAR_MAX</primary></indexterm>

<para>For each primitive integer type, there is a standard macro defined in
<filename>limits.h</filename> that gives the largest value that type can hold.  For
instance, for type <literal>int</literal>, the maximum value is <literal>INT_MAX</literal>.
On a 32-bit computer, that is equal to 2,147,483,647.  The
maximum value for <literal>unsigned int</literal> is <literal>UINT_MAX</literal>, which on a
32-bit computer is equal to 4,294,967,295.  Likewise, there are
<literal>SHRT_MAX</literal>, <literal>LONG_MAX</literal>, and <literal>LLONG_MAX</literal>, and
corresponding unsigned limits <literal>USHRT_MAX</literal>, <literal>ULONG_MAX</literal>, and
<literal>ULLONG_MAX</literal>.
</para>
<para>Since there are three ways to specify a <literal>char</literal> type, there are
also three limits: <literal>CHAR_MAX</literal>, <literal>SCHAR_MAX</literal>, and
<literal>UCHAR_MAX</literal>.
</para>
<para>For each type that is or might be signed, there is another symbol that
gives the minimum value it can hold.  (Just replace <literal>MAX</literal> with
<literal>MIN</literal> in the names listed above.)  There is no minimum limit
symbol for types specified with <literal>unsigned</literal> because the
minimum for them is universally zero.
</para>
<para><literal>INT_MIN</literal> is not the negative of <literal>INT_MAX</literal>.  In
two&#8217;s-complement representation, the most negative number is 1 less
than the negative of the most positive number.  Thus, <literal>INT_MIN</literal>
on a 32-bit computer has the value &#8722;2,147,483,648.  You can&#8217;t
actually write the value that way in C, since it would overflow.
That&#8217;s a good reason to use <literal>INT_MIN</literal> to specify
that value.  Its definition is written to avoid overflow.
</para>

</sect1>
</chapter>
<chapter label="28" id="Floating-Point-in-Depth">
<title>Floating Point in Depth</title>


<sect1 label="28.1" id="Floating-Representations">
<title>Floating-Point Representations</title>
<indexterm role="cp"><primary>floating-point representations</primary></indexterm>
<indexterm role="cp"><primary>representation of floating-point numbers</primary></indexterm>

<indexterm role="cp"><primary>IEEE 754-2008 Standard</primary></indexterm>
<para>Storing numbers as <firstterm>floating point</firstterm> allows representation of
numbers with fractional values, in a range larger than that of
hardware integers.  A floating-point number consists of a sign bit, a
<firstterm>significand</firstterm> (also called the <firstterm>mantissa</firstterm>), and a power of a
fixed base.  GNU C uses the floating-point representations specified by
the <citetitle>IEEE 754-2008 Standard for Floating-Point Arithmetic</citetitle>.
</para>
<para>The IEEE 754-2008 specification defines basic binary floating-point
formats of five different sizes: 16-bit, 32-bit, 64-bit, 128-bit, and
256-bit.  The formats of 32, 64, and 128 bits are used for the
standard C types <literal>float</literal>, <literal>double</literal>, and <literal>long double</literal>.
GNU C supports the 16-bit floating point type <literal>_Float16</literal> on some
platforms, but does not support the 256-bit floating point type.
</para>
<para>Each of the formats encodes the floating-point number as a sign bit.
After this comes an exponent that specifies a power of 2 (with a fixed
offset).  Then comes the significand.
</para>
<para>The first bit of the significand, before the binary point, is always
1, so there is no need to store it in memory.  It is called the
<firstterm>hidden bit</firstterm> because it doesn&#8217;t appear in the floating-point
number as used in the computer itself.
</para>
<para>All of those floating-point formats are sign-magnitude representations,
so +0 and &#8722;0 are different values.
</para>
<para>Besides the IEEE 754 format 128-bit float, GNU C also offers a format
consisting of a pair of 64-bit floating point numbers.  This lacks the
full exponent range of the IEEE 128-bit format, but is useful when the
underlying hardware platform does not support that.
</para>
</sect1>
<sect1 label="28.2" id="Floating-Type-Specs">
<title>Floating-Point Type Specifications</title>

<para>The standard library header file <filename>float.h</filename> defines a number of
constants that describe the platform&#8217;s implementation of
floating-point types <literal>float</literal>, <literal>double</literal> and <literal>long
double</literal>.  They include:
</para>
<indexterm role="fn"><primary>FLT_MIN</primary></indexterm>
<indexterm role="fn"><primary>DBL_MIN</primary></indexterm>
<indexterm role="fn"><primary>LDBL_MIN</primary></indexterm>
<indexterm role="fn"><primary>FLT_HAS_SUBNORM</primary></indexterm>
<indexterm role="fn"><primary>DBL_HAS_SUBNORM</primary></indexterm>
<indexterm role="fn"><primary>LDBL_HAS_SUBNORM</primary></indexterm>
<indexterm role="fn"><primary>FLT_TRUE_MIN</primary></indexterm>
<indexterm role="fn"><primary>DBL_TRUE_MIN</primary></indexterm>
<indexterm role="fn"><primary>LDBL_TRUE_MIN</primary></indexterm>
<indexterm role="fn"><primary>FLT_MAX</primary></indexterm>
<indexterm role="fn"><primary>DBL_MAX</primary></indexterm>
<indexterm role="fn"><primary>LDBL_MAX</primary></indexterm>
<indexterm role="fn"><primary>FLT_DECIMAL_DIG</primary></indexterm>
<indexterm role="fn"><primary>DBL_DECIMAL_DIG</primary></indexterm>
<indexterm role="fn"><primary>LDBL_DECIMAL_DIG</primary></indexterm>

<variablelist><varlistentry><term><literal>FLT_MIN</literal>
</term><term><literal>DBL_MIN</literal>
</term><term><literal>LDBL_MIN</literal>
</term><listitem><para>Defines the minimum normalized positive floating-point values that can
be represented with the type.
</para>
</listitem></varlistentry><varlistentry><term><literal>FLT_HAS_SUBNORM</literal>
</term><term><literal>DBL_HAS_SUBNORM</literal>
</term><term><literal>LDBL_HAS_SUBNORM</literal>
</term><listitem><para>Defines if the floating-point type supports subnormal (or &#8220;denormalized&#8221;)
numbers or not (see <link linkend="subnormal-numbers">subnormal numbers</link>).
</para>
</listitem></varlistentry><varlistentry><term><literal>FLT_TRUE_MIN</literal>
</term><term><literal>DBL_TRUE_MIN</literal>
</term><term><literal>LDBL_TRUE_MIN</literal>
</term><listitem><para>Defines the minimum positive values (including subnormal values) that
can be represented with the type.
</para>
</listitem></varlistentry><varlistentry><term><literal>FLT_MAX</literal>
</term><term><literal>DBL_MAX</literal>
</term><term><literal>LDBL_MAX</literal>
</term><listitem><para>Defines the largest values that can be represented with the type.
</para>
</listitem></varlistentry><varlistentry><term><literal>FLT_DECIMAL_DIG</literal>
</term><term><literal>DBL_DECIMAL_DIG</literal>
</term><term><literal>LDBL_DECIMAL_DIG</literal>
</term><listitem><para>Defines the number of decimal digits <literal>n</literal> such that any
floating-point number that can be represented in the type can be
rounded to a floating-point number with <literal>n</literal> decimal digits, and
back again, without losing any precision of the value.
</para></listitem></varlistentry></variablelist>
</sect1>
<sect1 label="28.3" id="Special-Float-Values">
<title>Special Floating-Point Values</title>
<indexterm role="cp"><primary>special floating-point values</primary></indexterm>
<indexterm role="cp"><primary>floating-point values, special</primary></indexterm>

<para>IEEE floating point provides for special values that are not ordinary
numbers.
</para>
<variablelist>
<varlistentry><term>infinities
</term><listitem><para><literal>+Infinity</literal> and <literal>-Infinity</literal> are two different infinite
values, one positive and one negative.  These result from
operations such as <literal>1 / 0</literal>, <literal>Infinity + Infinity</literal>,
<literal>Infinity * Infinity</literal>, and <literal>Infinity + <replaceable>finite</replaceable></literal>, and also
from a result that is finite, but larger than the most positive possible
value or smaller than the most negative possible value.
</para>
<para>See <link linkend="Handling-Infinity">Handling Infinity</link>, for more about working with infinities.
</para>
</listitem></varlistentry><varlistentry><term>NaNs (not a number)
</term><listitem><indexterm role="cp"><primary>QNaN</primary></indexterm>
<indexterm role="cp"><primary>SNaN</primary></indexterm>
<para>There are two special values, called Not-a-Number (NaN): a quiet
NaN (QNaN), and a signaling NaN (SNaN).
</para>
<para>A QNaN is produced by operations for which the value is undefined
in real arithmetic, such as <literal>0 / 0</literal>, <literal>sqrt (-1)</literal>,
<literal>Infinity - Infinity</literal>, and any basic operation in which an
operand is a QNaN.
</para>
<para>The signaling NaN is intended for initializing
otherwise-unassigned storage, and the goal is that unlike a
QNaN, an SNaN <emphasis>does</emphasis> cause an interrupt that can be caught
by a software handler, diagnosed, and reported.  In practice,
little use has been made of signaling NaNs, because the most
common CPUs in desktop and portable computers fail to implement
the full IEEE 754 Standard, and supply only one kind of NaN, the
quiet one.  Also, programming-language standards have taken
decades to catch up to the IEEE 754 standard, and implementations
of those language standards make an additional delay before
programmers become willing to use these features.
</para>
<para>To enable support for signaling NaNs, use the GCC command-line option
<option>-fsignaling-nans</option>, but this is an experimental feature and may
not work as expected in every situation.
</para>
<para>A NaN has a sign bit, but its value means nothing.
</para>
<para>See <link linkend="Handling-NaN">Handling NaN</link>, for more about working with NaNs.
</para>
</listitem></varlistentry><varlistentry><term>subnormal numbers
</term><listitem><indexterm role="cp"><primary>subnormal numbers</primary></indexterm>
<indexterm role="cp"><primary>underflow, floating</primary></indexterm>
<indexterm role="cp"><primary>floating underflow</primary></indexterm>
<anchor id="subnormal-numbers"/><para>It can happen that a computed floating-point value is too small to
represent, such as when two tiny numbers are multiplied.  The result
is then said to <firstterm>underflow</firstterm>.  The traditional behavior before
the IEEE 754 Standard was to use zero as the result, and possibly to report
the underflow in some sort of program output.
</para>
<para>The IEEE 754 Standard is vague about whether rounding happens
before detection of floating underflow and overflow, or after, and CPU
designers may choose either.
</para>
<para>However, the Standard does something unusual compared to earlier
designs, and that is that when the result is smaller than the
smallest <firstterm>normalized</firstterm> representable value (i.e., one in
which the leading significand bit is <literal>1</literal>), the normalization
requirement is relaxed, leading zero bits are permitted, and
precision is gradually lost until there are no more bits in the
significand.  That phenomenon is called <firstterm>gradual underflow</firstterm>,
and it serves important numerical purposes, although it does
reduce the precision of the final result.  Some floating-point
designs allow you to choose at compile time, or even at
run time, whether underflows are gradual, or are flushed abruptly
to zero.  Numbers that have entered the region of gradual
underflow are called <firstterm>subnormal</firstterm>.
</para>
<para>You can use the library functions <literal>fesetround</literal> and
<literal>fegetround</literal> to set and get the rounding mode.  Rounding modes
are defined (if supported by the platform) in <literal>fenv.h</literal> as:
<literal>FE_UPWARD</literal> to round toward positive infinity; <literal>FE_DOWNWARD</literal>
to round toward negative infinity; <literal>FE_TOWARDZERO</literal> to round
toward zero; and <literal>FE_TONEAREST</literal> to round to the nearest
representable value, the default mode.  It is best to use
<literal>FE_TONEAREST</literal> except when there is a special need for some other
mode.
</para></listitem></varlistentry></variablelist>
</sect1>
<sect1 label="28.4" id="Invalid-Optimizations">
<title>Invalid Optimizations</title>
<indexterm role="cp"><primary>invalid optimizations in floating-point arithmetic</primary></indexterm>
<indexterm role="cp"><primary>floating-point arithmetic invalid optimizations</primary></indexterm>

<para>Signed zeros, Infinity, and NaN invalidate some optimizations by
programmers and compilers that might otherwise have seemed obvious:
</para>
<itemizedlist><listitem><para><literal>x + 0</literal> and <literal>x - 0</literal> are not the same as <literal>x</literal> when
<literal>x</literal> is zero, because the result depends on the rounding rule.
See <link linkend="Rounding">Rounding</link>, for more about rounding rules.
</para>
</listitem><listitem><para><literal>x * 0.0</literal> is not the same as <literal>0.0</literal> when <literal>x</literal> is
Infinity, a NaN, or negative zero.
</para>
</listitem><listitem><para><literal>x / x</literal> is not the same as <literal>1.0</literal> when <literal>x</literal> is Infinity,
a NaN, or zero.
</para>
</listitem><listitem><para><literal>(x - y)</literal> is not the same as <literal>-(y - x)</literal> because when the
operands are finite and equal, one evaluates to <literal>+0</literal> and the
other to <literal>-0</literal>.
</para>
</listitem><listitem><para><literal>x - x</literal> is not the same as <literal>0.0</literal> when <replaceable>x</replaceable> is Infinity or
a NaN.
</para>
</listitem><listitem><para><literal>x == x</literal> and <literal>x != x</literal> are not equivalent to <literal>1</literal> and
<literal>0</literal> when <replaceable>x</replaceable> is a NaN.
</para>
</listitem><listitem><para><literal>x &lt; y</literal> and <literal>isless (x, y)</literal> are not equivalent, because the
first sets a sticky exception flag (see <link linkend="Exception-Flags">Exception Flags</link>) when an
operand is a NaN, whereas the second does not affect that flag.  The
same holds for the other <literal>isxxx</literal> functions that are companions to
relational operators.  See section &#8220;FP Comparison Functions&#8221; in <citetitle>The
GNU C Library Reference Manual</citetitle>.
</para>
</listitem></itemizedlist>
<para>The <option>-funsafe-math-optimizations</option> option enables
these optimizations.
</para>

</sect1>
<sect1 label="28.5" id="Exception-Flags">
<title>Floating Arithmetic Exception Flags</title>
<indexterm role="cp"><primary>floating arithmetic exception flags</primary></indexterm>
<indexterm role="cp"><primary>exception flags (floating point)</primary></indexterm>
<indexterm role="cp"><primary>sticky exception flags (floating point)</primary></indexterm>
<indexterm role="cp"><primary>floating overflow</primary></indexterm>
<indexterm role="cp"><primary>overflow, floating</primary></indexterm>
<indexterm role="cp"><primary>floating underflow</primary></indexterm>
<indexterm role="cp"><primary>underflow, floating</primary></indexterm>

<para><firstterm>Sticky exception flags</firstterm> record the occurrence of particular
conditions: once set, they remain set until the program explicitly
clears them.
</para>
<para>The conditions include <emphasis>invalid operand</emphasis>,
<emphasis>division-by_zero</emphasis>, <emphasis>inexact result</emphasis> (i.e., one that
required rounding), <emphasis>underflow</emphasis>, and <emphasis>overflow</emphasis>.  Some
extended floating-point designs offer several additional exception
flags.  The functions <literal>feclearexcept</literal>, <literal>feraiseexcept</literal>,
<literal>fetestexcept</literal>, <literal>fegetexceptflags</literal>, and
<literal>fesetexceptflags</literal> provide a standardized interface to those
flags.  See section &#8220;Status bit operations&#8221; in <citetitle>The GNU C Library
Reference Manual</citetitle>.
</para>
<para>One important use of those <anchor id="fetestexcept"/>flags is to do a
computation that is normally expected to be exact in floating-point
arithmetic, but occasionally might not be, in which case, corrective
action is needed.  You can clear the <emphasis>inexact result</emphasis> flag with a
call to <literal>feclearexcept (FE_INEXACT)</literal>, do the computation, and
then test the flag with <literal>fetestexcept (FE_INEXACT)</literal>; the result
of that call is 0 if the flag is not set (there was no rounding), and
1 when there was rounding (which, we presume, implies the program has
to correct for that).
</para>
<!-- ===================================================================== -->


</sect1>
<sect1 label="28.6" id="Exact-Floating_002dPoint">
<title>Exact Floating-Point Arithmetic</title>
<indexterm role="cp"><primary>exact floating-point arithmetic</primary></indexterm>
<indexterm role="cp"><primary>floating-point arithmetic, exact</primary></indexterm>

<para>As long as the numbers are exactly representable (fractions whose
denominator is a power of 2), and intermediate results do not require
rounding, then floating-point arithmetic is <emphasis>exact</emphasis>.  It is easy
to predict how many digits are needed for the results of arithmetic
operations:
</para>
<itemizedlist>
<listitem><para>addition and subtraction of two <replaceable>n</replaceable>-digit values with the
<emphasis>same</emphasis> exponent require at most <literal><replaceable>n</replaceable> + 1</literal> digits, but
when the exponents differ, many more digits may be needed;
</para>
</listitem><listitem><para>multiplication of two <replaceable>n</replaceable>-digit values requires exactly
2 <replaceable>n</replaceable> digits;
</para>
</listitem><listitem><para>although integer division produces a quotient and a remainder of
no more than <replaceable>n</replaceable>-digits, floating-point remainder and square
root may require an unbounded number of digits, and the quotient
can need many more digits than can be stored.
</para>
</listitem></itemizedlist>
<para>Whenever a result requires more than <replaceable>n</replaceable> digits, rounding
is needed.
</para>
<!-- ===================================================================== -->

</sect1>
<sect1 label="28.7" id="Rounding">
<title>Rounding</title>
<indexterm role="cp"><primary>rounding</primary></indexterm>

<para>When floating-point arithmetic produces a result that can&#8217;t fit
exactly in the significand of the type that&#8217;s in use, it has to
<firstterm>round</firstterm> the value.  The basic arithmetic operations&#8212;addition,
subtraction, multiplication, division, and square root&#8212;always produce
a result that is equivalent to the exact, possibly infinite-precision
result rounded to storage precision according to the current rounding
rule.
</para>
<para>Rounding sets the <literal>FE_INEXACT</literal> exception flag (see <link linkend="Exception-Flags">Exception
Flags</link>).  This enables programs to determine that rounding has
occurred.
</para>
<para>Rounding consists of adjusting the exponent to bring the significand
back to the required base-point alignment, then applying the current
<firstterm>rounding rule</firstterm> to squeeze the significand into the fixed
available size.
</para>
<para>The current rule is selected at run time from four options.  Here they
are:
</para>
<itemizedlist><listitem><para>* <emphasis>round-to-nearest</emphasis>, with ties rounded to an even integer;
</para>
</listitem><listitem><para>* <emphasis>round-up</emphasis>, towards <literal>+Infinity</literal>;
</para>
</listitem><listitem><para>* <emphasis>round-down</emphasis>, towards <literal>-Infinity</literal>;
</para>
</listitem><listitem><para>* <emphasis>round-towards-zero</emphasis>.
</para></listitem></itemizedlist>
<para>Under those four rounding rules, a decimal value
<literal>-1.2345</literal> that is to be rounded to a four-digit result would
become <literal>-1.234</literal>, <literal>-1.234</literal>, <literal>-1.235</literal>, and
<literal>-1.234</literal>, respectively.
</para>
<para>The default rounding rule is <emphasis>round-to-nearest</emphasis>, because that has
the least bias, and produces the lowest average error.  When the true
result lies exactly halfway between two representable machine numbers,
the result is rounded to the one that ends with an even digit.
</para>
<para>The <emphasis>round-towards-zero</emphasis> rule was common on many early computer
designs, because it is the easiest to implement: it just requires
silent truncation of all extra bits.
</para>
<para>The two other rules, <emphasis>round-up</emphasis> and <emphasis>round-down</emphasis>, are
essential for implementing <firstterm>interval arithmetic</firstterm>, whereby
each arithmetic operation produces lower and upper bounds that
are guaranteed to enclose the exact result.
</para>
<para>See <link linkend="Rounding-Control">Rounding Control</link>, for details on getting and setting the
current rounding mode.
</para>
</sect1>
<sect1 label="28.8" id="Rounding-Issues">
<title>Rounding Issues</title>
<indexterm role="cp"><primary>rounding issues (floating point)</primary></indexterm>
<indexterm role="cp"><primary>floating-point rounding issues</primary></indexterm>

<para>The default IEEE 754 rounding mode minimizes errors, and most
normal computations should not suffer any serious accumulation of
errors from rounding.
</para>
<para>Of course, you can contrive examples where that is not so.  Here
is one: iterate a square root, then attempt to recover the
original value by repeated squaring.
</para>
<screen>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main (void)
{
  double x = 100.0;
  double y;
  for (n = 10; n &lt;= 100; n += 10)
    {
      y = x;
      for (k = 0; k &lt; n; ++k) y = sqrt (y);
      for (k = 0; k &lt; n; ++k) y *= y;
      printf (&quot;n = %3d; x = %.0f\ty = %.6f\n&quot;, n, x, y);
    }
  return 0;
}
</screen>
<para>Here is the output:
</para>
<screen>n =  10; x = 100        y = 100.000000
n =  20; x = 100        y = 100.000000
n =  30; x = 100        y = 99.999977
n =  40; x = 100        y = 99.981025
n =  50; x = 100        y = 90.017127
n =  60; x = 100        y = 1.000000
n =  70; x = 100        y = 1.000000
n =  80; x = 100        y = 1.000000
n =  90; x = 100        y = 1.000000
n = 100; x = 100        y = 1.000000
</screen>
<para>After 50 iterations, <literal>y</literal> has barely one correct digit, and
soon after, there are no correct digits.
</para>
<!-- ===================================================================== -->

</sect1>
<sect1 label="28.9" id="Significance-Loss">
<title>Significance Loss</title>
<indexterm role="cp"><primary>significance loss (floating point)</primary></indexterm>
<indexterm role="cp"><primary>floating-point significance loss</primary></indexterm>

<para>A much more serious source of error in floating-point computation is
<firstterm>significance loss</firstterm> from subtraction of nearly equal values.  This
means that the number of bits in the significand of the result is
fewer than the size of the value would permit.  If the values being
subtracted are close enough, but still not equal, a <emphasis>single
subtraction</emphasis> can wipe out all correct digits, possibly contaminating
all future computations.
</para>
<para>Floating-point calculations can sometimes be carefully designed so
that significance loss is not possible, such as summing a series where
all terms have the same sign.  For example, the Taylor series
expansions of the trigonometric and hyperbolic sines have terms of
identical magnitude, of the general form <literal><replaceable>x</replaceable>**(2*<replaceable>n</replaceable> +
1) / (2*<replaceable>n</replaceable> + 1)!</literal>.  However, those in the trigonometric sine series
alternate in sign, while those in the hyperbolic sine series are all
positive.  Here is the output of two small programs that sum <replaceable>k</replaceable>
terms of the series for <literal>sin (<replaceable>x</replaceable>)</literal>, and compare the computed
sums with known-to-be-accurate library functions:
</para>
<screen>x = 10      k = 51
s (x)   = -0.544_021_110_889_270
sin (x) = -0.544_021_110_889_370

x = 20      k = 81
s (x)   = 0.912_945_250_749_573
sin (x) = 0.912_945_250_727_628

x = 30      k = 109
s (x)   = -0.987_813_746_058_855
sin (x) = -0.988_031_624_092_862

x = 40      k = 137
s (x)   = 0.617_400_430_980_474
sin (x) = 0.745_113_160_479_349

x = 50      k = 159
s (x)   = 57_105.187_673_745_720_532
sin (x) = -0.262_374_853_703_929

// sinh(x) series summation with positive signs
// with k terms needed to converge to machine precision

x = 10      k = 47
t (x)    = 1.101_323_287_470_340e+04
sinh (x) = 1.101_323_287_470_339e+04

x = 20      k = 69
t (x)    = 2.425_825_977_048_951e+08
sinh (x) = 2.425_825_977_048_951e+08

x = 30      k = 87
t (x)    = 5.343_237_290_762_229e+12
sinh (x) = 5.343_237_290_762_231e+12

x = 40      k = 105
t (x)    = 1.176_926_334_185_100e+17
sinh (x) = 1.176_926_334_185_100e+17

x = 50      k = 121
t (x)    = 2.592_352_764_293_534e+21
sinh (x) = 2.592_352_764_293_536e+21
</screen>
<para>We have added underscores to the numbers to enhance readability.
</para>
<para>The <literal>sinh (<replaceable>x</replaceable>)</literal> series with positive terms can be summed to
high accuracy.  By contrast, the series for <literal>sin (<replaceable>x</replaceable>)</literal>
suffers increasing significance loss, so that when <replaceable>x</replaceable> = 30 only
two correct digits remain.  Soon after, all digits are wrong, and the
answers are complete nonsense.
</para>
<para>An important skill in numerical programming is to recognize when
significance loss is likely to contaminate a computation, and revise
the algorithm to reduce this problem.  Sometimes, the only practical
way to do so is to compute in higher intermediate precision, which is
why the extended types like <literal>long double</literal> are important.
</para>
<!-- Formerly mentioned @code{__float128} -->

<!-- ===================================================================== -->

</sect1>
<sect1 label="28.10" id="Fused-Multiply_002dAdd">
<title>Fused Multiply-Add</title>
<indexterm role="cp"><primary>fused multiply-add in floating-point computations</primary></indexterm>
<indexterm role="cp"><primary>floating-point fused multiply-add</primary></indexterm>

<para>In 1990, when IBM introduced the POWER architecture, the CPU
provided a previously unknown instruction, the <firstterm>fused
multiply-add</firstterm> (FMA).  It computes the value <literal>x * y + z</literal> with
an <emphasis role="bold">exact</emphasis> double-length product, followed by an addition with a
<emphasis>single</emphasis> rounding.  Numerical computation often needs pairs of
multiply and add operations, for which the FMA is well-suited.
</para>
<para>On the POWER architecture, there are two dedicated registers that
hold permanent values of <literal>0.0</literal> and <literal>1.0</literal>, and the
normal <emphasis>multiply</emphasis> and <emphasis>add</emphasis> instructions are just
wrappers around the FMA that compute <literal>x * y + 0.0</literal> and
<literal>x * 1.0 + z</literal>, respectively.
</para>
<para>In the early days, it appeared that the main benefit of the FMA
was getting two floating-point operations for the price of one,
almost doubling the performance of some algorithms.  However,
numerical analysts have since shown numerous uses of the FMA for
significantly enhancing accuracy.  We discuss one of the most
important ones in the next section.
</para>
<para>A few other architectures have since included the FMA, and most
provide variants for the related operations <literal>x * y - z</literal>
(FMS), <literal>-x * y + z</literal> (FNMA), and <literal>-x * y - z</literal> (FNMS).
<!-- The IEEE 754-2008 revision requires implementations to provide -->
<!-- the FMA, as a sixth basic operation. -->
</para>
<para>The functions <literal>fmaf</literal>, <literal>fma</literal>, and <literal>fmal</literal> implement fused
multiply-add for the <literal>float</literal>, <literal>double</literal>, and <literal>long
double</literal> data types.  Correct implementation of the FMA in software is
difficult, and some systems that appear to provide those functions do
not satisfy the single-rounding requirement.  That situation should
change as more programmers use the FMA operation, and more CPUs
provide FMA in hardware.
</para>
<para>Use the <option>-ffp-contract=fast</option> option to allow generation of FMA
instructions, or <option>-ffp-contract=off</option> to disallow it.
</para>
<!-- ===================================================================== -->

</sect1>
<sect1 label="28.11" id="Error-Recovery">
<title>Error Recovery</title>
<indexterm role="cp"><primary>error recovery (floating point)</primary></indexterm>
<indexterm role="cp"><primary>floating-point error recovery</primary></indexterm>

<para>When two numbers are combined by one of the four basic
operations, the result often requires rounding to storage
precision.  For accurate computation, one would like to be able
to recover that rounding error.  With historical floating-point
designs, it was difficult to do so portably, but now that IEEE
754 arithmetic is almost universal, the job is much easier.
</para>
<para>For addition with the default <emphasis>round-to-nearest</emphasis> rounding
mode, we can determine the error in a sum like this:
</para>
<screen>volatile double err, sum, tmp, x, y;

if (fabs (x) &gt;= fabs (y))
  {
    sum = x + y;
    tmp = sum - x;
    err = y - tmp;
  }
else /* fabs (x) &lt; fabs (y) */
  {
    sum = x + y;
    tmp = sum - y;
    err = x - tmp;
  }
</screen>
<para><indexterm role="cp"><primary>twosum</primary></indexterm>
Now, <literal>x + y</literal> is <emphasis>exactly</emphasis> represented by <literal>sum + err</literal>.
This basic operation, which has come to be called <firstterm>twosum</firstterm>
in the numerical-analysis literature, is the first key to tracking,
and accounting for, rounding error.
</para>
<para>To determine the error in subtraction, just swap the <literal>+</literal> and
<literal>-</literal> operators.
</para>
<para>We used the <literal>volatile</literal> qualifier (see <link linkend="volatile">volatile</link>) in the
declaration of the variables, which forces the compiler to store and
retrieve them from memory, and prevents the compiler from optimizing
<literal>err = y - ((x + y) - x)</literal> into <literal>err = 0</literal>.
</para>
<para>For multiplication, we can compute the rounding error without
magnitude tests with the FMA operation (see <link linkend="Fused-Multiply_002dAdd">Fused Multiply-Add</link>),
like this:
</para>
<screen>volatile double err, prod, x, y;
prod = x * y;                /* rounded product */
err  = fma (x, y, -prod);    /* exact product <literal>= <replaceable>prod</replaceable> + <replaceable>err</replaceable></literal> */
</screen>
<para>For addition, subtraction, and multiplication, we can represent the
exact result with the notional sum of two values.  However, the exact
result of division, remainder, or square root potentially requires an
infinite number of digits, so we can at best approximate it.
Nevertheless, we can compute an error term that is close to the true
error: it is just that error value, rounded to machine precision.
</para>
<para>For division, you can approximate <literal>x / y</literal> with <literal>quo + err</literal>
like this:
</para>
<screen>volatile double err, quo, x, y;
quo = x / y;
err = fma (-quo, y, x) / y;
</screen>
<para>For square root, we can approximate <literal>sqrt (x)</literal> with <literal>root +
err</literal> like this:
</para>
<screen>volatile double err, root, x;
root = sqrt (x);
err = fma (-root, root, x) / (root + root);
</screen>
<para>With the reliable and predictable floating-point design provided
by IEEE 754 arithmetic, we now have the tools we need to track
errors in the five basic floating-point operations, and we can
effectively simulate computing in twice working precision, which
is sometimes sufficient to remove almost all traces of arithmetic
errors.
</para>
<!-- ===================================================================== -->


<!-- ===================================================================== -->

</sect1>
<sect1 label="28.12" id="Exact-Floating-Constants">
<title>Exact Floating-Point Constants</title>
<indexterm role="cp"><primary>exact specification of floating-point constants</primary></indexterm>
<indexterm role="cp"><primary>floating-point constants, exact specification of</primary></indexterm>

<para>One of the frustrations that numerical programmers have suffered
with since the dawn of digital computers is the inability to
precisely specify numbers in their programs.  On the early
decimal machines, that was not an issue: you could write a
constant <literal>1e-30</literal> and be confident of that exact value
being used in floating-point operations.  However, when the
hardware works in a base other than 10, then human-specified
numbers have to be converted to that base, and then converted
back again at output time.  The two base conversions are rarely
exact, and unwanted rounding errors are introduced.
</para>
<indexterm role="cp"><primary>hexademical floating-point constants</primary></indexterm>
<para>As computers usually represent numbers in a base other than 10,
numbers often must be converted to and from different bases, and
rounding errors can occur during conversion.  This problem is solved
in C using hexademical floating-point constants.  For example,
<literal>+0x1.fffffcp-1</literal> is the number that is the IEEE 754 32-bit value
closest to, but below, <literal>1.0</literal>. The significand is represented as a
hexadecimal fraction, and the <emphasis>power of two</emphasis> is written in
decimal following the exponent letter <literal>p</literal> (the traditional
exponent letter <literal>e</literal> is not possible, because it is a hexadecimal
digit).
</para>
<para>In <literal>printf</literal> and <literal>scanf</literal> and related functions, you can use
the &#8216;<literal>%a</literal>&#8217; and &#8216;<literal>%A</literal>&#8217; format specifiers for writing and reading
hexadecimal floating-point values.  &#8216;<literal>%a</literal>&#8217; writes them with lower
case letters and &#8216;<literal>%A</literal>&#8217; writes them with upper case letters.  For
instance, this code reproduces our sample number:
</para>
<screen>printf (&quot;%a\n&quot;, 1.0 - pow (2.0, -23));
    &#8867; 0x1.fffffcp-1
</screen>
<para>The <literal>strtod</literal> family was similarly extended to recognize
numbers in that new format.
</para>
<para>If you want to ensure exact data representation for transfer of
floating-point numbers between C programs on different
computers, then hexadecimal constants are an optimum choice.
</para>
<!-- ===================================================================== -->

</sect1>
<sect1 label="28.13" id="Handling-Infinity">
<title>Handling Infinity</title>
<indexterm role="cp"><primary>infinity in floating-point arithmetic</primary></indexterm>
<indexterm role="cp"><primary>floating-point infinity</primary></indexterm>

<para>As we noted earlier, the IEEE 754 model of computing is not to stop
the program when exceptional conditions occur.  It takes note of
exceptional values or conditions by setting sticky <firstterm>exception
flags</firstterm>, or by producing results with the special values Infinity and
QNaN.  In this section, we discuss Infinity; see <link linkend="Handling-NaN">Handling NaN</link> for
the other.
</para>
<para>In GNU C, you can create a value of negative Infinity in software like
this:
</para>
<screen>double x;

x = -1.0 / 0.0;
</screen>
<para>GNU C supplies the <literal>__builtin_inf</literal>, <literal>__builtin_inff</literal>, and
<literal>__builtin_infl</literal> macros, and the GNU C Library provides the
<literal>INFINITY</literal> macro, all of which are compile-time constants for
positive infinity.
</para>
<para>GNU C also provides a standard function to test for an Infinity:
<literal>isinf (x)</literal> returns <literal>1</literal> if the argument is a signed
infinity, and <literal>0</literal> if not.
</para>
<para>Infinities can be compared, and all Infinities of the same sign are
equal: there is no notion in IEEE 754 arithmetic of different kinds of
Infinities, as there are in some areas of mathematics.  Positive
Infinity is larger than any finite value, and negative Infinity is
smaller than finite value.
</para>
<para>Infinities propagate in addition, subtraction, multiplication,
and square root, but in division, they disappear, because of the
rule that <literal>finite / Infinity</literal> is <literal>0.0</literal>.  Thus, an
overflow in an intermediate computation that produces an Infinity
is likely to be noticed later in the final results.  The programmer can
then decide whether the overflow is expected, and acceptable, or whether
the code possibly has a bug, or needs to be run in higher
precision, or redesigned to avoid the production of the Infinity.
</para>
<!-- ===================================================================== -->

</sect1>
<sect1 label="28.14" id="Handling-NaN">
<title>Handling NaN</title>
<indexterm role="cp"><primary>NaN in floating-point arithmetic</primary></indexterm>
<indexterm role="cp"><primary>not a number</primary></indexterm>
<indexterm role="cp"><primary>floating-point NaN</primary></indexterm>

<para>NaNs are not numbers: they represent values from computations that
produce undefined results.  They have a distinctive property that
makes them unlike any other floating-point value: they are
<emphasis>unequal to everything, including themselves</emphasis>!  Thus, you can
write a test for a NaN like this:
</para>
<screen>if (x != x)
  printf (&quot;x is a NaN\n&quot;);
</screen>
<para>This test works in GNU C, but some compilers might evaluate that test
expression as false without properly checking for the NaN value.
A more portable way to test for NaN is to use the <literal>isnan</literal>
function declared in <literal>math.h</literal>:
</para>
<screen>if (isnan (x))
  printf (&quot;x is a NaN\n&quot;);
</screen>
<para>See section &#8220;Floating Point Classes&#8221; in <citetitle>The GNU C Library Reference Manual</citetitle>.
</para>
<para>One important use of NaNs is marking of missing data.  For
example, in statistics, such data must be omitted from
computations.  Use of any particular finite value for missing
data would eventually collide with real data, whereas such data
could never be a NaN, so it is an ideal marker.  Functions that
deal with collections of data that may have holes can be written
to test for, and ignore, NaN values.
</para>
<para>It is easy to generate a NaN in computations: evaluating <literal>0.0 /
0.0</literal> is the commonest way, but <literal>Infinity - Infinity</literal>,
<literal>Infinity / Infinity</literal>, and <literal>sqrt (-1.0)</literal> also work.
Functions that receive out-of-bounds arguments can choose to return a
stored NaN value, such as with the <literal>NAN</literal> macro defined in
<literal>math.h</literal>, but that does not set the <emphasis>invalid operand</emphasis>
exception flag, and that can fool some programs.
</para>
<indexterm role="cp"><primary>NaNs-always-propagate rule</primary></indexterm>
<para>Like Infinity, NaNs propagate in computations, but they are even
stickier, because they never disappear in division. Thus, once a
NaN appears in a chain of numerical operations, it is almost
certain to pop out into the final results.  The programmer 
has to decide whether that is expected, or whether there is a
coding or algorithmic error that needs repair.
</para>
<para>In general, when function gets a NaN argument, it usually returns a
NaN.  However, there are some exceptions in the math-library functions
that you need to be aware of, because they violate the
<emphasis>NaNs-always-propagate</emphasis> rule:
</para>
<itemizedlist>
<listitem><para><literal>pow (x, 0.0)</literal> always returns <literal>1.0</literal>, even if <literal>x</literal> is
0.0, Infinity, or a NaN.
</para>
</listitem><listitem><para><literal>pow (1, y)</literal> always returns <literal>1</literal>, even if <literal>y</literal> is a NaN.
</para>
</listitem><listitem><para><literal>hypot (INFINITY, y)</literal> and <literal>hypot (-INFINITY, y)</literal> both
always return <literal>INFINITY</literal>, even if <literal>y</literal> is a Nan.
</para>
</listitem><listitem><para>If just one of the arguments to <literal>fmax (x, y)</literal> or
<literal>fmin (x, y)</literal> is a NaN, it returns the other argument.  If
both arguments are NaNs, it returns a NaN, but there is no
requirement about where it comes from: it could be <literal>x</literal>, or
<literal>y</literal>, or some other quiet NaN.
</para></listitem></itemizedlist>
<para>NaNs are also used for the return values of math-library
functions where the result is not representable in real
arithmetic, or is mathematically undefined or uncertain, such as
<literal>sqrt (-1.0)</literal> and <literal>sin (Infinity)</literal>.  However, note that a
result that is merely too big to represent should always produce
an Infinity, such as with <literal>exp (1000.0)</literal> (too big) and
<literal>exp (Infinity)</literal> (truly infinite).
</para>
<!-- ===================================================================== -->

</sect1>
<sect1 label="28.15" id="Signed-Zeros">
<title>Signed Zeros</title>
<indexterm role="cp"><primary>signed zeros in floating-point arithmetic</primary></indexterm>
<indexterm role="cp"><primary>floating-point signed zeros</primary></indexterm>

<para>The sign of zero is significant, and important, because it records the
creation of a value that is too small to represent, but came from
either the negative axis, or from the positive axis.  Such fine
distinctions are essential for proper handling of <firstterm>branch cuts</firstterm>
in complex arithmetic (see <link linkend="Complex-Arithmetic">Complex Arithmetic</link>).
</para>
<para>The key point about signed zeros is that in comparisons, their sign
does not matter: <literal>0.0 == -0.0</literal> must <emphasis>always</emphasis> evaluate to
<literal>1</literal> (true).  However, they are not <emphasis>the same number</emphasis>, and
<literal>-0.0</literal> in C code stands for a negative zero.
</para>
<!-- ===================================================================== -->

</sect1>
<sect1 label="28.16" id="Scaling-by-the-Base">
<title>Scaling by Powers of the Base</title>
<indexterm role="cp"><primary>scaling floating point by powers of the base</primary></indexterm>
<indexterm role="cp"><primary>floating-point scaling by powers of the base</primary></indexterm>

<para>We have discussed rounding errors several times in this chapter,
but it is important to remember that when results require no more
bits than the exponent and significand bits can represent, those results
are <emphasis>exact</emphasis>.
</para>
<para>One particularly useful exact operation is scaling by a power of
the base.  While one, in principle, could do that with code like
this:
</para>
<screen>y = x * pow (2.0, (double)k);   /* Undesirable scaling: avoid! */
</screen>
<para>that is not advisable, because it relies on the quality of the
math-library power function, and that happens to be one of the
most difficult functions in the C math library to make accurate.
What is likely to happen on many systems is that the returned
value from <literal>pow</literal> will be close to a power of two, but
slightly different, so the subsequent multiplication introduces
rounding error.
</para>
<para>The correct, and fastest, way to do the scaling is either via the
traditional C library function, or with its C99 equivalent:
</para>
<screen>y = ldexp (x, k);            /* Traditional pre-C99 style. */
y = scalbn (x, k);           /* C99 style. */
</screen>
<para>Both functions return <literal>x * 2**k</literal>.
See section &#8220;Normalization Functions&#8221; in <citetitle>The GNU C Library Reference Manual</citetitle>.
</para>
<!-- ===================================================================== -->

</sect1>
<sect1 label="28.17" id="Rounding-Control">
<title>Rounding Control</title>
<indexterm role="cp"><primary>rounding control (floating point)</primary></indexterm>
<indexterm role="cp"><primary>floating-point rounding control</primary></indexterm>

<para>Here we describe how to specify the rounding mode at run time.  System
header file <filename>fenv.h</filename> provides the prototypes for these functions.
See section &#8220;Rounding&#8221; in <citetitle>The GNU C Library Reference Manual</citetitle>.
</para>
<para>That header file also provides constant names for the four rounding modes:
<literal>FE_DOWNWARD</literal>, <literal>FE_TONEAREST</literal>, <literal>FE_TOWARDZERO</literal>, and
<literal>FE_UPWARD</literal>.
</para>
<para>The function <literal>fegetround</literal> examines and returns the current
rounding mode.  On a platform with IEEE 754 floating point,
the value will always equal one of those four constants.
On other platforms, it may return a negative value. The function
<literal>fesetround</literal> sets the current rounding mode.
</para>
<para>Changing the rounding mode can be slow, so it is useful to minimize
the number of changes.  For interval arithmetic, we seem to need three
changes for each operation, but we really only need two, because we
can write code like this example for interval addition of two reals:
</para>
<screen>{
  struct interval_double
    {
      double hi, lo;
    } v;
  volatile double x, y;
  int rule;

  rule = fegetround ();

  if (fesetround (FE_UPWARD) == 0)
    {
      v.hi = x + y;
      v.lo = -(-x - y);
    }
  else
    fatal (&quot;ERROR: failed to change rounding rule&quot;);

  if (fesetround (rule) != 0)
    fatal (&quot;ERROR: failed to restore rounding rule&quot;);
}
</screen>
<para>The <literal>volatile</literal> qualifier (see <link linkend="volatile">volatile</link>) is essential on x86
platforms to prevent an optimizing compiler from producing the same
value for both bounds.
</para>

<!-- ===================================================================== -->

</sect1>
<sect1 label="28.18" id="Machine-Epsilon">
<title>Machine Epsilon</title>
<indexterm role="cp"><primary>machine epsilon (floating point)</primary></indexterm>
<indexterm role="cp"><primary>floating-point machine epsilon</primary></indexterm>

<para>In any floating-point system, three attributes are particularly
important to know: <firstterm>base</firstterm> (the number that the exponent specifies
a power of), <firstterm>precision</firstterm> (number of digits in the significand),
and <firstterm>range</firstterm> (difference between most positive and most negative
values).  The allocation of bits between exponent and significand
decides the answers to those questions.
</para>
<para>A measure of the precision is the answer to the question: what is
the smallest number that can be added to <literal>1.0</literal> such that the
sum differs from <literal>1.0</literal>?  That number is called the
<firstterm>machine epsilon</firstterm>.
</para>
<para>We could define the needed machine-epsilon constants for <literal>float</literal>,
<literal>double</literal>, and <literal>long double</literal> like this:
</para>
<screen>static const float  epsf = 0x1p-23;  /* about 1.192e-07 */
static const double eps  = 0x1p-52;  /* about 2.220e-16 */
static const long double epsl = 0x1p-63;  /* about 1.084e-19 */
</screen>
<para>Instead of the hexadecimal constants, we could also have used the
Standard C macros, <literal>FLT_EPSILON</literal>, <literal>DBL_EPSILON</literal>, and
<literal>LDBL_EPSILON</literal>.
</para>
<para>It is useful to be able to compute the machine epsilons at
run time, and we can easily generalize the operation by replacing
the constant <literal>1.0</literal> with a user-supplied value:
</para>
<screen>double
macheps (double x)
{ /* Return machine epsilon for <replaceable>x</replaceable>,  */
      such that <replaceable>x</replaceable> + macheps (<replaceable>x</replaceable>) &gt; <replaceable>x</replaceable>.  */
  static const double base = 2.0;
  double eps;

  if (isnan (x))
      eps = x;
  else
    {
      eps = (x == 0.0) ? 1.0 : x;

      while ((x + eps / base) != x)
          eps /= base;          /* Always exact!  */
    }

  return (eps);
}
</screen>
<para>If we call that function with arguments from <literal>0</literal> to
<literal>10</literal>, as well as Infinity and NaN, and print the returned
values in hexadecimal, we get output like this:
</para>
<screen>macheps (  0) = 0x1.0000000000000p-1074
macheps (  1) = 0x1.0000000000000p-52
macheps (  2) = 0x1.0000000000000p-51
macheps (  3) = 0x1.8000000000000p-52
macheps (  4) = 0x1.0000000000000p-50
macheps (  5) = 0x1.4000000000000p-51
macheps (  6) = 0x1.8000000000000p-51
macheps (  7) = 0x1.c000000000000p-51
macheps (  8) = 0x1.0000000000000p-49
macheps (  9) = 0x1.2000000000000p-50
macheps ( 10) = 0x1.4000000000000p-50
macheps (Inf) = infinity
macheps (NaN) = nan
</screen>
<para>Notice that <literal>macheps</literal> has a special test for a NaN to prevent an
infinite loop.
</para>

<para>Our code made another test for a zero argument to avoid getting a
zero return.  The returned value in that case is the smallest
representable floating-point number, here the subnormal value
<literal>2**(-1074)</literal>, which is about <literal>4.941e-324</literal>.
</para>
<para>No special test is needed for an Infinity, because the
<literal>eps</literal>-reduction loop then terminates at the first iteration.
</para>
<para>Our <literal>macheps</literal> function here assumes binary floating point; some
architectures may differ.
</para>
<para>The C library includes some related functions that can also be used to
determine machine epsilons at run time:
</para>
<screen>#include &lt;math.h&gt;           /* Include for these prototypes. */

double      nextafter  (double x, double y);
float       nextafterf (float x, float y);
long double nextafterl (long double x, long double y);
</screen>
<para>These return the machine number nearest <replaceable>x</replaceable> in the direction of
<replaceable>y</replaceable>.  For example, <literal>nextafter (1.0, 2.0)</literal> produces the same
result as <literal>1.0 + macheps (1.0)</literal> and <literal>1.0 + DBL_EPSILON</literal>.
See section &#8220;FP Bit Twiddling&#8221; in <citetitle>The GNU C Library Reference Manual</citetitle>.
</para>
<para>It is important to know that the machine epsilon is not symmetric
about all numbers.  At the boundaries where normalization changes the
exponent, the epsilon below <replaceable>x</replaceable> is smaller than that just above
<replaceable>x</replaceable> by a factor <literal>1 / base</literal>.  For example, <literal>macheps
(1.0)</literal> returns <literal>+0x1p-52</literal>, whereas <literal>macheps (-1.0)</literal> returns
<literal>+0x1p-53</literal>.  Some authors distinguish those cases by calling them
the <emphasis>positive</emphasis> and <emphasis>negative</emphasis>, or <emphasis>big</emphasis> and
<emphasis>small</emphasis>, machine epsilons.  You can produce their values like
this:
</para>
<screen>eps_neg = 1.0 - nextafter (1.0, -1.0);
eps_pos = nextafter (1.0, +2.0) - 1.0;
</screen>
<para>If <replaceable>x</replaceable> is a variable, such that you do not know its value at
compile time, then you can substitute literal <replaceable>y</replaceable> values with
either <literal>-inf()</literal> or <literal>+inf()</literal>, like this:
</para>
<screen>eps_neg = x - nextafter (x, -inf ());
eps_pos = nextafter (x, +inf() - x);
</screen>
<para>In such cases, if <replaceable>x</replaceable> is Infinity, then <emphasis>the <literal>nextafter</literal>
functions return <replaceable>y</replaceable> if <replaceable>x</replaceable> equals <replaceable>y</replaceable></emphasis>.  Our two
assignments then produce <literal>+0x1.fffffffffffffp+1023</literal> (about
1.798e+308) for <replaceable>eps_neg</replaceable> and Infinity for <replaceable>eps_pos</replaceable>.  Thus,
the call <literal>nextafter (INFINITY, -INFINITY)</literal> can be used to find
the largest representable finite number, and with the call
<literal>nextafter (0.0, 1.0)</literal>, the smallest representable number (here,
<literal>0x1p-1074</literal> (about 4.491e-324), a number that we saw before as
the output from <literal>macheps (0.0)</literal>).
</para>
<!-- ===================================================================== -->

</sect1>
<sect1 label="28.19" id="Complex-Arithmetic">
<title>Complex Arithmetic</title>
<indexterm role="cp"><primary>complex arithmetic in floating-point calculations</primary></indexterm>
<indexterm role="cp"><primary>floating-point arithmetic with complex numbers</primary></indexterm>

<para>We&#8217;ve already looked at defining and referring to complex numbers
(see <link linkend="Complex-Data-Types">Complex Data Types</link>).  What is important to discuss here are
some issues that are unlikely to be obvious to programmers without
extensive experience in both numerical computing, and in complex
arithmetic in mathematics.
</para>
<para>The first important point is that, unlike real arithmetic, in complex
arithmetic, the danger of significance loss is <emphasis>pervasive</emphasis>, and
affects <emphasis>every one</emphasis> of the basic operations, and <emphasis>almost
all</emphasis> of the math-library functions.  To understand why, recall the
rules for complex multiplication and division:
</para>
<screen>a = u + I*v              /* First operand. */
b = x + I*y              /* Second operand. */

prod = a * b
     = (u + I*v) * (x + I*y)
     = (u * x - v * y) + I*(v * x + u * y)

quo  = a / b
     = (u + I*v) / (x + I*y)
     = [(u + I*v) * (x - I*y)] / [(x + I*y) * (x - I*y)]
     = [(u * x + v * y) + I*(v * x - u * y)] / (x**2 + y**2)
</screen>
<para>There are four critical observations about those formulas:
</para>
<itemizedlist>
<listitem><para>the multiplications on the right-hand side introduce the
possibility of premature underflow or overflow;
</para>
</listitem><listitem><para>the products must be accurate to twice working precision;
</para>
</listitem><listitem><para>there is <emphasis>always</emphasis> one subtraction on the right-hand sides
that is subject to catastrophic significance loss; and
</para>
</listitem><listitem><para>complex multiplication has up to <emphasis>six</emphasis> rounding errors, and
complex division has <emphasis>ten</emphasis> rounding errors.
</para>
</listitem></itemizedlist>
<indexterm role="cp"><primary>branch cuts</primary></indexterm>
<para>Another point that needs careful study is the fact that many functions
in complex arithmetic have <firstterm>branch cuts</firstterm>.  You can view a
function with a complex argument, <literal>f (z)</literal>, as <literal>f (x + I*y)</literal>,
and thus, it defines a relation between a point <literal>(x, y)</literal> on the
complex plane with an elevation value on a surface.  A branch cut
looks like a tear in that surface, so approaching the cut from one
side produces a particular value, and from the other side, a quite
different value.  Great care is needed to handle branch cuts properly,
and even small numerical errors can push a result from one side to the
other, radically changing the returned value.  As we reported earlier,
correct handling of the sign of zero is critically important for
computing near branch cuts.
</para>
<para>The best advice that we can give to programmers who need complex
arithmetic is to always use the <emphasis>highest precision available</emphasis>,
and then to carefully check the results of test calculations to gauge
the likely accuracy of the computed results.  It is easy to supply
test values of real and imaginary parts where all five basic
operations in complex arithmetic, and almost all of the complex math
functions, lose <emphasis>all</emphasis> significance, and fail to produce even a
single correct digit.
</para>
<para>Even though complex arithmetic makes some programming tasks
easier, it may be numerically preferable to rework the algorithm
so that it can be carried out in real arithmetic.  That is
commonly possible in matrix algebra.
</para>
<para>GNU C can perform code optimization on complex number multiplication and
division if certain boundary checks will not be needed.  The
command-line option <option>-fcx-limited-range</option> tells the compiler that
a range reduction step is not needed when performing complex division,
and that there is no need to check if a complex multiplication or
division results in the value <literal>Nan + I*NaN</literal>.  By default these
checks are enabled.  You can explicitly enable them with the
<option>-fno-cx-limited-range</option> option.
</para>

</sect1>
<sect1 label="28.20" id="Round_002dTrip-Base-Conversion">
<title>Round-Trip Base Conversion</title>
<indexterm role="cp"><primary>round-trip base conversion</primary></indexterm>
<indexterm role="cp"><primary>base conversion (floating point)</primary></indexterm>
<indexterm role="cp"><primary>floating-point round-trip base conversion</primary></indexterm>

<para>Most numeric programs involve converting between base-2 floating-point
numbers, as represented by the computer, and base-10 floating-point
numbers, as entered and handled by the programmer.  What might not be
obvious is the number of base-2 bits vs. base-10 digits required for
each representation.  Consider the following tables showing the number of
decimal digits representable in a given number of bits, and vice versa:
</para>
<informaltable><tgroup cols="6"><colspec colwidth="50*"></colspec><colspec colwidth="10*"></colspec><colspec colwidth="10*"></colspec><colspec colwidth="10*"></colspec><colspec colwidth="10*"></colspec><colspec colwidth="10*"></colspec><tbody><row><entry><para>binary in   </para></entry><entry><para>24 </para></entry><entry><para>53 </para></entry><entry><para>64 </para></entry><entry><para>113 </para></entry><entry><para>237
</para></entry></row><row><entry><para>decimal out </para></entry><entry><para>9  </para></entry><entry><para>17 </para></entry><entry><para>21 </para></entry><entry><para>36  </para></entry><entry><para>73
</para></entry></row></tbody></tgroup></informaltable>
<informaltable><tgroup cols="5"><colspec colwidth="50*"></colspec><colspec colwidth="10*"></colspec><colspec colwidth="10*"></colspec><colspec colwidth="10*"></colspec><colspec colwidth="10*"></colspec><tbody><row><entry><para>decimal in  </para></entry><entry><para>7  </para></entry><entry><para>16 </para></entry><entry><para>34  </para></entry><entry><para>70
</para></entry></row><row><entry><para>binary out  </para></entry><entry><para>25 </para></entry><entry><para>55 </para></entry><entry><para>114 </para></entry><entry><para>234
</para></entry></row></tbody></tgroup></informaltable>
<para>We can compute the table numbers with these two functions:
</para>
<screen>int
matula(int nbits)
{   /* Return output decimal digits needed for nbits-bits input. */
    return ((int)ceil((double)nbits / log2(10.0) + 1.0));
}

int
goldberg(int ndec)
{   /* Return output bits needed for ndec-digits input. */
    return ((int)ceil((double)ndec / log10(2.0) + 1.0));
}
</screen>
<para>One significant observation from those numbers is that we cannot
achieve correct round-trip conversion between the decimal and
binary formats in the same storage size!  For example, we need 25
bits to represent a 7-digit value from the 32-bit decimal format,
but the binary format only has 24 available.  Similar
observations hold for each of the other conversion pairs.
</para>
<para>The general input/output base-conversion problem is astonishingly
complicated, and solutions were not generally known until the
publication of two papers in 1990 that are listed later near the end
of this chapter.  For the 128-bit formats, the worst case needs more
than 11,500 decimal digits of precision to guarantee correct rounding
in a binary-to-decimal conversion!
</para>
<para>For further details see the references for Bennett Goldberg and David
Matula.
</para>
<!-- ===================================================================== -->

</sect1>
<sect1 label="28.21" id="Further-Reading">
<title>Further Reading</title>

<para>The subject of floating-point arithmetic is much more complex
than many programmers seem to think, and few books on programming
languages spend much time in that area.  In this chapter, we have
tried to expose the reader to some of the key ideas, and to warn
of easily overlooked pitfalls that can soon lead to nonsensical
results.  There are a few good references that we recommend
for further reading, and for finding other important material
about computer arithmetic:
</para>
<!-- ===================================================================== -->
<!-- Each bibliography item has a sort key, so the bibliography can be -->
<!-- sorted in emacs with M-x sort-paragraphs on the region with the items. -->
<!-- ===================================================================== -->

<itemizedlist>
<listitem><!-- sort-key: Abbott -->
<para>Paul H. Abbott and 15 others, <citetitle>Architecture and software support
in IBM S/390 Parallel Enterprise Servers for IEEE Floating-Point
arithmetic</citetitle>, IBM Journal of Research and Development <emphasis role="bold">43</emphasis>(5/6)
723&#8211;760 (1999),
<ulink url="https://doi.org/10.1147/rd.435.0723">https://doi.org/10.1147/rd.435.0723</ulink>. This article gives
a good description of IBM&#8217;s algorithm for exact decimal-to-binary
conversion, complementing earlier ones by Clinger and others.
</para>
</listitem><listitem><!-- sort-key: Beebe -->
<para>Nelson H. F. Beebe, <citetitle>The Mathematical-Function Computation Handbook:
Programming Using the MathCW Portable Software Library</citetitle>,
Springer (2017), ISBN 3-319-64109-3 (hardcover), 3-319-64110-7 (e-book)
(xxxvi + 1114 pages),
<ulink url="https://doi.org/10.1007/978-3-319-64110-2">https://doi.org/10.1007/978-3-319-64110-2</ulink>.
This book describes portable implementations of a large superset
of the mathematical functions available in many programming
languages, extended to a future 256-bit format (70 decimal
digits), for both binary and decimal floating point.  It includes
a substantial portion of the functions described in the famous
<citetitle>NIST Handbook of Mathematical Functions</citetitle>, Cambridge (2018),
ISBN 0-521-19225-0.
See
<ulink url="http://www.math.utah.edu/pub/mathcw">http://www.math.utah.edu/pub/mathcw</ulink>
for compilers and libraries.
</para>
</listitem><listitem><!-- sort-key: Clinger-1990 -->
<para>William D. Clinger, <citetitle>How to Read Floating Point Numbers
Accurately</citetitle>,  ACM SIGPLAN Notices <emphasis role="bold">25</emphasis>(6) 92&#8211;101 (June 1990),
<ulink url="https://doi.org/10.1145/93548.93557">https://doi.org/10.1145/93548.93557</ulink>.
See also the papers by Steele &amp; White.
</para>
</listitem><listitem><!-- sort-key: Clinger-2004 -->
<para>William D. Clinger, <citetitle>Retrospective: How to read floating
point numbers accurately</citetitle>, ACM SIGPLAN Notices <emphasis role="bold">39</emphasis>(4) 360&#8211;371 (April 2004),
<ulink url="http://doi.acm.org/10.1145/989393.989430">http://doi.acm.org/10.1145/989393.989430</ulink>.  Reprint of 1990 paper,
with additional commentary.
</para>
</listitem><listitem><!-- sort-key: Goldberg-1967 -->
<para>I. Bennett Goldberg, <citetitle>27  Bits Are Not Enough For 8-Digit Accuracy</citetitle>,
Communications of the ACM <emphasis role="bold">10</emphasis>(2) 105&#8211;106 (February 1967),
<ulink url="http://doi.acm.org/10.1145/363067.363112">http://doi.acm.org/10.1145/363067.363112</ulink>.  This paper,
and its companions by David Matula, address the base-conversion
problem, and show that the naive formulas are wrong by one or
two digits.
</para>
</listitem><listitem><!-- sort-key: Goldberg-1991 -->
<para>David Goldberg, <citetitle>What Every Computer Scientist Should Know
About Floating-Point Arithmetic</citetitle>, ACM Computing Surveys <emphasis role="bold">23</emphasis>(1)
5&#8211;58 (March 1991), corrigendum <emphasis role="bold">23</emphasis>(3) 413 (September 1991),
<ulink url="https://doi.org/10.1145/103162.103163">https://doi.org/10.1145/103162.103163</ulink>.
This paper has been widely distributed, and reissued in vendor
programming-language documentation.  It is well worth reading,
and then rereading from time to time.
</para>
</listitem><listitem><!-- sort-key: Juffa -->
<para>Norbert Juffa and Nelson H. F. Beebe, <citetitle>A Bibliography of
Publications on Floating-Point Arithmetic</citetitle>,
<ulink url="http://www.math.utah.edu/pub/tex/bib/fparith.bib">http://www.math.utah.edu/pub/tex/bib/fparith.bib</ulink>.
This is the largest known bibliography of publications about
floating-point, and also integer, arithmetic.  It is actively
maintained, and in mid 2019, contains more than 6400 references to
original research papers, reports, theses, books, and Web sites on the
subject matter.  It can be used to locate the latest research in the
field, and the historical coverage dates back to a 1726 paper on
signed-digit arithmetic, and an 1837 paper by Charles Babbage, the
intellectual father of mechanical computers.  The entries for the
Abbott, Clinger, and Steele &amp; White papers cited earlier contain
pointers to several other important related papers on the
base-conversion problem.
</para>
</listitem><listitem><!-- sort-key: Kahan -->
<para>William Kahan, <citetitle>Branch Cuts for Complex Elementary Functions, or
Much Ado About Nothing&#8217;s Sign Bit</citetitle>, (1987),
<ulink url="http://people.freebsd.org/~das/kahan86branch.pdf">http://people.freebsd.org/~das/kahan86branch.pdf</ulink>.
This Web document about the fine points of complex arithmetic
also appears in the volume edited by A. Iserles and
M. J. D. Powell, <citetitle>The State of the Art in Numerical
Analysis: Proceedings of the Joint IMA/SIAM Conference on the
State of the Art in Numerical Analysis held at the University of
Birmingham, 14&#8211;18 April 1986</citetitle>, Oxford University Press (1987),
ISBN 0-19-853614-3 (xiv + 719 pages).  Its author is the famous
chief architect of the IEEE 754 arithmetic system, and one of the
world&#8217;s greatest experts in the field of floating-point
arithmetic.  An entire generation of his students at the
University of California, Berkeley, have gone on to careers in
academic and industry, spreading the knowledge of how to do
floating-point arithmetic right.
</para>
</listitem><listitem><!-- sort-key: Knuth -->
<para>Donald E. Knuth, <citetitle>A Simple Program Whose Proof Isn&#8217;t</citetitle>,
in <citetitle>Beauty is our business: a birthday salute to Edsger
W. Dijkstra</citetitle>, W. H. J. Feijen, A. J. M. van Gasteren,
D. Gries, and J. Misra (eds.), Springer (1990), ISBN
1-4612-8792-8,
<ulink url="https://doi.org/10.1007/978-1-4612-4476-9">https://doi.org/10.1007/978-1-4612-4476-9</ulink>.  This book
chapter supplies a correctness proof of the decimal to
binary, and binary to decimal, conversions in fixed-point
arithmetic in the TeX typesetting system.  The proof evaded
its author for a dozen years.
</para>
</listitem><listitem><!-- sort-key: Matula-1968a -->
<para>David W. Matula, <citetitle>In-and-out conversions</citetitle>,
Communications of the ACM <emphasis role="bold">11</emphasis>(1) 57&#8211;50 (January 1968),
<ulink url="https://doi.org/10.1145/362851.362887">https://doi.org/10.1145/362851.362887</ulink>.
</para>
</listitem><listitem><!-- sort-key: Matula-1968b -->
<para>David W. Matula, <citetitle>The Base Conversion Theorem</citetitle>,
Proceedings of the American Mathematical Society <emphasis role="bold">19</emphasis>(3)
716&#8211;723 (June 1968).  See also other papers here by this author,
and by I. Bennett Goldberg.
</para>
</listitem><listitem><!-- sort-key: Matula-1970 -->
<para>David W. Matula, <citetitle>A Formalization of Floating-Point Numeric
Base Conversion</citetitle>, IEEE Transactions on Computers <emphasis role="bold">C-19</emphasis>(8)
681&#8211;692 (August 1970),
<ulink url="https://doi.org/10.1109/T-C.1970.223017">https://doi.org/10.1109/T-C.1970.223017</ulink>.
</para>
</listitem><listitem><!-- sort-key: Muller-2010 -->
<para>Jean-Michel Muller and eight others, <citetitle>Handbook of
Floating-Point Arithmetic</citetitle>, Birkh&#228;user-Boston (2010), ISBN
0-8176-4704-X (xxiii + 572 pages),
<ulink url="https://doi.org/10.1007/978-0-8176-4704-9">https://doi.org/10.1007/978-0-8176-4704-9</ulink>.  This is a
comprehensive treatise from a French team who are among the
world&#8217;s greatest experts in floating-point arithmetic, and among
the most prolific writers of research papers in that field.  They
have much to teach, and their book deserves a place on the
shelves of every serious numerical programmer.
</para>
</listitem><listitem><!-- sort-key: Muller-2018 -->
<para>Jean-Michel Muller and eight others, <citetitle>Handbook of
Floating-Point Arithmetic</citetitle>, Second edition, Birkh&#228;user-Boston (2018), ISBN
3-319-76525-6 (xxv + 627 pages),
<ulink url="https://doi.org/10.1007/978-3-319-76526-6">https://doi.org/10.1007/978-3-319-76526-6</ulink>.  This is a new
edition of the preceding entry.
</para>
</listitem><listitem><!-- sort-key: Overton -->
<para>Michael Overton, <citetitle>Numerical Computing with IEEE Floating
Point Arithmetic, Including One Theorem, One Rule of Thumb, and
One Hundred and One Exercises</citetitle>, SIAM (2001), ISBN 0-89871-482-6
(xiv + 104 pages),
<ulink url="http://www.ec-securehost.com/SIAM/ot76.html">http://www.ec-securehost.com/SIAM/ot76.html</ulink>.
This is a small volume that can be covered in a few hours.
</para>
</listitem><listitem><!-- sort-key: Steele-1990 -->
<para>Guy L. Steele Jr. and Jon L. White, <citetitle>How to Print
Floating-Point Numbers Accurately</citetitle>, ACM SIGPLAN Notices
<emphasis role="bold">25</emphasis>(6) 112&#8211;126 (June 1990),
<ulink url="https://doi.org/10.1145/93548.93559">https://doi.org/10.1145/93548.93559</ulink>.
See also the papers by Clinger.
</para>
</listitem><listitem><!-- sort-key: Steele-2004 -->
<para>Guy L. Steele Jr. and Jon L. White, <citetitle>Retrospective: How to
Print Floating-Point Numbers Accurately</citetitle>, ACM SIGPLAN Notices
<emphasis role="bold">39</emphasis>(4) 372&#8211;389 (April 2004),
<ulink url="http://doi.acm.org/10.1145/989393.989431">http://doi.acm.org/10.1145/989393.989431</ulink>.  Reprint of 1990
paper, with additional commentary.
</para>
</listitem><listitem><!-- sort-key: Sterbenz -->
<para>Pat H. Sterbenz, <citetitle>Floating Point Computation</citetitle>, Prentice-Hall
(1974), ISBN 0-13-322495-3 (xiv + 316 pages).  This often-cited book
provides solid coverage of what floating-point arithmetic was like
<emphasis>before</emphasis> the introduction of IEEE 754 arithmetic.
</para>
</listitem></itemizedlist>
</sect1>
</chapter>
<chapter label="29" id="Compilation">
<title>Compilation</title>
<indexterm role="cp"><primary>object file</primary></indexterm>
<indexterm role="cp"><primary>compilation module</primary></indexterm>
<indexterm role="cp"><primary>make rules</primary></indexterm>

<para>Early in the manual we explained how to compile a simple C program
that consists of a single source file (see <link linkend="Compile-Example">Compile Example</link>).
However, we handle only short programs that way.  A typical C program
consists of many source files, each of which is a separate
<firstterm>compilation module</firstterm>&#8212;meaning that it has to be compiled
separately.
</para>
<para>The full details of how to compile with GCC are documented in xxxx.
<!-- ??? ref -->
Here we give only a simple introduction.
</para>
<para>These are the commands to compile two compilation modules,
<filename>foo.c</filename> and <filename>bar.c</filename>, with a command for each module:
</para>
<screen>gcc -c -O -g foo.c
gcc -c -O -g bar.c
</screen>
<para>In these commands, <option>-g</option> says to generate debugging information,
<option>-O</option> says to do some optimization, and <option>-c</option> says to put
the compiled code for that module into a corresponding <firstterm>object
file</firstterm> and go no further.  The object file for <filename>foo.c</filename> is called
<filename>foo.o</filename>, and so on.
</para>
<para>If you wish, you can specify the additional options <option>-Wformat
-Wparenthesis -Wstrict-prototypes</option>, which request additional warnings.
</para>
<para>One reason to divide a large program into multiple compilation modules
is to control how each module can access the internals of the others.
When a module declares a function or variable <literal>extern</literal>, other
modules can access it.  The other functions and variables in
a module can&#8217;t be accessed from outside that module.
</para>
<para>The other reason for using multiple modules is so that changing
one source file does not require recompiling all of them in order
to try the modified program.  Dividing a large program into many
substantial modules in this way typically makes recompilation much faster.
</para>
<indexterm role="cp"><primary>linking object files</primary></indexterm>
<para>After you compile all the program&#8217;s modules, in order to run the
program you must <firstterm>link</firstterm> the object files into a combined
executable, like this:
</para>
<screen>gcc -o foo foo.o bar.o
</screen>
<para>In this command, <option>-o foo</option> species the file name for the
executable file, and the other arguments are the object files to link.
Always specify the executable file name in a command that generates
one.
</para>
<para>Normally we don&#8217;t run any of these commands directly.  Instead we
write a set of <firstterm>make rules</firstterm> for the program, then use the
<command>make</command> program to recompile only the source files that need to
be recompiled.
</para>
<!-- ??? ref to make manual -->

</chapter>
<chapter label="30" id="Directing-Compilation">
<title>Directing Compilation</title>

<para>This chapter describes C constructs that don&#8217;t alter the program&#8217;s
meaning <emphasis>as such</emphasis>, but rather direct the compiler how to treat
some aspects of the program.
</para>

<sect1 label="30.1" id="Pragmas">
<title>Pragmas</title>

<para>A <firstterm>pragma</firstterm> is an annotation in a program that gives direction to
the compiler.
</para>

<!-- See also @ref{Macro Pragmas}, which save and restore macro definitions. -->

<sect2 label="30.1.1" id="Pragma-Basics">
<title>Pragma Basics</title>

<para>C defines two syntactical forms for pragmas, the line form and the
token form.  You can write any pragma in either form, with the same
meaning.
</para>
<para>The line form is a line in the source code, like this:
</para>
<screen>#pragma <replaceable>line</replaceable>
</screen>
<para>The line pragma has no effect on the parsing of the lines around it.
This form has the drawback that it can&#8217;t be generated by a macro expansion.
</para>
<para>The token form is a series of tokens; it can appear anywhere in the
program between the other tokens.
</para>
<screen>_Pragma (<replaceable>stringconstant</replaceable>)
</screen>
<para>The pragma has no effect on the syntax of the tokens that surround it;
thus, here&#8217;s a pragma in the middle of an <literal>if</literal> statement:
</para>
<screen>if _Pragma (&quot;hello&quot;) (x &gt; 1)
</screen>
<para>However, that&#8217;s an unclear thing to do; for the sake of
understandability, it is better to put a pragma on a line by itself
and not embedded in the middle of another construct.
</para>
<para>Both forms of pragma have a textual argument.  In a line pragma, the
text is the rest of the line.  The textual argument to <literal>_Pragma</literal>
uses the same syntax as a C string constant: surround the text with
two &#8216;<literal>&quot;</literal>&#8217; characters, and add a backslash before each &#8216;<literal>&quot;</literal>&#8217; or
&#8216;<literal>\</literal>&#8217; character in it.
</para>
<para>With either syntax, the textual argument specifies what to do.
It begins with one or several words that specify the operation.
If the compiler does not recognize them, it ignores the pragma.
</para>
<para>Here are the pragma operations supported in GNU C.
</para>
<!-- ??? Verify font for [] -->
<variablelist><varlistentry><term><literal>#pragma GCC dependency &quot;<replaceable>file</replaceable>&quot; [<replaceable>message</replaceable>]</literal>
</term><term><literal>_Pragma (&quot;GCC dependency \&quot;<replaceable>file</replaceable>\&quot; [<replaceable>message</replaceable>]&quot;)</literal>
</term><listitem><para>Declares that the current source file depends on <replaceable>file</replaceable>, so GNU C
compares the file times and gives a warning if <replaceable>file</replaceable> is newer
than the current source file.
</para>
<para>This directive searches for <replaceable>file</replaceable> the way <literal>#include</literal>
searches for a non-system header file.
</para>
<para>If <replaceable>message</replaceable> is given, the warning message includes that text.
</para>
<para>Examples:
</para>
<screen>#pragma GCC dependency &quot;parse.y&quot;
_pragma (&quot;GCC dependency \&quot;/usr/include/time.h\&quot; \
rerun fixincludes&quot;)
</screen>
</listitem></varlistentry><varlistentry><term><literal>#pragma GCC poison <replaceable>identifiers</replaceable></literal>
</term><term><literal>_Pragma (&quot;GCC poison <replaceable>identifiers</replaceable>&quot;)</literal>
</term><listitem><para>Poisons the identifiers listed in <replaceable>identifiers</replaceable>.
</para>
<para>This is useful to make sure all mention of <replaceable>identifiers</replaceable> has been
deleted from the program and that no reference to them creeps back in.
If any of those identifiers appears anywhere in the source after the
directive, it causes a compilation error.  For example,
</para>
<screen>#pragma GCC poison printf sprintf fprintf
sprintf(some_string, &quot;hello&quot;);
</screen>
<para>generates an error.
</para>
<para>If a poisoned identifier appears as part of the expansion of a macro
that was defined before the identifier was poisoned, it will <emphasis>not</emphasis>
cause an error.  Thus, system headers that define macros that use
the identifier will not cause errors.
</para>
<para>For example,
</para>
<screen>#define strrchr rindex
_Pragma (&quot;GCC poison rindex&quot;)
strrchr(some_string, 'h');
</screen>
<para>does not cause a compilation error.
</para>
</listitem></varlistentry><varlistentry><term><literal>#pragma GCC system_header</literal>
</term><term><literal>_Pragma (&quot;GCC system_header&quot;)</literal>
</term><listitem><para>Specify treating the rest of the current source file as if it came
from a system header file.  See section &#8220;System Headers&#8221; in <citetitle>Using the GNU Compiler Collection</citetitle>.
</para>
</listitem></varlistentry><varlistentry><term><literal>#pragma GCC warning <replaceable>message</replaceable></literal>
</term><term><literal>_Pragma (&quot;GCC warning <replaceable>message</replaceable>&quot;)</literal>
</term><listitem><para>Equivalent to <literal>#warning</literal>.  Its advantage is that the
<literal>_Pragma</literal> form can be included in a macro definition.
</para>
</listitem></varlistentry><varlistentry><term><literal>#pragma GCC error <replaceable>message</replaceable></literal>
</term><term><literal>_Pragma (&quot;GCC error <replaceable>message</replaceable>&quot;)</literal>
</term><listitem><para>Equivalent to <literal>#error</literal>.  Its advantage is that the
<literal>_Pragma</literal> form can be included in a macro definition.
</para>
</listitem></varlistentry><varlistentry><term><literal>#pragma GCC message <replaceable>message</replaceable></literal>
</term><term><literal>_Pragma (&quot;GCC message <replaceable>message</replaceable>&quot;)</literal>
</term><listitem><para>Similar to &#8216;<literal>GCC warning</literal>&#8217; and &#8216;<literal>GCC error</literal>&#8217;, this simply prints an
informational message, and could be used to include additional warning
or error text without triggering more warnings or errors.  (Note that
unlike &#8216;<literal>warning</literal>&#8217; and &#8216;<literal>error</literal>&#8217;, &#8216;<literal>message</literal>&#8217; does not include
&#8216;<literal>GCC</literal>&#8217; as part of the pragma.)
</para></listitem></varlistentry></variablelist>
</sect2>
<sect2 label="30.1.2" id="Severity-Pragmas">
<title>Severity Pragmas</title>

<para>These pragmas control the severity of classes of diagnostics.
You can specify the class of diagnostic with the GCC option that causes
those diagnostics to be generated.
</para>
<variablelist><varlistentry><term><literal>#pragma GCC diagnostic error <replaceable>option</replaceable></literal>
</term><term><literal>_Pragma (&quot;GCC diagnostic error <replaceable>option</replaceable>&quot;)</literal>
</term><listitem><para>For code following this pragma, treat diagnostics of the variety
specified by <replaceable>option</replaceable> as errors.  For example:
</para>
<screen>_Pragma (&quot;GCC diagnostic error -Wformat&quot;)
</screen>
<para>specifies to treat diagnostics enabled by the <replaceable>-Wformat</replaceable> option
as errors rather than warnings.
</para>
</listitem></varlistentry><varlistentry><term><literal>#pragma GCC diagnostic warning <replaceable>option</replaceable></literal>
</term><term><literal>_Pragma (&quot;GCC diagnostic warning <replaceable>option</replaceable>&quot;)</literal>
</term><listitem><para>For code following this pragma, treat diagnostics of the variety
specified by <replaceable>option</replaceable> as warnings.  This overrides the
<replaceable>-Werror</replaceable> option which says to treat warnings as errors.
</para>
</listitem></varlistentry><varlistentry><term><literal>#pragma GCC diagnostic ignore <replaceable>option</replaceable></literal>
</term><term><literal>_Pragma (&quot;GCC diagnostic ignore <replaceable>option</replaceable>&quot;)</literal>
</term><listitem><para>For code following this pragma, refrain from reporting any diagnostics
of the variety specified by <replaceable>option</replaceable>.
</para>
</listitem></varlistentry><varlistentry><term><literal>#pragma GCC diagnostic push</literal>
</term><term><literal>_Pragma (&quot;GCC diagnostic push&quot;)</literal>
</term><term><literal>#pragma GCC diagnostic pop</literal>
</term><term><literal>_Pragma (&quot;GCC diagnostic pop&quot;)</literal>
</term><listitem><para>These pragmas maintain a stack of states for severity settings.
&#8216;<literal>GCC diagnostic push</literal>&#8217; saves the current settings on the stack,
and &#8216;<literal>GCC diagnostic pop</literal>&#8217; pops the last stack item and restores
the current settings from that.
</para>
<para>&#8216;<literal>GCC diagnostic pop</literal>&#8217; when the severity setting stack is empty
restores the settings to what they were at the start of compilation.
</para>
<para>Here is an example:
</para>
<screen>_Pragma (&quot;GCC diagnostic error -Wformat&quot;)

/* <option>-Wformat</option> messages treated as errors.  */

_Pragma (&quot;GCC diagnostic push&quot;)
_Pragma (&quot;GCC diagnostic warning -Wformat&quot;)

/* <option>-Wformat</option> messages treated as warnings.  */

_Pragma (&quot;GCC diagnostic push&quot;)
_Pragma (&quot;GCC diagnostic ignored -Wformat&quot;)

/* <option>-Wformat</option> messages suppressed.  */

_Pragma (&quot;GCC diagnostic pop&quot;)

/* <option>-Wformat</option> messages treated as warnings again.  */

_Pragma (&quot;GCC diagnostic pop&quot;)

/* <option>-Wformat</option> messages treated as errors again.  */

/* This is an excess &#8216;<literal>pop</literal>&#8217; that matches no &#8216;<literal>push</literal>&#8217;.  */
_Pragma (&quot;GCC diagnostic pop&quot;)

/* <option>-Wformat</option> messages treated once again
   as specified by the GCC command-line options.  */
</screen></listitem></varlistentry></variablelist>
</sect2>
<sect2 label="30.1.3" id="Optimization-Pragmas">
<title>Optimization Pragmas</title>

<para>These pragmas enable a particular optimization for specific function
definitions.  The settings take effect at the end of a function
definition, so the clean place to use these pragmas is between
function definitions.
</para>
<variablelist><varlistentry><term><literal>#pragma GCC optimize <replaceable>optimization</replaceable></literal>
</term><term><literal>_Pragma (&quot;GCC optimize <replaceable>optimization</replaceable>&quot;)</literal>
</term><listitem><para>These pragmas enable the optimization <replaceable>optimization</replaceable> for the
following functions.  For example,
</para>
<screen>_Pragma (&quot;GCC optimize -fforward-propagate&quot;)
</screen>
<para>says to apply the &#8216;<literal>forward-propagate</literal>&#8217; optimization to all
following function definitions.  Specifying optimizations for
individual functions, rather than for the entire program, is rare but
can be useful for getting around a bug in the compiler.
</para>
<para>If <replaceable>optimization</replaceable> does not correspond to a defined optimization
option, the pragma is erroneous.  To turn off an optimization, use the
corresponding &#8216;<literal>-fno-</literal>&#8217; option, such as
&#8216;<literal>-fno-forward-propagate</literal>&#8217;.
</para>
</listitem></varlistentry><varlistentry><term><literal>#pragma GCC target <replaceable>optimizations</replaceable></literal>
</term><term><literal>_Pragma (&quot;GCC target <replaceable>optimizations</replaceable>&quot;)</literal>
</term><listitem><para>The pragma &#8216;<literal>GCC target</literal>&#8217; is similar to &#8216;<literal>GCC optimize</literal>&#8217; but is
used for platform-specific optimizations.  Thus,
</para>
<screen>_Pragma (&quot;GCC target popcnt&quot;)
</screen>
<para>activates the optimization &#8216;<literal>popcnt</literal>&#8217; for all
following function definitions.  This optimization is supported
on a few common targets but not on others.
</para>
</listitem></varlistentry><varlistentry><term><literal>#pragma GCC push_options</literal>
</term><term><literal>_Pragma (&quot;GCC push_options&quot;)</literal>
</term><listitem><para>The &#8216;<literal>push_options</literal>&#8217; pragma saves on a stack the current settings
specified with the &#8216;<literal>target</literal>&#8217; and &#8216;<literal>optimize</literal>&#8217; pragmas.
</para>
</listitem></varlistentry><varlistentry><term><literal>#pragma GCC pop_options</literal>
</term><term><literal>_Pragma (&quot;GCC pop_options&quot;)</literal>
</term><listitem><para>The &#8216;<literal>pop_options</literal>&#8217; pragma pops saved settings from that stack.
</para>
<para>Here&#8217;s an example of using this stack.
</para>
<screen>_Pragma (&quot;GCC push_options&quot;)
_Pragma (&quot;GCC optimize forward-propagate&quot;)

/* Functions to compile
   with the <literal>forward-propagate</literal> optimization. */

_Pragma (&quot;GCC pop_options&quot;)
/* Ends enablement of <literal>forward-propagate</literal>. */
</screen>
</listitem></varlistentry><varlistentry><term><literal>#pragma GCC reset_options</literal>
</term><term><literal>_Pragma (&quot;GCC reset_options&quot;)</literal>
</term><listitem><para>Clears all pragma-defined &#8216;<literal>target</literal>&#8217; and &#8216;<literal>optimize</literal>&#8217;
optimization settings.
</para></listitem></varlistentry></variablelist>
</sect2>
</sect1>
<sect1 label="30.2" id="Static-Assertions">
<title>Static Assertions</title>
<indexterm role="cp"><primary>static assertions</primary></indexterm>
<indexterm role="fn"><primary>_Static_assert</primary></indexterm>

<para>You can add compiler-time tests for necessary conditions into your
code using <literal>_Static_assert</literal>.  This can be useful, for example, to
check that the compilation target platform supports the type sizes
that the code expects.  For example,
</para>
<screen>_Static_assert ((sizeof (long int) &gt;= 8),
    &quot;long int needs to be at least 8 bytes&quot;);
</screen>
<para>reports a compile-time error if compiled on a system with long
integers smaller than 8 bytes, with &#8216;<literal>long int needs to be at
least 8 bytes</literal>&#8217; as the error message.
</para>
<para>Since calls <literal>_Static_assert</literal> are processed at compile time, the
expression must be computable at compile time and the error message
must be a literal string.  The expression can refer to the sizes of
variables, but can&#8217;t refer to their values.  For example, the
following static assertion is invalid for two reasons:
</para>
<screen>char *error_message
  = &quot;long int needs to be at least 8 bytes&quot;;
int size_of_long_int = sizeof (long int);

_Static_assert (size_of_long_int == 8, error_message);
</screen>
<para>The expression <literal>size_of_long_int == 8</literal> isn&#8217;t computable at
compile time, and the error message isn&#8217;t a literal string.
</para>
<para>You can, though, use preprocessor definition values with
<literal>_Static_assert</literal>:
</para>
<screen>#define LONG_INT_ERROR_MESSAGE &quot;long int needs to be \
at least 8 bytes&quot;

_Static_assert ((sizeof (long int) == 8),
  LONG_INT_ERROR_MESSAGE);
</screen>
<para>Static assertions are permitted wherever a statement or declaration is
permitted, including at top level in the file, and also inside the
definition of a type.
</para>
<screen>union y
{
  int i;
  int *ptr;
  _Static_assert (sizeof (int *) == sizeof (int),
		  &quot;Pointer and int not same size&quot;);
};
</screen>
</sect1>
</chapter>
<appendix label="A" id="Type-Alignment">
<title>Type Alignment</title>
<indexterm role="cp"><primary>type alignment</primary></indexterm>
<indexterm role="cp"><primary>alignment of type</primary></indexterm>
<indexterm role="fn"><primary>_Alignof</primary></indexterm>
<indexterm role="fn"><primary>__alignof__</primary></indexterm>

<para>Code for device drivers and other communication with low-level
hardware sometimes needs to be concerned with the alignment of
data objects in memory.
</para>
<para>Each data type has a required <firstterm>alignment</firstterm>, always a power of 2,
that says at which memory addresses an object of that type can validly
start.  A valid address for the type must be a multiple of its
alignment.  If a type&#8217;s alignment is 1, that means it can validly
start at any address.  If a type&#8217;s alignment is 2, that means it can
only start at an even address.  If a type&#8217;s alignment is 4, that means
it can only start at an address that is a multiple of 4.
</para>
<para>The alignment of a type (except <literal>char</literal>) can vary depending on the
kind of computer in use.  To refer to the alignment of a type in a C
program, use <literal>_Alignof</literal>, whose syntax parallels that of
<literal>sizeof</literal>.  Like <literal>sizeof</literal>, <literal>_Alignof</literal> is a compile-time
operation, and it doesn&#8217;t compute the value of the expression used
as its argument.
</para>
<para>Nominally, each integer and floating-point type has an alignment equal to
the largest power of 2 that divides its size.  Thus, <literal>int</literal> with
size 4 has a nominal alignment of 4, and <literal>long long int</literal> with
size 8 has a nominal alignment of 8.
</para>
<para>However, each kind of computer generally has a maximum alignment, and
no type needs more alignment than that.  If the computer&#8217;s maximum
alignment is 4 (which is common), then no type&#8217;s alignment is more
than 4.
</para>
<para>The size of any type is always a multiple of its alignment; that way,
in an array whose elements have that type, all the elements are
properly aligned if the first one is.
</para>
<para>These rules apply to all real computers today, but some embedded
controllers have odd exceptions.  We don&#8217;t have references to cite for
them.
<!-- We can't cite a nonfree manual as documentation. -->
</para>
<para>Ordinary C code guarantees that every object of a given type is in
fact aligned as that type requires.
</para>
<para>If the operand of <literal>_Alignof</literal> is a structure field, the value
is the alignment it requires.  It may have a greater alignment by
coincidence, due to the other fields, but <literal>_Alignof</literal> is not
concerned about that.  See <link linkend="Structures">Structures</link>.
</para>
<para>Older versions of GNU C used the keyword <literal>__alignof__</literal> for this,
but now that the feature has been standardized, it is better
to use the standard keyword <literal>_Alignof</literal>.
</para>
<indexterm role="fn"><primary>_Alignas</primary></indexterm>
<indexterm role="fn"><primary>__aligned__</primary></indexterm>
<para>You can explicitly specify an alignment requirement for a particular
variable or structure field by adding <literal>_Alignas
(<replaceable>alignment</replaceable>)</literal> to the declaration, where <replaceable>alignment</replaceable> is a
power of 2 or a type name.  For instance:
</para>
<screen>char _Alignas (8) x;
</screen>
<para>or
</para>
<screen>char _Alignas (double) x;
</screen>
<para>specifies that <literal>x</literal> must start on an address that is a multiple of
8.  However, if <replaceable>alignment</replaceable> exceeds the maximum alignment for the
machine, that maximum is how much alignment <literal>x</literal> will get.
</para>
<para>The older GNU C syntax for this feature looked like
<literal>__attribute__ ((__aligned__ (<replaceable>alignment</replaceable>)))</literal> to the
declaration, and was added after the variable.  For instance:
</para>
<screen>char x __attribute__ ((__aligned__ 8));
</screen>
<para>See <link linkend="Attributes">Attributes</link>.
</para>
</appendix>
<appendix label="B" id="Aliasing">
<title>Aliasing</title>
<indexterm role="cp"><primary>aliasing (of storage)</primary></indexterm>
<indexterm role="cp"><primary>pointer type conversion</primary></indexterm>
<indexterm role="cp"><primary>type conversion, pointer</primary></indexterm>

<para>We have already presented examples of casting a <literal>void *</literal> pointer
to another pointer type, and casting another pointer type to
<literal>void *</literal>.
</para>
<para>One common kind of pointer cast is guaranteed safe: casting the value
returned by <literal>malloc</literal> and related functions (see <link linkend="Dynamic-Memory-Allocation">Dynamic Memory
Allocation</link>).  It is safe because these functions do not save the
pointer anywhere else; the only way the program will access the newly
allocated memory is via the pointer just returned.
</para>
<para>In fact, C allows casting any pointer type to any other pointer type.
Using this to access the same place in memory using two
different data types is called <firstterm>aliasing</firstterm>.
</para>
<para>Aliasing is necessary in some programs that do sophisticated memory
management, such as GNU Emacs, but most C programs don&#8217;t need to do
aliasing.  When it isn&#8217;t needed, <emphasis role="bold">stay away from it!</emphasis>  To do
aliasing correctly requires following the rules stated below.
Otherwise, the aliasing may result in malfunctions when the program
runs.
</para>
<para>The rest of this appendix explains the pitfalls and rules of aliasing.
</para>

<sect1 label="B.1" id="Aliasing-Alignment">
<title>Aliasing and Alignment</title>

<para>In order for a type-converted pointer to be valid, it must have the
alignment that the new pointer type requires.  For instance, on most
computers, <literal>int</literal> has alignment 4; the address of an <literal>int</literal>
must be a multiple of 4.  However, <literal>char</literal> has alignment 1, so the
address of a <literal>char</literal> is usually not a multiple of 4.  Taking the
address of such a <literal>char</literal> and casting it to <literal>int *</literal> probably
results in an invalid pointer.  Trying to dereference it may cause a
<literal>SIGBUS</literal> signal, depending on the platform in use (see <link linkend="Signals">Signals</link>).
</para>
<screen>foo ()
{
  char i[4];
  int *p = (int *) &amp;i[1]; /* Misaligned pointer! */
  return *p;              /* Crash! */
}
</screen>
<para>This requirement is never a problem when casting the return value
of <literal>malloc</literal> because that function always returns a pointer
with as much alignment as any type can require.
</para>
</sect1>
<sect1 label="B.2" id="Aliasing-Length">
<title>Aliasing and Length</title>

<para>When converting a pointer to a different pointer type, make sure the
object it really points to is at least as long as the target of the
converted pointer.  For instance, suppose <literal>p</literal> has type <literal>int
*</literal> and it&#8217;s cast as follows:
</para>
<screen>int *p;

struct
  {
    double d, e, f;
  } foo;

struct foo *q = (struct foo *)p;

q-&gt;f = 5.14159;
</screen>
<para>the value <literal>q-&gt;f</literal> will run past the end of the <literal>int</literal> that
<literal>p</literal> points to.  If <literal>p</literal> was initialized to the start of an
array of type <literal>int[6]</literal>, the object is long enough for three
<literal>double</literal>s.  But if <literal>p</literal> points to something shorter,
<literal>q-&gt;f</literal> will run on beyond the end of that, overlaying some other
data.  Storing that will garble that other data.  Or it could extend
past the end of memory space and cause a <literal>SIGSEGV</literal> signal
(see <link linkend="Signals">Signals</link>).
</para>
</sect1>
<sect1 label="B.3" id="Aliasing-Type-Rules">
<title>Type Rules for Aliasing</title>

<para>C code that converts a pointer to a different pointer type can use the
pointers to access the same memory locations with two different data
types.  If the same address is accessed with different types in a
single control thread, optimization can make the code do surprising
things (in effect, make it malfunction).
</para>
<para>Here&#8217;s a concrete example where aliasing that can change the code&#8217;s
behavior when it is optimized.  We assume that <literal>float</literal> is 4 bytes
long, like <literal>int</literal>, and so is every pointer.  Thus, the structures
<literal>struct a</literal> and <literal>struct b</literal> are both 8 bytes.
</para>
<screen>#include &lt;stdio.h&gt;
struct a { int size; char *data; };
struct b { float size; char *data; };

void sub (struct a *p, struct b *q)
{
  int x;
  p-&gt;size = 0;
  q-&gt;size = 1;
  x = p-&gt;size;
  printf(&quot;x       =%d\n&quot;, x);
  printf(&quot;p-&gt;size =%d\n&quot;, (int)p-&gt;size);
  printf(&quot;q-&gt;size =%d\n&quot;, (int)q-&gt;size);
}

int main(void)
{
  struct a foo;
  struct a *p = &amp;foo;
  struct b *q = (struct b *) &amp;foo;

  sub (p, q);
}
</screen>
<para>This code works as intended when compiled without optimization.  All
the operations are carried out sequentially as written.  The code
sets <literal>x</literal> to <literal>p-&gt;size</literal>, but what it actually gets is the
bits of the floating point number 1, as type <literal>int</literal>.
</para>
<para>However, when optimizing, the compiler is allowed to assume
(mistakenly, here) that <literal>q</literal> does not point to the same storage as
<literal>p</literal>, because their data types are not allowed to alias.
</para>
<para>From this assumption, the compiler can deduce (falsely, here) that the
assignment into <literal>q-&gt;size</literal> has no effect on the value of
<literal>p-&gt;size</literal>, which must therefore still be 0.  Thus, <literal>x</literal> will
be set to 0.
</para>
<para>GNU C, following the C standard, <emphasis>defines</emphasis> this optimization as
legitimate.  Code that misbehaves when optimized following these rules
is, by definition, incorrect C code.
</para>
<para>The rules for storage aliasing in C are based on the two data types:
the type of the object, and the type it is accessed through.  The
rules permit accessing part of a storage object of type <replaceable>t</replaceable> using
only these types:
</para>
<itemizedlist><listitem><para><replaceable>t</replaceable>.
</para>
</listitem><listitem><para>A type compatible with <replaceable>t</replaceable>.  See <link linkend="Compatible-Types">Compatible Types</link>.
</para>
</listitem><listitem><para>A signed or unsigned version of one of the above.
</para>
</listitem><listitem><para>A qualifed version of one of the above.
See <link linkend="Type-Qualifiers">Type Qualifiers</link>.
</para>
</listitem><listitem><para>An array, structure (see <link linkend="Structures">Structures</link>), or union type
(<literal>Unions</literal>) that contains one of the above, either directly as a
field or through multiple levels of fields.  If <replaceable>t</replaceable> is
<literal>double</literal>, this would include <literal>struct s { union { double
d[2]; int i[4]; } u; int i; };</literal> because there&#8217;s a <literal>double</literal>
inside it somewhere.
</para>
</listitem><listitem><para>A character type.                                                            
</para></listitem></itemizedlist>
<para>What do these rules say about the example in this subsection?
</para>
<para>For <literal>foo.size</literal> (equivalently, <literal>a-&gt;size</literal>), <replaceable>t</replaceable> is
<literal>int</literal>.  The type <literal>float</literal> is not allowed as an aliasing type
by those rules, so <literal>b-&gt;size</literal> is not supposed to alias with
elements of <literal>j</literal>.  Based on that assumption, GNU C makes a
permitted optimization that was not, in this case, consistent with
what the programmer intended the program to do.
</para>
<para>Whether GCC actually performs type-based aliasing analysis depends on
the details of the code.  GCC has other ways to determine (in some cases)
whether objects alias, and if it gets a reliable answer that way, it won&#8217;t
fall back on type-based heuristics.
</para>
<!-- @opindex -fno-strict-aliasing -->
<para>The importance of knowing the type-based aliasing rules is not so as
to ensure that the optimization is done where it would be safe, but so
as to ensure it is <emphasis>not</emphasis> done in a way that would break the
program.  You can turn off type-based aliasing analysis by giving GCC
the option <option>-fno-strict-aliasing</option>.
</para>
</sect1>
</appendix>
<appendix label="C" id="Digraphs">
<title>Digraphs</title>
<indexterm role="cp"><primary>digraphs</primary></indexterm>

<para>C accepts aliases for certain characters.  Apparently in the 1990s
some computer systems had trouble inputting these characters, or
trouble displaying them.  These digraphs almost never appear in C
programs nowadays, but we mention them for completeness.
</para>
<variablelist><varlistentry><term>&#8216;<literal>&lt;:</literal>&#8217;
</term><listitem><para>An alias for &#8216;<literal>[</literal>&#8217;.
</para></listitem></varlistentry><varlistentry><term>&#8216;<literal>:&gt;</literal>&#8217;
</term><listitem><para>An alias for &#8216;<literal>]</literal>&#8217;.
</para></listitem></varlistentry><varlistentry><term>&#8216;<literal>&lt;%</literal>&#8217;
</term><listitem><para>An alias for &#8216;<literal>{</literal>&#8217;.
</para></listitem></varlistentry><varlistentry><term>&#8216;<literal>%&gt;</literal>&#8217;
</term><listitem><para>An alias for &#8216;<literal>}</literal>&#8217;.
</para></listitem></varlistentry><varlistentry><term>&#8216;<literal>%:</literal>&#8217;
</term><listitem><para>An alias for &#8216;<literal>#</literal>&#8217;,
used for preprocessing directives (see <link linkend="Directives">Directives</link>) and
macros (see <link linkend="Macros">Macros</link>).
</para></listitem></varlistentry></variablelist>
</appendix>
<appendix label="D" id="Attributes">
<title>Attributes in Declarations</title>
<indexterm role="cp"><primary>attributes</primary></indexterm>
<indexterm role="fn"><primary>__attribute__</primary></indexterm>

<para>You can specify certain additional requirements in a declaration, to
get fine-grained control over code generation, and helpful
informational messages during compilation.  We use a few attributes in
code examples throughout this manual, including
</para>
<variablelist><varlistentry><term><literal>aligned</literal>
</term><listitem><para>The <literal>aligned</literal> attribute specifies a minimum alignment for a
variable or structure field, measured in bytes:
</para>
<screen>int foo __attribute__ ((aligned (8))) = 0;
</screen>
<para>This directs GNU C to allocate <literal>foo</literal> at an address that is a
multiple of 8 bytes.  However, you can&#8217;t force an alignment bigger
than the computer&#8217;s maximum meaningful alignment.
</para>
</listitem></varlistentry><varlistentry><term><literal>packed</literal>
</term><listitem><para>The <literal>packed</literal> attribute specifies to compact the fields of a
structure by not leaving gaps between fields.  For example,
</para>
<screen>struct __attribute__ ((packed)) bar
{
  char a;
  int b;
};
</screen>
<para>allocates the integer field <literal>b</literal> at byte 1 in the structure,
immediately after the character field <literal>a</literal>.  The packed structure
is just 5 bytes long (assuming <literal>int</literal> is 4 bytes) and its
alignment is 1, that of <literal>char</literal>.
</para>
</listitem></varlistentry><varlistentry><term><literal>deprecated</literal>
</term><listitem><para>Applicable to both variables and functions, the <literal>deprecated</literal>
attribute tells the compiler to issue a warning if the variable or
function is ever used in the source file.
</para>
<screen>int old_foo __attribute__ ((deprecated));

int old_quux () __attribute__ ((deprecated));
</screen>
</listitem></varlistentry><varlistentry><term><literal>__noinline__</literal>
</term><listitem><para>The <literal>__noinline__</literal> attribute, in a function&#8217;s declaration or
definition, specifies never to inline calls to that function.  All
calls to that function, in a compilation unit where it has this
attribute, will be compiled to invoke the separately compiled
function.  See <link linkend="Inline-Function-Definitions">Inline Function Definitions</link>.
</para>
</listitem></varlistentry><varlistentry><term><literal>__noclone__</literal>
</term><listitem><para>The <literal>__noclone__</literal> attribute, in a function&#8217;s declaration or
definition, specifies never to clone that function.  Thus, there will
be only one compiled version of the function.  See <link linkend="Label-Value-Caveats">Label Value
Caveats</link>, for more information about cloning.
</para>
</listitem></varlistentry><varlistentry><term><literal>always_inline</literal>
</term><listitem><para>The <literal>always_inline</literal> attribute, in a function&#8217;s declaration or
definition, specifies to inline all calls to that function (unless
something about the function makes inlining impossible).  This applies
to all calls to that function in a compilation unit where it has this
attribute.  See <link linkend="Inline-Function-Definitions">Inline Function Definitions</link>.
</para>
</listitem></varlistentry><varlistentry><term><literal>gnu_inline</literal>
</term><listitem><para>The <literal>gnu_inline</literal> attribute, in a function&#8217;s declaration or
definition, specifies to handle the <literal>inline</literal> keywprd the way GNU
C originally implemented it, many years before ISO C said anything
about inlining.  See <link linkend="Inline-Function-Definitions">Inline Function Definitions</link>.
</para></listitem></varlistentry></variablelist>
<para>For full documentation of attributes, see the GCC manual.
See section &#8220;System Headers&#8221; in <citetitle>Using
the GNU Compiler Collection</citetitle>.
</para>
</appendix>
<appendix label="E" id="Signals">
<title>Signals</title>
<indexterm role="cp"><primary>signal</primary></indexterm>
<indexterm role="cp"><primary>handler (for signal)</primary></indexterm>
<indexterm role="cp"><primary><literal>SIGSEGV</literal></primary></indexterm>
<indexterm role="cp"><primary><literal>SIGFPE</literal></primary></indexterm>
<indexterm role="cp"><primary><literal>SIGBUS</literal></primary></indexterm>

<para>Some program operations bring about an error condition called a
<firstterm>signal</firstterm>.  These signals terminate the program, by default.
</para>
<para>There are various different kinds of signals, each with a name.  We
have seen several such error conditions through this manual:
</para>
<variablelist><varlistentry><term><literal>SIGSEGV</literal>
</term><listitem><para>This signal is generated when a program tries to read or write outside
the memory that is allocated for it, or to write memory that can only
be read.  The name is an abbreviation for &#8220;segmentation violation&#8221;.
</para>
</listitem></varlistentry><varlistentry><term><literal>SIGFPE</literal>
</term><listitem><para>This signal indicates a fatal arithmetic error.  The name is an
abbreviation for &#8220;floating-point exception&#8221;, but covers all types of
arithmetic errors, including division by zero and overflow.
</para>
</listitem></varlistentry><varlistentry><term><literal>SIGBUS</literal>
</term><listitem><para>This signal is generated when an invalid pointer is dereferenced,
typically the result of dereferencing an uninintalized pointer.  It is
similar to <literal>SIGSEGV</literal>, except that <literal>SIGSEGV</literal> indicates
invalid access to valid memory, while <literal>SIGBUS</literal> indicates an
attempt to access an invalid address.
</para></listitem></varlistentry></variablelist>
<para>These kinds of signal allow the program to specify a function as a
<firstterm>signal handler</firstterm>.  When a signal has a handler, it doesn&#8217;t
terminate the program; instead it calls the handler.
</para>
<para>There are many other kinds of signal; here we list only those that
come from run-time errors in C operations.  The rest have to do with
the functioning of the operating system.  The GNU C Library Reference
Manual gives more explanation about signals (see section &#8220;The GNU C Library&#8221; in <citetitle>The GNU C Library Reference
Manual</citetitle>).
</para>
</appendix>
<appendix label="F" id="GNU-Free-Documentation-License">
<title>GNU Free Documentation License</title>

<!-- The GNU Free Documentation License. -->
Version 1.3, 3 November 2008

<!-- This file is intended to be included within another document, -->
<!-- hence no sectioning command or @node. -->

<literallayout>Copyright &#169; 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
<ulink url="http://fsf.org/">http://fsf.org/</ulink>

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.
</literallayout>
<orderedlist numeration="arabic"><listitem><para>PREAMBLE
</para>
<para>The purpose of this License is to make a manual, textbook, or other
functional and useful document <firstterm>free</firstterm> in the sense of freedom: to
assure everyone the effective freedom to copy and redistribute it,
with or without modifying it, either commercially or noncommercially.
Secondarily, this License preserves for the author and publisher a way
to get credit for their work, while not being considered responsible
for modifications made by others.
</para>
<para>This License is a kind of &#8220;copyleft&#8221;, which means that derivative
works of the document must themselves be free in the same sense.  It
complements the GNU General Public License, which is a copyleft
license designed for free software.
</para>
<para>We have designed this License in order to use it for manuals for free
software, because free software needs free documentation: a free
program should come with manuals providing the same freedoms that the
software does.  But this License is not limited to software manuals;
it can be used for any textual work, regardless of subject matter or
whether it is published as a printed book.  We recommend this License
principally for works whose purpose is instruction or reference.
</para>
</listitem><listitem><para>APPLICABILITY AND DEFINITIONS
</para>
<para>This License applies to any manual or other work, in any medium, that
contains a notice placed by the copyright holder saying it can be
distributed under the terms of this License.  Such a notice grants a
world-wide, royalty-free license, unlimited in duration, to use that
work under the conditions stated herein.  The &#8220;Document&#8221;, below,
refers to any such manual or work.  Any member of the public is a
licensee, and is addressed as &#8220;you&#8221;.  You accept the license if you
copy, modify or distribute the work in a way requiring permission
under copyright law.
</para>
<para>A &#8220;Modified Version&#8221; of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with
modifications and/or translated into another language.
</para>
<para>A &#8220;Secondary Section&#8221; is a named appendix or a front-matter section
of the Document that deals exclusively with the relationship of the
publishers or authors of the Document to the Document&#8217;s overall
subject (or to related matters) and contains nothing that could fall
directly within that overall subject.  (Thus, if the Document is in
part a textbook of mathematics, a Secondary Section may not explain
any mathematics.)  The relationship could be a matter of historical
connection with the subject or with related matters, or of legal,
commercial, philosophical, ethical or political position regarding
them.
</para>
<para>The &#8220;Invariant Sections&#8221; are certain Secondary Sections whose titles
are designated, as being those of Invariant Sections, in the notice
that says that the Document is released under this License.  If a
section does not fit the above definition of Secondary then it is not
allowed to be designated as Invariant.  The Document may contain zero
Invariant Sections.  If the Document does not identify any Invariant
Sections then there are none.
</para>
<para>The &#8220;Cover Texts&#8221; are certain short passages of text that are listed,
as Front-Cover Texts or Back-Cover Texts, in the notice that says that
the Document is released under this License.  A Front-Cover Text may
be at most 5 words, and a Back-Cover Text may be at most 25 words.
</para>
<para>A &#8220;Transparent&#8221; copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the
general public, that is suitable for revising the document
straightforwardly with generic text editors or (for images composed of
pixels) generic paint programs or (for drawings) some widely available
drawing editor, and that is suitable for input to text formatters or
for automatic translation to a variety of formats suitable for input
to text formatters.  A copy made in an otherwise Transparent file
format whose markup, or absence of markup, has been arranged to thwart
or discourage subsequent modification by readers is not Transparent.
An image format is not Transparent if used for any substantial amount
of text.  A copy that is not &#8220;Transparent&#8221; is called &#8220;Opaque&#8221;.
</para>
<para>Examples of suitable formats for Transparent copies include plain
ASCII without markup, Texinfo input format, La&tex; input
format, SGML or XML using a publicly available
DTD, and standard-conforming simple HTML,
PostScript or PDF designed for human modification.  Examples
of transparent image formats include PNG, XCF and
JPG.  Opaque formats include proprietary formats that can be
read and edited only by proprietary word processors, SGML or
XML for which the DTD and/or processing tools are
not generally available, and the machine-generated HTML,
PostScript or PDF produced by some word processors for
output purposes only.
</para>
<para>The &#8220;Title Page&#8221; means, for a printed book, the title page itself,
plus such following pages as are needed to hold, legibly, the material
this License requires to appear in the title page.  For works in
formats which do not have any title page as such, &#8220;Title Page&#8221; means
the text near the most prominent appearance of the work&#8217;s title,
preceding the beginning of the body of the text.
</para>
<para>The &#8220;publisher&#8221; means any person or entity that distributes copies
of the Document to the public.
</para>
<para>A section &#8220;Entitled XYZ&#8221; means a named subunit of the Document whose
title either is precisely XYZ or contains XYZ in parentheses following
text that translates XYZ in another language.  (Here XYZ stands for a
specific section name mentioned below, such as &#8220;Acknowledgements&#8221;,
&#8220;Dedications&#8221;, &#8220;Endorsements&#8221;, or &#8220;History&#8221;.)  To &#8220;Preserve the Title&#8221;
of such a section when you modify the Document means that it remains a
section &#8220;Entitled XYZ&#8221; according to this definition.
</para>
<para>The Document may include Warranty Disclaimers next to the notice which
states that this License applies to the Document.  These Warranty
Disclaimers are considered to be included by reference in this
License, but only as regards disclaiming warranties: any other
implication that these Warranty Disclaimers may have is void and has
no effect on the meaning of this License.
</para>
</listitem><listitem><para>VERBATIM COPYING
</para>
<para>You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the
copyright notices, and the license notice saying this License applies
to the Document are reproduced in all copies, and that you add no other
conditions whatsoever to those of this License.  You may not use
technical measures to obstruct or control the reading or further
copying of the copies you make or distribute.  However, you may accept
compensation in exchange for copies.  If you distribute a large enough
number of copies you must also follow the conditions in section 3.
</para>
<para>You may also lend copies, under the same conditions stated above, and
you may publicly display copies.
</para>
</listitem><listitem><para>COPYING IN QUANTITY
</para>
<para>If you publish printed copies (or copies in media that commonly have
printed covers) of the Document, numbering more than 100, and the
Document&#8217;s license notice requires Cover Texts, you must enclose the
copies in covers that carry, clearly and legibly, all these Cover
Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
the back cover.  Both covers must also clearly and legibly identify
you as the publisher of these copies.  The front cover must present
the full title with all words of the title equally prominent and
visible.  You may add other material on the covers in addition.
Copying with changes limited to the covers, as long as they preserve
the title of the Document and satisfy these conditions, can be treated
as verbatim copying in other respects.
</para>
<para>If the required texts for either cover are too voluminous to fit
legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.
</para>
<para>If you publish or distribute Opaque copies of the Document numbering
more than 100, you must either include a machine-readable Transparent
copy along with each Opaque copy, or state in or with each Opaque copy
a computer-network location from which the general network-using
public has access to download using public-standard network protocols
a complete Transparent copy of the Document, free of added material.
If you use the latter option, you must take reasonably prudent steps,
when you begin distribution of Opaque copies in quantity, to ensure
that this Transparent copy will remain thus accessible at the stated
location until at least one year after the last time you distribute an
Opaque copy (directly or through your agents or retailers) of that
edition to the public.
</para>
<para>It is requested, but not required, that you contact the authors of the
Document well before redistributing any large number of copies, to give
them a chance to provide you with an updated version of the Document.
</para>
</listitem><listitem><para>MODIFICATIONS
</para>
<para>You may copy and distribute a Modified Version of the Document under
the conditions of sections 2 and 3 above, provided that you release
the Modified Version under precisely this License, with the Modified
Version filling the role of the Document, thus licensing distribution
and modification of the Modified Version to whoever possesses a copy
of it.  In addition, you must do these things in the Modified Version:
</para>
<orderedlist numeration="upperalpha"><listitem><para>Use in the Title Page (and on the covers, if any) a title distinct
from that of the Document, and from those of previous versions
(which should, if there were any, be listed in the History section
of the Document).  You may use the same title as a previous version
if the original publisher of that version gives permission.
</para>
</listitem><listitem><para>List on the Title Page, as authors, one or more persons or entities
responsible for authorship of the modifications in the Modified
Version, together with at least five of the principal authors of the
Document (all of its principal authors, if it has fewer than five),
unless they release you from this requirement.
</para>
</listitem><listitem><para>State on the Title page the name of the publisher of the
Modified Version, as the publisher.
</para>
</listitem><listitem><para>Preserve all the copyright notices of the Document.
</para>
</listitem><listitem><para>Add an appropriate copyright notice for your modifications
adjacent to the other copyright notices.
</para>
</listitem><listitem><para>Include, immediately after the copyright notices, a license notice
giving the public permission to use the Modified Version under the
terms of this License, in the form shown in the Addendum below.
</para>
</listitem><listitem><para>Preserve in that license notice the full lists of Invariant Sections
and required Cover Texts given in the Document&#8217;s license notice.
</para>
</listitem><listitem><para>Include an unaltered copy of this License.
</para>
</listitem><listitem><para>Preserve the section Entitled &#8220;History&#8221;, Preserve its Title, and add
to it an item stating at least the title, year, new authors, and
publisher of the Modified Version as given on the Title Page.  If
there is no section Entitled &#8220;History&#8221; in the Document, create one
stating the title, year, authors, and publisher of the Document as
given on its Title Page, then add an item describing the Modified
Version as stated in the previous sentence.
</para>
</listitem><listitem><para>Preserve the network location, if any, given in the Document for
public access to a Transparent copy of the Document, and likewise
the network locations given in the Document for previous versions
it was based on.  These may be placed in the &#8220;History&#8221; section.
You may omit a network location for a work that was published at
least four years before the Document itself, or if the original
publisher of the version it refers to gives permission.
</para>
</listitem><listitem><para>For any section Entitled &#8220;Acknowledgements&#8221; or &#8220;Dedications&#8221;, Preserve
the Title of the section, and preserve in the section all the
substance and tone of each of the contributor acknowledgements and/or
dedications given therein.
</para>
</listitem><listitem><para>Preserve all the Invariant Sections of the Document,
unaltered in their text and in their titles.  Section numbers
or the equivalent are not considered part of the section titles.
</para>
</listitem><listitem><para>Delete any section Entitled &#8220;Endorsements&#8221;.  Such a section
may not be included in the Modified Version.
</para>
</listitem><listitem><para>Do not retitle any existing section to be Entitled &#8220;Endorsements&#8221; or
to conflict in title with any Invariant Section.
</para>
</listitem><listitem><para>Preserve any Warranty Disclaimers.
</para></listitem></orderedlist>
<para>If the Modified Version includes new front-matter sections or
appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or all
of these sections as invariant.  To do this, add their titles to the
list of Invariant Sections in the Modified Version&#8217;s license notice.
These titles must be distinct from any other section titles.
</para>
<para>You may add a section Entitled &#8220;Endorsements&#8221;, provided it contains
nothing but endorsements of your Modified Version by various
parties&#8212;for example, statements of peer review or that the text has
been approved by an organization as the authoritative definition of a
standard.
</para>
<para>You may add a passage of up to five words as a Front-Cover Text, and a
passage of up to 25 words as a Back-Cover Text, to the end of the list
of Cover Texts in the Modified Version.  Only one passage of
Front-Cover Text and one of Back-Cover Text may be added by (or
through arrangements made by) any one entity.  If the Document already
includes a cover text for the same cover, previously added by you or
by arrangement made by the same entity you are acting on behalf of,
you may not add another; but you may replace the old one, on explicit
permission from the previous publisher that added the old one.
</para>
<para>The author(s) and publisher(s) of the Document do not by this License
give permission to use their names for publicity for or to assert or
imply endorsement of any Modified Version.
</para>
</listitem><listitem><para>COMBINING DOCUMENTS
</para>
<para>You may combine the Document with other documents released under this
License, under the terms defined in section 4 above for modified
versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodified, and
list them all as Invariant Sections of your combined work in its
license notice, and that you preserve all their Warranty Disclaimers.
</para>
<para>The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy.  If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by
adding at the end of it, in parentheses, the name of the original
author or publisher of that section if known, or else a unique number.
Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.
</para>
<para>In the combination, you must combine any sections Entitled &#8220;History&#8221;
in the various original documents, forming one section Entitled
&#8220;History&#8221;; likewise combine any sections Entitled &#8220;Acknowledgements&#8221;,
and any sections Entitled &#8220;Dedications&#8221;.  You must delete all
sections Entitled &#8220;Endorsements.&#8221;
</para>
</listitem><listitem><para>COLLECTIONS OF DOCUMENTS
</para>
<para>You may make a collection consisting of the Document and other documents
released under this License, and replace the individual copies of this
License in the various documents with a single copy that is included in
the collection, provided that you follow the rules of this License for
verbatim copying of each of the documents in all other respects.
</para>
<para>You may extract a single document from such a collection, and distribute
it individually under this License, provided you insert a copy of this
License into the extracted document, and follow this License in all
other respects regarding verbatim copying of that document.
</para>
</listitem><listitem><para>AGGREGATION WITH INDEPENDENT WORKS
</para>
<para>A compilation of the Document or its derivatives with other separate
and independent documents or works, in or on a volume of a storage or
distribution medium, is called an &#8220;aggregate&#8221; if the copyright
resulting from the compilation is not used to limit the legal rights
of the compilation&#8217;s users beyond what the individual works permit.
When the Document is included in an aggregate, this License does not
apply to the other works in the aggregate which are not themselves
derivative works of the Document.
</para>
<para>If the Cover Text requirement of section 3 is applicable to these
copies of the Document, then if the Document is less than one half of
the entire aggregate, the Document&#8217;s Cover Texts may be placed on
covers that bracket the Document within the aggregate, or the
electronic equivalent of covers if the Document is in electronic form.
Otherwise they must appear on printed covers that bracket the whole
aggregate.
</para>
</listitem><listitem><para>TRANSLATION
</para>
<para>Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section 4.
Replacing Invariant Sections with translations requires special
permission from their copyright holders, but you may include
translations of some or all Invariant Sections in addition to the
original versions of these Invariant Sections.  You may include a
translation of this License, and all the license notices in the
Document, and any Warranty Disclaimers, provided that you also include
the original English version of this License and the original versions
of those notices and disclaimers.  In case of a disagreement between
the translation and the original version of this License or a notice
or disclaimer, the original version will prevail.
</para>
<para>If a section in the Document is Entitled &#8220;Acknowledgements&#8221;,
&#8220;Dedications&#8221;, or &#8220;History&#8221;, the requirement (section 4) to Preserve
its Title (section 1) will typically require changing the actual
title.
</para>
</listitem><listitem><para>TERMINATION
</para>
<para>You may not copy, modify, sublicense, or distribute the Document
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense, or distribute it is void, and
will automatically terminate your rights under this License.
</para>
<para>However, if you cease all violation of this License, then your license
from a particular copyright holder is reinstated (a) provisionally,
unless and until the copyright holder explicitly and finally
terminates your license, and (b) permanently, if the copyright holder
fails to notify you of the violation by some reasonable means prior to
60 days after the cessation.
</para>
<para>Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.
</para>
<para>Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, receipt of a copy of some or all of the same material does
not give you any rights to use it.
</para>
</listitem><listitem><para>FUTURE REVISIONS OF THIS LICENSE
</para>
<para>The Free Software Foundation may publish new, revised versions
of the GNU Free Documentation License from time to time.  Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.  See
<ulink url="http://www.gnu.org/copyleft/">http://www.gnu.org/copyleft/</ulink>.
</para>
<para>Each version of the License is given a distinguishing version number.
If the Document specifies that a particular numbered version of this
License &#8220;or any later version&#8221; applies to it, you have the option of
following the terms and conditions either of that specified version or
of any later version that has been published (not as a draft) by the
Free Software Foundation.  If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.  If the Document
specifies that a proxy can decide which future versions of this
License can be used, that proxy&#8217;s public statement of acceptance of a
version permanently authorizes you to choose that version for the
Document.
</para>
</listitem><listitem><para>RELICENSING
</para>
<para>&#8220;Massive Multiauthor Collaboration Site&#8221; (or &#8220;MMC Site&#8221;) means any
World Wide Web server that publishes copyrightable works and also
provides prominent facilities for anybody to edit those works.  A
public wiki that anybody can edit is an example of such a server.  A
&#8220;Massive Multiauthor Collaboration&#8221; (or &#8220;MMC&#8221;) contained in the
site means any set of copyrightable works thus published on the MMC
site.
</para>
<para>&#8220;CC-BY-SA&#8221; means the Creative Commons Attribution-Share Alike 3.0
license published by Creative Commons Corporation, a not-for-profit
corporation with a principal place of business in San Francisco,
California, as well as future copyleft versions of that license
published by that same organization.
</para>
<para>&#8220;Incorporate&#8221; means to publish or republish a Document, in whole or
in part, as part of another Document.
</para>
<para>An MMC is &#8220;eligible for relicensing&#8221; if it is licensed under this
License, and if all works that were first published under this License
somewhere other than this MMC, and subsequently incorporated in whole
or in part into the MMC, (1) had no cover texts or invariant sections,
and (2) were thus incorporated prior to November 1, 2008.
</para>
<para>The operator of an MMC Site may republish an MMC contained in the site
under CC-BY-SA on the same site at any time before August 1, 2009,
provided the MMC is eligible for relicensing.
</para>
</listitem></orderedlist>
<bridgehead renderas="sect1">ADDENDUM: How to use this License for your documents</bridgehead>

<para>To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and
license notices just after the title page:
</para>
<screen>  Copyright (C)  <replaceable>year</replaceable>  <replaceable>your name</replaceable>.
  Permission is granted to copy, distribute and/or modify this document
  under the terms of the GNU Free Documentation License, Version 1.3
  or any later version published by the Free Software Foundation;
  with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
  Texts.  A copy of the license is included in the section entitled ``GNU
  Free Documentation License''.
</screen>
<para>If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
replace the &#8220;with&#8230;Texts.&#8221; line with this:
</para>
<screen>    with the Invariant Sections being <replaceable>list their titles</replaceable>, with
    the Front-Cover Texts being <replaceable>list</replaceable>, and with the Back-Cover Texts
    being <replaceable>list</replaceable>.
</screen>
<para>If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.
</para>
<para>If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License,
to permit their use in free software.
</para>
<!-- Local Variables: -->
<!-- ispell-local-pdict: "ispell-dict" -->
<!-- End: -->

</appendix>
<chapter label="" id="Symbol-Index">
<title>Index of Symbols and Keywords</title>

<index role="fn"></index>

</chapter>
<chapter label="" id="Concept-Index">
<title>Concept Index</title>

<index role="cp"></index>

</chapter>
</book>
